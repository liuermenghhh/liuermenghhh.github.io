<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>运行时数据区</title>
      <link href="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630191719146.png" alt="image-20210630191719146" style="zoom: 50%;"><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630191758617.png" alt="image-20210630191758617" style="zoom: 50%;"><p>运行时数据区结构图：灰色的表示单独线程私有，红色的为多个线程共享</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p><p>Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，他会调用Java线程中的run（）方法。</p><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main (String []）的 main 线程以及所有这个 maih 线程自己创建的线程。</p><p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆オ不会变化。这种线程的执行类型包括”stop-the-world“的垃圾收集，线程收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li></ul><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器又叫PC寄存器（Program Counter Register）</p><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630195700935.png" alt="image-20210630195700935" style="zoom:50%;"><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址：或者，如果是在执行 native 方法，则是未指定值（undefined）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>它是唯一一个在 Java 虚拟机规范中没有规定任何 outofmemoryerror情况的区域</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630195745436.png" alt="image-20210630195745436" style="zoom:50%;"><p>PC寄存器用来存储指向下一条指令的地址，由执行引擎读取下一条指令。</p><h3 id="两个常见的问题"><a href="#两个常见的问题" class="headerlink" title="两个常见的问题"></a>两个常见的问题</h3><ul><li><p>使用PC寄存器存储字节码指令地址有什么用？<br>为什么使用PC寄存器记录当前线程的执行地址？</p><ul><li>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li><li>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</li></ul></li><li><p>PC寄存器为什么被设定为线程私有</p><ul><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和帧，程序计数器在各个线程之间互不影响。</li></ul></li></ul><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>虚拟机栈出现的背景</p><ul><li>为了跨平台</li></ul></li><li><p>优缺点</p><ul><li>指令集小，编译器容易实现</li><li>性能下降，实现同样的功能需要更多的指令</li></ul></li><li><p>内存中的栈与堆</p><ul><li>栈是运行时的单位，堆是存储的单位</li><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解的是数据存储的问题，即数据怎么放、放在哪儿。</li></ul></li><li><p>虚拟机栈基本内容</p><ul><li><p>Java虚拟机栈是什么</p><ul><li>Java 虚拟机（Java virtua Machine Stack），早期也叫 Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用</li><li>是线程私有的</li></ul></li><li><p>生命周期</p><ul><li>和线程一致</li></ul></li><li><p>作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回</li></ul></li><li><p>栈的特点（优点）</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进栈；执行结束后得出栈工作</li><li>对于栈来说不存在垃圾回收问题</li></ul></li><li><p>面试题：开发中遇到的异常有哪些</p><ul><li>栈中可能出现的异常</li><li>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的<ul><li>如果采用固定大小的 Java 虚拟机，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机允许的最大容量，Java 虚拟机将会抛出一个  Stackoverflowerror 异常。如图</li><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630200412469.png" alt="image-20210630200412469" style="zoom:50%;"></li><li>如果 Java 虚拟机可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 ourtofmemoryerror 异常</li></ul></li></ul></li></ul></li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>栈中存储什么</p><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><p>栈运行原理</p><ul><li>JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current  Method），定义这个方法的类就是当前类（Current Class）。</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li><li>不同线程中所包含的帧是不允许存在相互引用的，即不可能在一个帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前帧，使得前一个帧重新成为当前栈帧</li><li>Java 方法<strong>有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></li></ul><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><h4 id="局部变量表（Local-Variables"><a href="#局部变量表（Local-Variables" class="headerlink" title="局部变量表（Local Variables)"></a><strong>局部变量表</strong>（Local Variables)</h4><ul><li><p>基本概念</p><ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>定义为一个<strong>数字数组</strong>，主要用于存储<strong>方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及  returnAddress 类型。</strong></li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li><li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小決定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的空间，导致其嵌套调用次数就会少。</li><li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li><li><p>slot</p><ul><li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束</p></li><li><p>局部变量表，最基本的存储单元是 Slot（变量槽）</p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference), returnaddress 类型的变量。</p></li><li><p>在局部变量表里，32 位以内的类型只占用一个 slot（包括returnaddress 类型）,64 位的类型（long 和 double）占用两个 slot</p><ul><li>byte、short、char 在存储前被转换为 int, boolean 也被转换为 int,0 表示 false，非 0 表示 true。</li><li>long 和 double 则占据两个 slot。</li></ul></li><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问素引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个<strong>实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 slot 上</strong></p></li><li><p>如果需要访问局部变量表中个 64bit 的局部变量值时，只需要使用前一个素引即可。（比如：访问 long 或 doublea 类型变量）</p></li><li><p>如果<strong>当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 slot 处，</strong>其余的参数按照参数表顺序继续排列。</p></li></ul></li><li><p>slot的重复利用</p><ul><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630202519548.png" alt="image-20210630202519548" style="zoom: 44%;"></li><li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的的</li></ul></li><li><p>静态变量与局部变量的对比</p><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li><strong>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值</strong>。</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一定义了局部变量则必须人为的初始化，否则无法使用。</li></ul></li><li><p>补充说明</p><ul><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表<strong>中的变量也是重要的垃圾回收根节</strong>点，只要被局部变量表中直接或间接引用的对象都不会被回收</li></ul></li></ul><h4 id="操作数栈（Operand-Stack-（或表达式栈）"><a href="#操作数栈（Operand-Stack-（或表达式栈）" class="headerlink" title="操作数栈（Operand Stack)（或表达式栈）"></a><strong>操作数栈（</strong>Operand Stack)（或表达式栈）</h4><ul><li><p>基本概念</p><ul><li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack)</p></li><li><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据,即入(push)/出栈(pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ul></li><li><p>操作数栈</p><ul><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630203203881.png" alt="image-20210630203203881" style="zoom:40%;"></li><li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 code 属性中，为 max stack 的值</li><li>栈中的任何一个元素都是可以任意的 Java 数据类型</li><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入（push）和出（pop）操作来完成一次数据访问</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说 Java <strong>虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong></li></ul></li><li><p>栈顶缓存技术（Top-of-Stack  Cashing）</p><ul><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧湊，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</li><li>由于操作数是存储在内存中的,因此频繁地执行内存读/写操作必然会影 响执行速度。为了解决这个问题，Hotspot JVM 的设计者们提出了顶缓存（TS, Top-of- Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读/写次数，提升执行引擎的执行效率</li></ul></li></ul><h4 id="动态链接（Dynamic-Linking-（或指向运行时常量池的方法引用）"><a href="#动态链接（Dynamic-Linking-（或指向运行时常量池的方法引用）" class="headerlink" title="动态链接（Dynamic Linking)（或指向运行时常量池的方法引用）"></a><strong>动态链接（Dynamic Linking)（或指向运行时常量池的方法引用）</strong></h4><ul><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630204322351.png" alt="image-20210630204322351" style="zoom:40%;"></li><li><p>每一个帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p></li><li><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p></li><li><p>为什么需要常量池？</p><ul><li>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</li></ul></li><li><p>class文件中的常量池进入方法区就成了运行时常量池</p></li></ul><h5 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h5><h6 id="方法的绑定"><a href="#方法的绑定" class="headerlink" title="方法的绑定"></a>方法的绑定</h6><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p><ul><li><p>静态链接：</p><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情況下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p></li><li><p>动态链接：</p><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p></li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p><ul><li><p>早期绑定：</p><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p></li><li><p>晚期绑定：</p><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p></li></ul><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p><h6 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h6><ul><li>非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li><strong>静态方法、私有方法、final 方法、实例构造器、父类方法</strong>都是非虚方法</li><li>其他方法称为虚方法</li></ul><p><strong>非虚方法在类加载的解析阶段就可以进行解析。</strong></p><p>虚拟机中提供了以下几条方法调用指令：</p><ul><li>普通调用指令：</li></ul><ol><li>Invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>Invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本 </li><li>Invokevirtual: 调用所有虚方法 </li><li>Invokeinterface：调用接口方法</li></ol><ul><li>动态调用指令</li></ul><ol start="5"><li>Invokedynamic：动态解析出需要用的方法，然后执行</li></ol><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法。</p><p>关于Invokedynamic指令：</p><ul><li>JVM 字节码指令集一直比较稳定，一直到 Java7 中才増加了一个 invokedynamic 指令，这是 Java 为了实现「动态类型语言」支持而做的一种改进。</li><li>但是在 Java7 中并没有提供直接生成 invokedynamic：指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</li><li>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 台的动态语言的编译器。</li></ul><p>动态类型语言和静态类型语言</p><ul><li>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息：动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ul><h6 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h6><p>Java 语言中方法重写的本质：</p><ol><li><p>找到操作数顶的第一个元素所执行的对象的实际类型，记作 C</p></li><li><p>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结東；如果不通过，则返回 java.lang. IllegalAccesserror 异常。</p></li><li><p>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</p></li><li><p>如果始终没有找到合适的方法，则抛出 java.lang. AbstractMethodError 异常。</p></li></ol><p>IllegalAccessError 介绍：</p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h6 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h6><ul><li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method tabe)（非虚方法不会出现在中）来实现。使用索引表来代替找。</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>那么虚方法表什么时候被创建？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p></li></ul><h4 id="方法返回地址（Return-Address-（或方法正常退出或者异常退出的定义）"><a href="#方法返回地址（Return-Address-（或方法正常退出或者异常退出的定义）" class="headerlink" title="方法返回地址（Return Address)（或方法正常退出或者异常退出的定义）"></a>方法返回地址（Return Address)（或方法正常退出或者异常退出的定义）</h4><ul><li><p>存放调用该方法的pc寄存器的值。</p></li><li><p>一个方法的结束，有两种方式：</p><p>​    正常执行完成</p><p>​    出现未处理的异常，非正常退出</p></li><li><p>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定，帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去</p></li><li><p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p></li></ul><p>当一个方法开始执行后，只有两种方式可以退出这个方法</p><p>1、执行引擎遇到任一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口</p><ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含 i return（当返回值是 boolean、byte、char、 shorth 和 int 类型时使用）、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</li></ul><p>2、在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p><ul><li>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li></ul><p>本质上，方法的退出就是当前帧出的过程。此时，需要恢复上层防法的局部变量表、操作数、将返回值压入调用者栈帧的操作数、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：再谈类的加载器</title>
      <link href="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="01-概述"><a href="#01-概述" class="headerlink" title="01-概述"></a>01-概述</h2><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>Class Loader 是Java的核心组件，所有的 Class 都是由 Classloader 进行加载的，Classloader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang. Class 对象实例。然后交给Java 虚拟机进行链接、初始化等操作。因此，Classloader 在整个装载阶段，只能影响到类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为。至于它是否可以运行，则由 Execution Engine 决定。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194021203.png" alt="image-20210627194021203" style="zoom:33%;"><p>类加载器最早出现在Java1.0 版本中，那个时候只是单纯地为了满足Java Applet 应用而被研发出来。但如今类加载器却在 OSGi、字节码加解密领域大放异彩。这主要归功于Java 虚拟机的设计者们当初在设计挙加载器的时候，并没有考虑将它绑定在内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p><h3 id="1-大厂面试题"><a href="#1-大厂面试题" class="headerlink" title="1-大厂面试题"></a>1-大厂面试题</h3><p>蚂蚁金服：</p><p>深入分析 Classloader，双亲委派机制</p><p>类加载器的双亲委派模型是什么？</p><p>一面：双亲委派机制及使用原因</p><p>百度：</p><p>都有哪些类加载器，这些类加载器都加载哪些文件？</p><p>手写一个类加载器 Demo</p><p>Class 的 forname (“java.lang. String“）和 Class 的 getClassLoader（）的 loadClass (“java.1ang. String“）有什么区别？</p><p>腾讯：</p><p>什么是双亲委派模型？</p><p>类加载器有哪些？</p><p>小米</p><p>双亲委派模型介绍一下</p><p>滴滴：</p><p>简单说说你了解的类加载器</p><p>一面：讲一下双亲委派模型，以及其优点</p><p>字节跳动</p><p>什么是类加载器，类加载器有哪些？</p><p>京东</p><p>类加载器的双亲委派模型是什么？</p><p>双亲委派机制可以打破吗？为什么</p><h3 id="2-类的加载分类"><a href="#2-类的加载分类" class="headerlink" title="2-类的加载分类"></a>2-类的加载分类</h3><p><strong>显示加载VS隐示加载</strong></p><p>Class 文件的显式加载与隐式加载的方式是指 JVM 加载 class 文件到内存的方式。</p><p><strong>显式加载</strong>指的是在代码中通过调用 ClassLoader 加载 class 对象，如直接使用 <code>Class. forName (name）</code>或 <code>this.GetClass().GetClassLoader().loadClass()</code>加载 class 对象。</p><p><strong>隐式加载</strong>则是不直接在代码中调用 Classloader 的方法加载 class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 class 文件时，该类的 class 文件中引用了另外一个类的对象，此时额外引用的类将通过JVM 自动加载到内存中。</p><p>在日常开发以上两种方式一般会混合使用。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194649610.png" alt="image-20210627194649610" style="zoom: 25%;"><h3 id="3-类加载器的必要性"><a href="#3-类加载器的必要性" class="headerlink" title="3-类加载器的必要性"></a>3-类加载器的必要性</h3><p>一般情況下，java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li>避免在开发中遇到 java.lang. ClassNotFoundException 异常或 java.lang. NoClassDeffoundError 异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解问题</li><li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li><li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li></ul><h3 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4-命名空间"></a>4-命名空间</h3><ol><li>何为类的唯一性？</li></ol><p>对于任意一个类，都需要由加载<strong>它的类加载器和这个类本身</strong>一同确认其在Java 虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p><ol><li>命名空间</li></ol><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><h3 id="5-类加载机制的基本特征"><a href="#5-类加载机制的基本特征" class="headerlink" title="5-类加载机制的基本特征"></a>5-类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p><ul><li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK 内部的 ServiceProvider/ ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li></ul><h3 id="6-类加载器之间的关系"><a href="#6-类加载器之间的关系" class="headerlink" title="6-类加载器之间的关系"></a>6-类加载器之间的关系</h3><p><strong>Launcher.java类：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Launcher.ExtClassLoader var1;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError( <span class="string">&quot;Could not create extension class loader&quot;</span> , var10);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span> .loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError( <span class="string">&quot;Could not create application class loader&quot;</span> , var9);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Thread.currentThread().setContextClassLoader( <span class="keyword">this</span> .loader); </span><br><span class="line"></span><br><span class="line">         …… </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>分析： </p><p><strong>1、验证扩展类加载器的父类是null</strong> </p><p>先看：</p><p> <code>var1 = Launcher.ExtClassLoader.getExtClassLoader();</code> </p><p>获取到扩展类加载器，点击该方法往里面追溯，在找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Launcher.ExtClassLoader(var0);</span><br></pre></td></tr></table></figure><p>我们在点击该方法往里面追溯，在找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super (getExtURLs(var1), (ClassLoader) null , Launcher.factory);</span><br></pre></td></tr></table></figure><p>然后点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="params"><span class="function">            URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> ( checkCreateClassLoader (), parent);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>点击其中的parent就是null，我们点击this，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> . parent = parent; </span><br></pre></td></tr></table></figure><p>由于parent就是null，所以扩展类加载器的父类是null ，也就是引导类加载器，因此我们调用获取扩展类加载器父类的方法获得的结果是null</p><p> <strong>2、验证系统类加载器的父类是扩展类加载器</strong> </p><p>先看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> .loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br></pre></td></tr></table></figure><p>获取到系统类加载器，点击该方法往里面追溯，在找到：</p><p> <code>return new Launcher.AppClassLoader(var1x, var0);</code>  </p><p>其中var0就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">   <span class="keyword">super</span> (var1, var2, Launcher.factory);</span><br><span class="line">   <span class="keyword">this</span> .ucp.initLookupCache( <span class="keyword">this</span> );</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="params"><span class="function">            URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> ( checkCreateClassLoader (), parent);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> . parent = parent; </span><br></pre></td></tr></table></figure><p>由于parent就是扩展类加载器，所以系统类加载器的父类是扩展类加载器 ，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</p><p><strong>3、当前线程上下文的ClassLoader就是系统类加载器</strong> </p><p><code>Thread.currentThread().setContextClassLoader(this.loader)</code> 就是将系统类加载器设置为当前线程的上下文加载器，所以<code>Thread.currentThread().getContextClassLoader()</code> 获取到的就是系统类加载器</p><h2 id="02-复习"><a href="#02-复习" class="headerlink" title="02-复习"></a>02-复习</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-defined Classloader)</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 Classloader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627203246891.png" alt="image-20210627203246891" style="zoom:33%;"><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</p><p>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</p><p>下面的代码解释了包含的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">// 父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">// parent=new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p><h3 id="1-引导类加载器"><a href="#1-引导类加载器" class="headerlink" title="1-引导类加载器"></a>1-引导类加载器</h3><ul><li>这个类加载使用C/C++语言实现的,嵌套在JVM内部</li><li>它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容)。用于提供JVM 自身需要的类。</li><li>并不继承自 java.lang.Classloader，没有父加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为 java、javax、sun 头的类</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li></ul><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204027345.png" alt="image-20210627204027345" style="zoom:33%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204324564.png" alt="image-20210627204324564" style="zoom:33%;"><p>使用-XX:+TraceClassLoading参数得到。</p><p>启动类加载器使用C++编写的？yes！</p><ul><li>C/C++指针函数&amp;函数指针、C++支持多继承、更加高效</li><li>Java：由 C++演变而来，(C++) –版，单继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;*******启动类加载器********&quot;</span>);</span><br><span class="line">    URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">    <span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">        System.out.println(urL.toExternalForm());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*******启动类加载器********</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/classes</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassLoader classLoader=java.security.Provider.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2-扩展类加载器"></a>2-扩展类加载器</h3><ul><li>Java 语言编写，由sun.misc. Launcher$ExtClassLoader 实现。</li><li>继承于 Classloader 类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库,或从]DK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png" alt="image-20210627205013180" style="zoom: 50%;"><h3 id="3-系统类加载器"><a href="#3-系统类加载器" class="headerlink" title="3-系统类加载器"></a>3-系统类加载器</h3><ul><li>Java 语言编写，由 sun.misc. Launcher$AppClassLoader 实现</li><li>继承于 Classloader 类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量 classpath 或系统属性java.class.path 指定路径下的类库应用程序中的类加载器默认是系统类加载器。它是用户自定义类加载器的默认父加载器</li><li>通过 Classloader 的 getsystemClassloader（）方法可以获取到该类加载器</li></ul><h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4-用户自定义类加载器"></a>4-用户自定义类加载器</h3><ul><li>在Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR 包，也可以是网络上的远程资源。</li><li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的 OSGI 组件框架，再如  Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，自定义加载器能够实现应用隔离，例如 Tomcat, Spring 等中间件和组件框架都在内部实现了自定义的加载器,并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改 C/C++程序就能为其新功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。自定义类加载器通常需要继承于 Classloader。</li></ul><h2 id="03-测试不同的类的加载器"><a href="#03-测试不同的类的加载器" class="headerlink" title="03-测试不同的类的加载器"></a>03-测试不同的类的加载器</h2><p>每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用。</p><p>获取 ClassLoader 的途径</p><p>获得当前类的 Classloade：<code>clazz. GetClassLoader ()</code></p><p>获得当前线程上下文的 ClassLoader:<code>Thread.currenThread (). GetContextClassLoader ()</code></p><p>获得系统的 Classloader: <code>ClassLoader.GetSystemClassLoader ()</code></p><p><strong>说明：</strong></p><p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用 C++语言编写而成的，而另外两种类加载器则是使用 Java 语言编写而成的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值。</p><p>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 <code>Class. GetClassLoader()</code>返回的，<strong>与数组当中元素类型的类加器</strong>是一样的：如果数<strong>组当中的元素类型是基本数据类型，数组类是没有类加载器的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@511d50c0</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line">            ClassLoader currentClassLoader = Class.forName(<span class="string">&quot;com.liuermeng.jvm.chapter04.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(currentClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">            <span class="comment">// 关于数组类型的加载:使用的类的加载器与数组元素的加载器相同</span></span><br><span class="line">            String[] arrStr=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null</span></span><br><span class="line">            ClassLoaderTest1[] arrClt=<span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrClt.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] arri=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arri.getClass().getClassLoader());<span class="comment">//null 基本数据类型，不需要类的加载器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04-ClassLoader源码解析"><a href="#04-ClassLoader源码解析" class="headerlink" title="04-ClassLoader源码解析"></a>04-ClassLoader源码解析</h2><p><strong>ClassLoader与现有类加载器的关系：</strong></p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628144346523.png" alt="image-20210628144346523" style="zoom:33%;"><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h3 id="1-ClassLoader的主要方法"><a href="#1-ClassLoader的主要方法" class="headerlink" title="1-ClassLoader的主要方法"></a>1-ClassLoader的主要方法</h3><p><strong>抽象类ClassLoader的主要方法：（内部没有抽象方法）</strong></p><p><code>public final ClassLoader getParent()</code> 返回该类加载器的超类加载器</p><p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code> 加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。该方法中的逻辑就是<strong>双亲委派模式</strong>的实现。</p><p><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code> 查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被 loadClass（）方法调用。</p><ul><li>在 JDK1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类。但是在 JDK1.2 之后已不再建议用户去覆盖 loadClass（）方法，而是建议把自定义的类加载逻辑写在  findClass（）方法中，从前面的分析可知findClass（）方法是在 loadClass（）方法中被调用的，当loadClass（）方法中父加载器加载失败后，则会调用自己的 findClass（）方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li><li>需要注意的是 ClassLoader 类中并没有实现 findClass（）方法的具体代码逻辑，取而代之的是抛出Classnotfoundexception 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法起使用的。一般情况下，在自定义类加载器时，会直接覆盖 Classloader 的 findClass方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defingClass（）方法生成类的Class对象。</li></ul><p><code>Protected final Class&lt;?&gt; defineClass(String name, byte[] b,int off,int len)</code> 根据给定的字节数组 b 转换为 class 的实例，off 千和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 Classloader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用。</p><ul><li>defineClass（）方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中已实现该方法逻辑），通过这个方法不仅能够通过 class 文件实例化 class对象，也可以通过其他方式实例化 class 对象，如通过络收一个类的字节码，然后转换 byte 字节流创建对应的 Class 对象。</li><li>defineClass（）方法通常与 findClass（）方法一起使用，一般情況下，在自定义类加载器时，会直接覆盖Classloader 的 findClass（）方法并编写加载规则，取得要加載类的字节码后转换成流，然后调用 defineclass（）方法生成类的 Class 对象</li></ul><p><code>protected final void resolveClass(Class&lt;?&gt; c)</code> 链接指定的一个Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>  查找名称为 name 的己经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改。</p><p><code>private final ClassLoader parent</code>  它也是一个 Classloader 的实例，这个字段所表示的 Classloader 也称为这个 Classloader 的双亲。在类加载的过程中，Classloader 可能会将某些请求交予自己的双亲处理</p><p><strong>loadClass()剖析</strong></p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.liuermeng.User&quot;</span>);</span><br></pre></td></tr></table></figure><p>涉及到如下方法的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">// resolve：true-加载class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// 首先，在缓存中判断是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果未加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// parent为null：父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; <span class="comment">// 当前类的加载器的父类加载器未加载此类</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findClass（）</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">// 是否进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SecureClassLoader与URLClassLoader"><a href="#2-SecureClassLoader与URLClassLoader" class="headerlink" title="2-SecureClassLoader与URLClassLoader"></a>2-SecureClassLoader与URLClassLoader</h3><p>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对 class 源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联。</p><p>前面说过，Classloader 是一个抽象类，很多方法是空的没有实现，比如 findClass（）、findResource（）等。而 URLClassLoader 这个实现类为这些方法提供了具体的实现。并新増了 URLClassPath 类协助取得 Class 字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findcass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png" alt="image-20210627205013180" style="zoom:50%;"><h3 id="3-ExtClassLoader与AppClassLaoder"><a href="#3-ExtClassLoader与AppClassLaoder" class="headerlink" title="3-ExtClassLoader与AppClassLaoder"></a>3-ExtClassLoader与AppClassLaoder</h3><p>了解完 URLClassLoader 后接着看看剩余的两个类加载器，即拓展类加载器 ExtClassLoader 和系统类加载器  AppClassLoader，这两个类都继承自 URLClassLoader, 是sun.misc. Launcher 的静态内部类。 sun.misc. Launcher 主要被系统用于启动主应用程序，ExtClassLoader 和 AppClassLoader都是由 sun.misc. Launcher 创建的，其类主要类结构如下：</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150519826.png" alt="image-20210628150519826" style="zoom:50%;"><p>ExtClassLoader 并没有重写 loadClass（）方法，这足矣说明其遵循双亲委派模式，而 AppClassLoader 重载了 loadClass（）方法，但最终调用的还是父类 loadClass（）方法，因此依然遵守双亲委派模式。</p><h3 id="4-Class-forName-与ClassLoader-loadClass"><a href="#4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4-Class.forName()与ClassLoader.loadClass()"></a>4-Class.forName()与ClassLoader.loadClass()</h3><p>Class.forName ()：是一个静态方法，最常用的是 Class.forName (String className）；根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。如：Class.forName (“com.liuermeng.Helloworld”)</p><p>ClassLoader.loadClass ()：这是一个实例方法，需要一个 CLassLoader 对象来调用该方法。该方法将Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。如：Classloader c1=……;  c1.loadClass (“com.liuermeng.Helloworld”);</p><h2 id="05-双亲委派机制"><a href="#05-双亲委派机制" class="headerlink" title="05-双亲委派机制"></a>05-双亲委派机制</h2><h3 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1-定义与本质"></a>1-定义与本质</h3><p>类加载器用来把类加载到Java 虚拟机中。从 JDK1.2 版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证 Java 平台的安全。</p><ol><li><strong>定义</strong></li></ol><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><ol start="2"><li><strong>本质</strong></li></ol><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，オ会由系统类加载器或自定义的类加载器进行加载。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150910750-4935529.png" alt="image-20210628150910750" style="zoom:33%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150946026-4935529.png" alt="image-20210628150946026" style="zoom: 33%;"><h3 id="2-优势与劣势"><a href="#2-优势与劣势" class="headerlink" title="2-优势与劣势"></a>2-优势与劣势</h3><ol><li><strong>双亲委派机制优势</strong></li></ol><ul><li><p>避免类的重复加载，确保一个类的全局唯一性</p><p>Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 Classloader 再加载一次。</p></li><li><p>保护程序安全，防止核心 API 被随意改</p></li></ul><ol start="2"><li><strong>代码支持</strong></li></ol><p>双亲委派机制在 java.lang.Classloader.loadClass (String, boolean）接口中体现。该接口的逻辑如下：</p><p> (1) 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p> (2) 判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass (name, false）接口进行加载。</p><p> (3) 反之，如果当前加载器的父类加载器为空，则调用 findBootStrapClassOrNul (name）接口，让引导类加载器进行加载。</p><p> (4) 如果通过以上 3 条路径都没能成功加载，则调用 findClass (name）接口进行加载。该接口最终会调用 java.lang.Classloader 接口的 defineClass 系列的 native 接口加载目标Java 类。双亲委派的模型就隐藏在这第 2 和第 3 步中。</p><ol start="3"><li><strong>举例</strong></li></ol><p>假设当前加载的是 java.lang.Object 这个类，很显然，该类属于JDK 中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载 java.lang.Object 时，JVM 默认会使用系统类加载器去加载，按照上面 4 步加载的逻辑，在第 1 步从系统类的缓存中肯定查找不到该类，于是进入第 2 步。由于系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第 1 步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第 2 步。扩展类的父加载器是 null, 因此系统调用 findclass (String），最终通过引导类加载器进行加载。</p><ol start="4"><li><strong>思考</strong></li></ol><p>如果在自定义的类加载器中重写 java.lang.Classloader.loadClass (String）或java.lang.ClassLoader.loadClass (String, boolean）方法，抹去其中的双亲委派机制，仅保留上面这 4 步中的第 1 步与第 4 步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK 还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.Classloader.defineClass (string, byte [], int, int,Protectiondomain）方法，而该方法会执行 preDefineClass（）接口，该接口中提供了对JDK 核心类库的保护。</p><ol start="5"><li><strong>双亲委托模式的弊端</strong></li></ol><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个 Classloader 的职责非常明确，但是同时会带来一个问题，即顶层的 Classloader 无法访问底层的 CLassloader 所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口该接口需要在应用类中得以实现，该接口述绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><ol start="6"><li><strong>结论</strong></li></ol><p>由于Java 虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。</p><p>比如在 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet 规范推荐的一种做法。</p><h3 id="3-破坏双亲委派机制"><a href="#3-破坏双亲委派机制" class="headerlink" title="3-破坏双亲委派机制"></a>3-破坏双亲委派机制</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>双亲委派模型并不是一个具有强制性约的模型，而是Java 设计者推荐给开发者们的类加载器实现方式。</p><p>在Java 的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java 模块化出现为止，双亲委派模型主要出现过 3 次较大规模“被破坏”的情况。</p><h4 id="破坏双亲委派机制1"><a href="#破坏双亲委派机制1" class="headerlink" title="破坏双亲委派机制1"></a>破坏双亲委派机制1</h4><p>第一次破坏双亲委派机制：</p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一即JDK1.2 面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.Classloader 则在Java 的第1个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免 loadClass（）被子类覆盖的可能性，只能在JDK1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findclass (），并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass（）中编写代码。上节我们已经分析过 loadClass（）方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass（）方法的逻辑，如果父类加载失败，会自动调用自己的 findcass（）方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><h4 id="破坏双亲委派机制2"><a href="#破坏双亲委派机制2" class="headerlink" title="破坏双亲委派机制2"></a>破坏双亲委派机制2</h4><p>第二次破坏双亲委派机制：线程上下文类加载器</p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码那该怎么办呢？</p><p>这并非是不可能出现的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是Java 的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3 时加入到 rt.jar 的），肯定属于Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 Classpath 下的 JNDI 服务提供者接口（Service Provider Interface, SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ (SPI：在Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI)</p><p>为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context Classloader）</strong>。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在 JDK6 时，JDK 提供了 java.Util. ServiceLoader 类，以 META-INF/services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628160124899-4935529.png" alt="image-20210628160124899" style="zoom:33%;"><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h4 id="破坏双亲委派机制3"><a href="#破坏双亲委派机制3" class="headerlink" title="破坏双亲委派机制3"></a>破坏双亲委派机制3</h4><p>第三次破坏双亲委派机制：</p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：<strong>代码热替换（Hot Swap）、模块热部署（Hot Deployment）</strong>等</p><p>IBM 公司主导的JSR-291（即 OSGi R4.2) 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p><p>*<em>1) 将以 java. <em>开头的类，委派给父类加载器加载。</em></em></p><p><strong>2) 否则，将委派列表名单内的类，委派给父类加载器加载。</strong></p><ol start="3"><li><p>否则，将 Import 列表中的类，委派给 Export。这个类的 Bundle 的类加载器加载。</p></li><li><p>否则，查找当前 Bundle 的 Classpath，使用自己的类加载器加载。</p></li><li><p>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</p></li><li><p>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</p></li><li><p>否则，类查找失败。</p></li></ol><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：</p><p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<strong>这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p><p>正如：OSGi 中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为 OSGI 中对类加载器的运用是值得学习的，完全弄懂了 OSGi 的实现，就算是掌握了类加载器的精粹</p><h3 id="4-热替换的实现"><a href="#4-热替换的实现" class="headerlink" title="4-热替换的实现"></a>4-热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了 PHP 源文件，这种改动就会立即生效，而无需重启 Web 服务器。</p><p>但对Java 来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加并重定义这个类。因此，在Java 中实现这一功能的一个可行的方法就是灵活运用 Classloader。</p><p>注意：由不同 Classloader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 Classloader 加载同个类，在虚拟机内部，会认为这 2 个类是完全不同的。</p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628161157283-4935529.png" alt="image-20210628161157283" style="zoom: 25%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628162015161-4935529.png" alt="image-20210628162015161" style="zoom: 20%;"><h2 id="06-沙箱安全机制"><a href="#06-沙箱安全机制" class="headerlink" title="06-沙箱安全机制"></a>06-沙箱安全机制</h2><h3 id="1-JDK1-0时期"><a href="#1-JDK1-0时期" class="headerlink" title="1-JDK1.0时期"></a>1-JDK1.0时期</h3><p>在Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱（Sandbox）机制。如下图所示 JDK1.0 安全模型</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163159255-4935529.png" alt="image-20210628163159255" style="zoom: 25%;"><h3 id="2-JDK1-1时期"><a href="#2-JDK1-1时期" class="headerlink" title="2-JDK1.1时期"></a>2-JDK1.1时期</h3><p>JDK1.0 中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的 Java1.1 版本中，针对安全机制做了改进，増加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p><p>如下图所示JDK1.1 安全模型</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163255917-4935529.png" alt="image-20210628163255917" style="zoom:25%;"><h3 id="3-JDK1-2时期"><a href="#3-JDK1-2时期" class="headerlink" title="3-JDK1.2时期"></a>3-JDK1.2时期</h3><p>在Java1.2 版本中，再次改进了安全机制，増加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 JDK1.2 安全模型</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163339056-4935529.png" alt="image-20210628163339056" style="zoom:25%;"><h3 id="4-JDK1-6时期"><a href="#4-JDK1-6时期" class="headerlink" title="4-JDK1.6时期"></a>4-JDK1.6时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6)</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163441756-4935529.png" alt="image-20210628163441756" style="zoom:25%;"><h2 id="07-自定义类的加载器"><a href="#07-自定义类的加载器" class="headerlink" title="07-自定义类的加载器"></a>07-自定义类的加载器</h2><ol><li><strong>为什么要自定义类加载器</strong>？</li></ol><ul><li>隔离加载类</li></ul><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。</p><ul><li>修改类加载的方式</li></ul><p>类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p><ul><li>扩展加载源</li></ul><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p><ul><li>防止源码泄漏</li></ul><p>Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p><ol start="2"><li><strong>常见的场景</strong></li></ol><ul><li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE 和 OSGi、JPMS 等框架。</p></li><li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码动态修改或者生成类型。</p></li></ul><ol start="3"><li><strong>注意</strong>：</li></ol><p>在一般情下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java 类型转换，则加载器反而容易产生不美好的事情。在做Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><strong>实现方式</strong></li></ol><ul><li><p>Java 提供了抽象类 java.lang. Classloader，所有用户自定义的类加载器都应该继承 Classloader 类。</p></li><li><p>在自定义 Classloader 的子类时候，我们常见的会有两种做法：</p><ul><li><p>方式一：重写 loadClass（）方法</p></li><li><p>方式二：重写 findClass（）方法–&gt;推荐</p></li></ul></li></ul><ol start="2"><li><strong>对比</strong></li></ol><p>这两种方法本质上差不多，毕竟 loadClass（）也会调用 findClass (），但是从逻辑上讲我们最好不要直接修改 loadClass（）的内部逻辑。建议的做法是只在 findClass（）里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用。</p><ul><li><p>loadClass（）这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass（）方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p></li><li><p>当编写好自定义类加载器后，便可以在程序中调用 loadClass（）方法来实现类加载操作。</p></li></ul><ol start="3"><li><strong>说明</strong></li></ol><ul><li><p>其父类加载器是系统类加载器</p></li><li><p>JVM中的所有类加载都会使用 java.lang.ClassLoader.loadClass (String）接口（自定义类加载器并重写java.lang.ClassLoader.loadClass (String）接口的除外），连 JDK 的核心类库也不能例外。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName=byteCodePath+className+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bos= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len=bis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(data,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] byteCodes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; aClass = defineClass(<span class="keyword">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader loader=<span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/Users/liumeng/Desktop/&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz= loader.loadClass(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类加载器为&quot;</span>+clazz.getClassLoader().getClass().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类加载器的父类加载器为&quot;</span>+clazz.getClassLoader().getParent().getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载此类的类加载器为com.liuermeng.jvm.classloader.MyClassLoader</span><br><span class="line">加载此类的类加载器的父类加载器为sun.misc.Launcher$AppClassLoader//我们并没有定义父类加载器，默认为系统类加载器</span><br></pre></td></tr></table></figure><h2 id="08-Java9新特性"><a href="#08-Java9新特性" class="headerlink" title="08-Java9新特性"></a>08-Java9新特性</h2><p>为了保证兼容性，JDK9 没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platformClassLoader）。可以通过 Classloaderl的新方法 getPlatformClassLoader（）来获取。</li></ol><p>JDK9 基于模块化进行构建 (原来的rt.jar和 tools.jar 被拆分成数十个 JMOD 文件）,其中的Java 类库就已天然地满足了可扩展的需求，那自然无须再保留<code>&lt;JAVA_HOME&gt; \liib\ext</code>目录, 此前使用这个 目录或者 java.ext.dirs 系统变量来扩展JDK 功能的机制已经没有继续存在的价值了</p><ol start="2"><li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</li></ol><p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk. internall.loader.BuiltinClassLoader。</p> <img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628184815857-4935529.png" alt="image-20210628184815857" style="zoom:33%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185218382-4935529.png" alt="image-20210628185218382" style="zoom:33%;"><p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassloader 类的特定方法，那代码很可能会在 JDK9 及更高版本的 JDK 中崩溃。</p><ol start="3"><li><p>在Java9 中，类加载器有了名称。该名称在构造方法中指定，可以通过 getName（）方法来获取。平台类加载器的名称是 platform，应用类加载器的名称是 app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p></li><li><p>启动类加载器现在是在 jvm 内部和 java 类库共同协作实现的类加载器（以前是c++实现），但为了与之前代码兼容在获取启动类加载器的场景中然会返回 null， 而不会得到 BootClassLoader 实例。</p></li><li><p>类加载的委派关系也发生了变动。</p></li></ol><p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><p>双亲委派模式示意图</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185505425-4935529.png" alt="image-20210628185505425" style="zoom: 25%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104356777-4935529.png" alt="image-20210629104356777" style="zoom: 50%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104427185-4935529.png" alt="image-20210629104427185" style="zoom:50%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104449171-4935529.png" alt="image-20210629104449171" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码指令集与解析举例</title>
      <link href="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/"/>
      <url>/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当作最基本的执行模型来理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">  自动计算PC寄存器的值+1；</span><br><span class="line">  根据PC寄存器的指示位置，从字节码流中取出操作码；</span><br><span class="line">  if(字节码存在操作数)从字节码流中取出操作数；</span><br><span class="line">  执行操作码所定义的操作；</span><br><span class="line">&#125;while(字节码长度&gt;0)</span><br></pre></td></tr></table></figure><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，<code>iload</code> 指令用于从局部变量表中加载 <code>int</code> 型的数据到操作数栈中，而 <code>fload</code> 指令加载的则是 <code>float</code> 类型的数据。</p><p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：</p><p>代表对 <code>int</code> 类型的数据操作，</p><p>l 代表 <code>1ong</code> </p><p>s 代表 <code>short</code> </p><p>b 代表 <code>byte</code> </p><p>c 代表 <code>char</code> </p><p>f 代表 <code>float</code> </p><p>d 代表 <code>double</code></p><p>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如 <code>arraylength</code> 指令，它没有代表数据类型的特殊字符，但</p><p>操作数永远只能是一个数组类型的对象。</p><p>还有另外一些指令，如无条件跳转指令 <code>goto</code> 则是与<strong>数据类型无关的</strong>。</p><p>大部分的指令都没有支持整数类型 <code>byte</code>、<code>char</code> 和 <code>short</code>，甚至没有任何指令支持 <code>boolean</code> 类型。编译器会在编译期或运行期将 <code>byte</code> 和 <code>short</code> 类型的数据带符号扩展（<code>Sign- Extend</code>）为相应的 <code>int</code> 类型数据, 将 <code>boolean</code>/和<code>char</code> 类型数据零位扩展（<code>Zero- Extend</code>）为相应的 <code>int</code> 类型数据。与之类似，在处理 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型的数组时，也会转换为使用对应的 <code>int</code> 类型的字节码指令来处理。因此，大多数对于 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型数据的操作，实际上都是使用相应的 <code>int</code> 类型作为运算类型。</p><h3 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h3><h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><p><strong>1、作用</strong></p><p>加载和存储指令用于将数据从栈桢的局部变量表和操作数之间来回传递</p><p><strong>2、常用指令</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621082659746.png" alt="image-20210621082659746"></p><p>上面所例举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>)。这些助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了    <code>iload_0、iload_1、iload_2、iload_3</code>这几个指令）。这组指令都是某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式，<strong>对于这若干组特殊指令来说，他们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p><p>除此之外，它们的语义与原生的通用指令完全一致（例如 <code>iload_0</code> 的语义与操作数为0时的 <code>iload</code> 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是 int 类型数据，<code>&lt;l&gt;</code> 代表 long 类型，<code>&lt;f&gt;</code>代表 float 类型，<code>&lt;d&gt;</code>代表 double 类型。</p><p>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</p><h3 id="复习：再谈操作数栈与局部变量表"><a href="#复习：再谈操作数栈与局部变量表" class="headerlink" title="复习：再谈操作数栈与局部变量表"></a>复习：再谈操作数栈与局部变量表</h3><p><strong>1、操作数栈</strong></p><p>我们知道，Java 字节码是Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为<strong>操作数栈，来存放计算的操作数以及返回结果</strong>。</p><p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数機中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入中。</p><p><strong>2、局部变量表（Local Variables）</strong></p><p>Java 方法桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p><p>实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p><p>和操作数栈一样，Long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621084753169.png" alt="image-20210621084753169"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085050120.png" alt="image-20210621085050120"></p><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="1-局部变量压栈指令"><a href="#1-局部变量压栈指令" class="headerlink" title="1-局部变量压栈指令"></a>1-局部变量压栈指令</h3><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数。</p><p>这类指令大体可以分为：</p><p>​        &gt;<code>xload_ &lt;n&gt;</code> (x 为 i、l、f、d、a, n 为 0 到 3) </p><p>​        &gt;<code>xload</code> (x 为 i、l、f、d、a）</p><p>说明：在这里，x 的取值表示数据类型。</p><p>指令 xload_n 表示将第 n 个局部变量压入操作数，比如 iload_1、fload_0、aload_0 等指令。其中 aload_n 表示将个对象引用压栈。</p><p>指令 xload 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令 iload、fload 等</p><p><strong>￼举例分析</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085858658.png" alt="image-20210621085858658"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085922759.png" alt="image-20210621085922759"></p><h3 id="2-常量入栈指令"><a href="#2-常量入栈指令" class="headerlink" title="2-常量入栈指令"></a>2-常量入栈指令</h3><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 <code>const</code>系列、<code>push</code> 系列和 <code>ldc</code> 指令。</p><p><strong>指令 <code>const</code> 系列</strong>：用于对特定的常量入，入的常量隐含在指令本身里。指令有：<code>const_&lt;i&gt;</code> (i 从-1 到 5)、<code>lconst_&lt;l&gt;</code> (l 从 0 到 1)、<code>fconst_ &lt;f&gt;</code> (f 从 0 到 2)、<code>dconst_&lt;d&gt;</code> (d 从 0 到 1)、aconst_null。</p><p> 比如，</p><p> iconst_m1 将 -1 压入操作数栈；</p><p> iconst _x (x 为到 5) 将 x 压入栈：</p><p> lconst_0、lconst_1 分别将长整数 0 和 1 压入栈；</p><p> fconst_0、fconst_1、fconst_2 分别将浮点数0、1、2 压入栈；</p><p> dconst_0 和 dconst_1 分别将 doublet 型 0 和 1 压入栈。</p><p> aconst_null 将 null 压入操作数</p><p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整数，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p><p><strong>指令 <code>push</code> 系列</strong>：主要包括 biush 和 sipush。它们的区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数， sipus 接收 16 位整数，它们都将参数压入栈。</p><p><strong>指令 <code>ldc</code> 系列</strong>：如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。</p><p>类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。</p><p>如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。</p><p>总结如下：</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621091752821.png" alt="image-20210621091752821"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092109463.png" alt="image-20210621092109463"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092316340.png" alt="image-20210621092316340"></p><p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，本次的n代表数值或者对象，而不是局部变量表中的下标</p><h3 id="3-出栈入局部变量表指令"><a href="#3-出栈入局部变量表指令" class="headerlink" title="3-出栈入局部变量表指令"></a>3-出栈入局部变量表指令</h3><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以 store 的形式存在，比如 xstore (x 为 i、l、f、d、a）、xstore_n (x 为 i、l、f、d、a, n 为 0 至 3)。</p><p>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它值给局部变量索引 n 位置。</p><p>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</p><p><strong>说明：</strong></p><p>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有  istore_0、istore_2、istore_3, 它们分别表示从操作数顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。</p><p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然増加了指令数量，但是可以大大压缩生成的字节码的体积如果局部变量表很大，需要存储的槽位大于 3, 那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。</p><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><p><strong>1、作用：</strong></p><p>算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p><p><strong>2、分类：</strong></p><p>大体上算数指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令。</p><p><strong>3、byte、short、char和boolean类型说明</strong></p><p>在每一大类中，都有针对Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095121174.png" alt="image-20210621095121174"></p><p><strong>4、运算时的溢出</strong></p><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常 ArithmeticException。</p><p><strong>5、运算模式</strong></p><p>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p><p>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</p><p><strong>6、NaN值使用</strong></p><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</p><p><strong>对于无穷大和NaN的举例</strong></p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095607569.png" alt="image-20210621095607569" style="zoom:50%;"><h3 id="1-所有算数指令"><a href="#1-所有算数指令" class="headerlink" title="1-所有算数指令"></a>1-所有算数指令</h3><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095751219.png" alt="image-20210621095751219" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095952979.png" alt="image-20210621095952979" style="zoom:50%;"><p>参数i=5，绿色表示局部变量表，蓝色表示操作数栈。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621100011574.png" alt="image-20210621100011574" style="zoom:50%;"><h3 id="2-比较指令的说明"><a href="#2-比较指令的说明" class="headerlink" title="2-比较指令的说明"></a>2-比较指令的说明</h3><p>比较指令的作用是比较顶两个元素的大小，并将比较结果入栈。</p><p>比较指令有：dampg, dcmpl、fcmpg、fcmpl、lcmp。</p><p>​        与前面讲解的指令类似，首字符 d 表示 double 类型，f表示 float,l 表示 long。</p><p>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令。以 float 为例，有 fcmp 和 fcmpl 两个指</p><p>令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。</p><p>指令 dcmpl 和 dampg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令。</p><p><strong>举例</strong></p><p>指令 fcmpg 和 fcmpl 都从中弹出两个操作数，并将它们做比较，设顶的元素为 v2, 栈顶顺位第 2 位的元素为 v1, 若</p><p>v1=v2, 则压入0；若 v1&gt; v2 则压入 1: 若 v1 &lt;v2 则压入-1。</p><p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1, 而 fcmpl 会压入-1。</p><p>数值类型的数据，才与以谈大小！ </p><p>boolean、引用数据类型不能比较大小</p><p><strong>注意</strong>：NaN(Not a Number)表示不是一个数字，比如0.0/0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，只有double和float类型中可能出现NaN的情况，而long类型不会出现NaN，所以只有lcmp。</p><h3 id="3-i-amp-i"><a href="#3-i-amp-i" class="headerlink" title="3- ++i&amp;i++"></a>3- ++i&amp;i++</h3><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101720616.png" alt="image-20210621101720616" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101758904.png" alt="image-20210621101758904" style="zoom:33%;"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101835404.png" alt="image-20210621101835404" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101855081.png" alt="image-20210621101855081" style="zoom:33%;"></p><p><strong>结论</strong>：如果只是i++和++i，字节码相同</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102017955.png" alt="image-20210621102017955" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102040391.png" alt="image-20210621102040391" style="zoom:33%;"></p><p><strong>结论</strong>：a=i++是将局部变量表中的10先加载到操作数栈，再对局部变量表中的10+1；然后再将操作数栈中的10存储到局部变量表中索引为2的空间中</p><p>b=j++是先将局部变量表中的20自加1之后再加载到操作数栈，然后在存储到局部变量表中</p><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p><strong>1、类型转换指令说明</strong></p><p>①类型转换指令可以将两种不同的数值类型进行相互转换。</p><p>②这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><h3 id="1-宽化类型转换"><a href="#1-宽化类型转换" class="headerlink" title="1-宽化类型转换"></a>1-宽化类型转换</h3><p><strong>1.转换规则</strong></p><p>Java 虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：</p><p>​        从 int 类型到 long、float 或者 double 类型。对应的指令为：i21、i2f、i2d</p><p>​        从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</p><p>​        从 float 类型到 double 类型。对应的指令为：f2d</p><p>简化为：<code>int--&gt;long--&gt; foat--&gt; double</code></p><p><strong>2.精度损失问题</strong></p><p>2.1 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</p><p>2.2 从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数值。</p><p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java 虚拟机抛出运行时异常。</p><p><strong>3.补充说明</strong></p><p>从 byte、char 和 short类型到 int 类型的宽化类型转换实际上是不存在的。对于 byte 类型转为 int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将 byte 转为 long 时，使用的是 i2l, 可以看到在内部 byte 在这里己经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：</p><p>​        一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只意使用一个字节表示指令，因此指令总数不能超过 256个，为了节省指令资源，将 short/和 byte 当做 int 处理也在情理之中。</p><p>​        另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p><h3 id="2-窄化类型转换"><a href="#2-窄化类型转换" class="headerlink" title="2-窄化类型转换"></a>2-窄化类型转换</h3><p><strong>1.转化规则</strong></p><p>Java 虚拟机也直接支持以下窄化类型转换:</p><p>​        从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s </p><p>​        从 long 类型到 int 类型。对应的指令有：l2i</p><p>​        从行 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l</p><p>​        从 doub1e 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f</p><p><strong>2.精度损失问题</strong></p><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><p><strong>3.补充说明</strong></p><p>3.1 当将一个浮点值窄化转换为整数类型 T (T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：</p><p>​        如果浮点值是 NaN，那转换结果就是 int 或 long 类型的0。</p><p>​        如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果V在目标类型 T (int 或 long）的表示范围之内，那转换结果就是V。否则，将根据 V 的符号，转换为 T 所能表示的最大或者最小正数</p><p>3.2 当将一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</p><p>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：</p><p>​        如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</p><p>​        如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</p><p>​        对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</p><p><strong>注意</strong>：从float、double、long等类型往byte、short、char类型转换的时候，需要先把前面几种类型转换成int类型，然后在从int类型转换到后面这几种类型，所以int类型相等于一种过渡类型</p><h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><p>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><h3 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1-创建指令"></a>1-创建指令</h3><p>虽然类实例和数组都是对象，但Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p><p><strong>1. 创建类实例的指令：</strong></p><p>创建类实例的指令：new</p><p>​        它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</p><p><strong>2. 创建数组的指令：</strong></p><p>创建数组的指令：newarray、anewarray、mu tianewarray</p><p>​         newarray：创建基本类型数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anewarray：创建引用类型数</span><br><span class="line"></span><br><span class="line">multianewarray：创建多维数组</span><br></pre></td></tr></table></figure><p>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也非常高。</p><p><strong>需要注意的细节：</strong></p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105624505.png" alt="image-20210621105624505" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105652436.png" alt="image-20210621105652436" style="zoom:50%;"><p>两个创建二维数组的字节码中的差距需要注意</p><h3 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2-字段访问指令"></a>2-字段访问指令</h3><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p><p>​        <em>访问类字段（static 字段，或者称为类变量）的指令：getstatic、putstatic</em> </p><p>​        <em>访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfied、putfield</em></p><p>举例：</p><p>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的</p><p>对象或者值，并将其压入操作数栈。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113216931.png" alt="image-20210621113216931" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113249177.png" alt="image-20210621113249177" style="zoom:50%;"><p>注意：<code>get***</code>是入栈，而<code>put***</code>是出栈</p><h3 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3-数组操作指令"></a>3-数组操作指令</h3><p>数组操作指令主要有：xastore 和 xaload 指令。具体为：</p><p>​        把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aalad</p><p>​        将一个操作数的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、 faster、dastore、aastore</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621114243226.png" alt="image-20210621114243226" style="zoom:50%;"><p>取数组长度的指令：arraylength</p><p>​        该指令弹出顶的数组元素，获取数组的长度，将长度压入栈</p><p><strong>说明</strong></p><p>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令xaload 在执行时，要求操作数中栈顶元素为数组素引，顶顺位第 2 个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 <code>a[i]</code>重新压入栈。</p><p> xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，restores 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</p><h3 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4-类型检查指令"></a>4-类型检查指令</h3><p>检查类实例或数组类型的指令：instanceof、checkcast。</p><p>​        指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数，否则它会抛出 ClassCastException 异常。</p><p>​        指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</p><h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1-方法调用指令"></a>1-方法调用指令</h3><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p><p>以下 <strong>5 条指令</strong>用于方法调用：</p><p>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java 语言中最常见的方法分派方式。</p><p> invokeinterface 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p><p> invokespecia 指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）、私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</p><p> invokestatic 指令用于调用命名类中的类方法（static 方法）。这是<strong>静态绑定</strong>的。</p><p> invokedynamic：调用动态绑定的方法，这个是JDK1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</p><p><strong>注意：</strong> </p><p>1、invokedynamic老师不讲，估计是很少遇到吧</p><p>2、invokeinterface是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</p><p>3、invokespecial只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了.  这几种方法都是不会被重写的</p><p>4、invokestatic是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是invokestatic，也不难理解</p><p>5、invokevirtual是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如A a = new B();a.hello()，其中B类继承A类，并且B类重写了A类中的hello()方法，这种情况下就是invokevirtual了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是invokevirtual了</p><h3 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2-方法返回指令"></a>2-方法返回指令</h3><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p><p>​        包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、 dreturn 和 areturn</p><p>​        另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621133956414.png" alt="image-20210621133956414" style="zoom:50%;"><p>举例：</p><p>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p><p>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</p><p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621135828244.png" alt="image-20210621135828244"></p><h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆那样，JVM 提供的操作数管理指令，可以用于直接操作操作数的指令。</p><p>这类指令包括如下内容：</p><p>​        将一个或两个元素从栈顶弹出，并且直接废弃：pop, pop2</p><p>​        复制顶一个或两个数值并将复制值或双份的复制值重新压入顶：dup, dup2, dup_x1,  dup2 x1, dup_x2, dup2_x2:</p><p>​        将栈最顶端的两个Slot数值位置交换：swap。Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令。</p><p>​        指令 nop，是一个非常特殊的指令，它的字节码为 x。和汇编语言中的 nop 一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p><p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p><p><strong>说明：</strong></p><p>不带_x 的指令是复制栈顶数据并压入顶。包括两个指令，dup 和 dup2。dup 的系数代表要复制的 Slot 个数。</p><p>​        dup 开头的指令用于复制 1 个 Sot 的数据。例如 1 个 int 或 1 个 reference 类型数据</p><p>​        dup2 开头的指令用于复制 2 个 S1ot 的数据。例如 1 个 1ong，或 2 个 int，或 1 个 int+1 个 float 类型数据</p><p>带_x 的指令是复制栈顶数据并插入顶以下的某个位置。共有 4 个指令，dup_x1, dup2_x1,</p><p>dup_x2, dup2_x2. 对于带_x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插</p><p>入的位置。因此</p><p>​        dup_x1 插入位置：1+1=2, 即栈顶 2 个 Slot 下面</p><p>​        dup_x2 插入位置：1+2=3, 即栈顶 3 个 Slot 下面</p><p>​        dup2_x1 插入位置：2+1=3, 即栈顶 3 个 Slot 下面</p><p>​        dup2_x2 插入位置：2+2=4, 即栈顶 4 个 Slot 下面</p><p>pop：将顶的 1 个 Slot 数值出。例如 1 个 short 类型数值</p><p>pop2: 将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值</p><h2 id="控制转义指令"><a href="#控制转义指令" class="headerlink" title="控制转义指令"></a>控制转义指令</h2><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为 1) 比较指令、2) 条件跳转指令、3) 比较条件跳转指令、4) 多条件分支跳转指令、5) 无条件跳转指令等。</p><p>比较指令见算数指令</p><h3 id="1-条件跳转指令"><a href="#1-条件跳转指令" class="headerlink" title="1-条件跳转指令"></a>1-条件跳转指令</h3><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p><p>条件跳转指令有：ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull。这些指令都接收两个字节的操作数用于计算跳转的位置（16 位符号整数作为当前位置的 offset）。</p><p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621152715017.png" alt="image-20210621152715017"></p><p>注意</p><ol><li>与前面运算规则一致：</li></ol><p>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成</p><p>对于 long、float、double：类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转</p><ol><li><p>由于各类型的比较最终都会转为 int 类型的比较操作，所以Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621153319123.png" alt="image-20210621153319123"></p><p>⚠️这里是满足条件就跳转，而源程序中是满足条件则继续执行 </p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621155510988.png" alt="image-20210621155510988"></p><p>这里需要⚠️，print函数最后输出的是boolean类型的，当前操作数栈中的1作为参数传到print方法中以后，此处的print方法是调用的返回值为boolean的重载方法，如下图</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160314388.png" alt="image-20210621160314388"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160603355.png" alt="image-20210621160603355"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162110106.png" alt="image-20210621162110106"></p></li></ol><p><strong>注意：</strong> </p><p>1、对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用<strong>比较指令和条件跳转指令</strong> 来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型</p><p>2、int类型值（包含byte、char、short）比较 和 对象类型值比较需要使用<strong>比较条件跳转指令</strong> </p><h3 id="2-比较条件跳转指令"><a href="#2-比较条件跳转指令" class="headerlink" title="2-比较条件跳转指令"></a>2-比较条件跳转指令</h3><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p><p>这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_ icmpgt、if_ icmple、if_icmpge、if_ acmpeq和 if_ acmpne。其中指令助记符加上“if_”后，以字符“i”开头的指令针对int型整数操作（也包括 short 和 byte 类型），以字符“a”开头的指令表示对象引用的比较。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162346744.png" alt="image-20210621162346744"></p><p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入。<strong>如果预设条件成立，则执行跳转，否则，继续执行下条语句。</strong></p><p><strong>举例如下</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162751624.png" alt="image-20210621162751624"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621163632471.png" alt="image-20210621163632471"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164348661.png" alt="image-20210621164348661"></p><p><strong>总结：</strong></p><p>只有int或者用int表示的类型可以直接使用<strong>比较条件跳转指令</strong>；</p><p>double，float，long则需要<strong>比较指令</strong>和<strong>条件跳转指令</strong>共同使用才能完成跳转。</p><h3 id="3-多条件分支跳转"><a href="#3-多条件分支跳转" class="headerlink" title="3-多条件分支跳转"></a>3-多条件分支跳转</h3><p>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164743732.png" alt="image-20210621164743732"></p><p>从助记符上看，两者都是 switch 语句的实现，它们的区别：</p><p>​         tableswitch 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高。</p><p>​        指令 lookupswitch 内部存放着各个离散的 case- offset 对，每次执行都要搜索全部的 case- offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此效率较低。</p><p>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203815830.png" alt="image-20210621203815830"></p><p>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 <strong>case- offset 对按照 case 值大小排</strong>序，给定 index 时，需要査查找与 index 相等的 case，获得其offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203953038.png" alt="image-20210621203953038"></p><p><strong>举例如下</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171348274.png" alt="image-20210621171348274"></p><p>如果将case2中的break注释掉，</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171614629.png" alt="image-20210621171614629"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202029361.png" alt="image-20210621202029361"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202709783.png" alt="image-20210621202709783"></p><p>这里对字符串的比较，先比较哈希值，哈希值相同再比较值是否相等</p><h3 id="4-无条件跳转"><a href="#4-无条件跳转" class="headerlink" title="4-无条件跳转"></a>4-无条件跳转</h3><p>目前主要的无条件跳转指令为 goto。指令 goto 接收<strong>两个字节</strong>的操作数，共同组成一个带符号的整数，用于指定指令的偏移量指令执行的目的就是跳转到偏移量给定的位置处。</p><p>如果指令偏移量太大，超过双字节的帯符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它<strong>接收 4 个字节</strong>的操作数，可以表示更大的地址范围。</p><p>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且己经被虛拟机<em>逐渐废弃</em>，故不在这里介绍这两个指令。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204052272.png" alt="image-20210621204052272"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204647802.png" alt="image-20210621204647802"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205120603.png" alt="image-20210621205120603"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205408219.png" alt="image-20210621205408219"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205643514.png" alt="image-20210621205643514"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205815307.png" alt="image-20210621205815307"></p><h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>异常及异常的处理：</p><p>过程一：异常对象的生成过程—&gt; throw(手动/自动) —-&gt;指令：athrow </p><p>过程二：异常的处理：抓抛模型。try- catch- finaly —-&gt;使用异常表</p><h3 id="1-抛出异常指令"><a href="#1-抛出异常指令" class="headerlink" title="1-抛出异常指令"></a>1-抛出异常指令</h3><p>(1) athrow 指令</p><p>在Java 程序中显示抛出异常的操作（throw 语句）都是由 athrow 指令来实现。</p><p>除了使用 throw 语句显示抛出异常情况之外，JVM 规范还规定了许多运行时异常会在其他Java 虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出  ArithmeticException 异常。</p><p> (2) 注意</p><p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java 虚拟机会清除操作数上的所有内容，而后将异常实例压入调用者操作数栈上。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621221625270.png" alt="image-20210621221625270"></p><p>如果使用throw new 异常名称() 这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称 这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223049071.png" alt="image-20210621223049071"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223157782.png" alt="image-20210621223157782"></p><h3 id="2-异常处理与异常表"><a href="#2-异常处理与异常表" class="headerlink" title="2-异常处理与异常表"></a>2-异常处理与异常表</h3><p><strong>1、处理异常：</strong></p><p>在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是采用异常表来完成的。</p><p><strong>2、异常表</strong></p><p>如果一个方法定义了一个 try- catch 或者 try- finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者  finally 块的信息。异常表保存了每个异常处理信息。比如</p><p>​        起始位置</p><p>​        结束位置</p><p>​        程序计数器记录的代码处理的偏移地址</p><p>​        被捕获的异常类在常量池中的索引</p><p><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法（在调用方法帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM 自己终止，比如这个线程是个 main 线程。</p><p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finaly 块来完成目标</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622092751237.png" alt="image-20210622092751237"></p><p>栈中压入创建的异常实例信息后，会和异常表中的一场类型进行比对，因此说异常处理是通过异常表进行的</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622093823020.png" alt="image-20210622093823020"></p><p><strong>这里的异常处理，其实是重新做了一遍finally里面的事情，因为finally里面的代码时一定要执行，如果未发生异常，则上面的代码不会中断，顺利执行完finally中的代码，如果发生异常，在异常处理中也要执行finally中的代码。</strong></p><h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><p>组成</p><p>java 虚拟机支持两种同步结构：<strong>方法级的同步和方法内部一段指令序列的同</strong>步，这两种同步都是使用 monitor 来支持的</p><h3 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1-方法级的同步"></a>1-方法级的同步</h3><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONZED 访问标志得知一个方法是否声明为同步方法</p><p>当调用方法时，调用指令将会检方法的 ACC_SYNCHRONIZED 访问标志是否设置。</p><p>​        如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p><p>​        在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁</p><p>​        如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622112918956.png" alt="image-20210622112918956" style="zoom:50%;"><p>说明：</p><p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <strong>monitorenter 和 monitorexiti 进</strong>行同步区控制。这是因为，对于同步方法而言，当虚拟机通<strong>过方法的访问标示</strong>符判断是一个同步方法时<strong>，会自动在方法调用前进行加锁，当</strong>同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和  monitorexit 指令是<strong>隐式存在的</strong>，并未直接出现在字节码中。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622113055258.png" alt="image-20210622113055258"></p><h3 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2-方法内指令指令序列的同步"></a>2-方法内指令指令序列的同步</h3><p>同步一段指令集序列：通常是由 java 中的 synchronized 语句块来表示的。jvm 的指令集有 monitorenter 和  monitorexit 两条指令来支持 synchronized 关键字的语义。</p><p>当一个线程进入同步代码块时，它使用 monitorenterl 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入;若为 1, 则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p><p>当线程退出同步块时，需要使用 monitorexit 声明退出。在Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p><p>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p><p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程 4 离开临界区后，线程 1、2、3 才有可能进入。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622095830957.png" alt="image-20210622095830957" style="zoom:50%;"><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p><p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622101528989.png" alt="image-20210622101528989"></p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载过程（类的生命过程）详解</title>
      <link href="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</strong></p><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，他的整个生命周期包括如下7个阶段：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622143633263-4785833.png" alt="image-20210622143633263" style="zoom:50%;"><p>其中，验证、准备、解析3个部分统称为链接（Linking）</p><p>从程序中类的使用过程看：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622143915545-4785833.png" alt="image-20210622143915545" style="zoom:50%;"><p>注意：我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</p><h3 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h3><p><strong>蚂蚁金服：</strong></p><p>描述一下 JVM 加载 Class 文件的原理机制？</p><p>一面：类加载过程</p><p><strong>百度：</strong></p><p>类加载的时机 </p><p>java 类加载过程？</p><p>简述 java 类加载机制？</p><p><strong>腾讯：</strong></p><p>JVM 中类加载机制，类加载过程？</p><p><strong>滴滴：</strong></p><p>JVM 类加载机制</p><p><strong>美团：</strong></p><p>Java 类加载过程</p><p>描述一下 jvm 加载 class 文件的原理机制</p><p><strong>京东：</strong></p><p>什么是类的加载？</p><p>哪些情况会触发类的加载？</p><p>讲一下 JVM 加载一个类的过程</p><p> JVM 的类加载机制是什么？</p><h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="1-加载完成的操作"><a href="#1-加载完成的操作" class="headerlink" title="1-加载完成的操作"></a>1-加载完成的操作</h3><p><strong>加载的理解</strong></p><p>所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出Java 类的原型一一类模板对象。所谓类模板对象，其实就是Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM 在运行期便能通过类模板而获取java 类中的任意信息，能够对Java 类的成员变量进行遍历，也能进行Java 方法的调用。</p><p>反射的机制即基于这一基础。如果 JVM 没有将Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p><p><strong>加载完成的操作</strong></p><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例。</strong></p><p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p><ul><li><p>通过类的全名，获取类的二进制数据流</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p></li><li><p>创建 java.lang. Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><h3 id="2-二进制流的获取方式"><a href="#2-二进制流的获取方式" class="headerlink" title="2-二进制流的获取方式"></a>2-二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（<strong>只要所读取的字节码符合JVM 规范即</strong>可）</p><ul><li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）</li><li>读入 jar、zip 等归档数据包，提取类文件。</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于 HTTP 之类的协议通过网络进行加载</li><li>在运行时生成一段 C1ass 的二进制信息等</li></ul><p>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><h3 id="3-类模型与Class实例的位置"><a href="#3-类模型与Class实例的位置" class="headerlink" title="3-类模型与Class实例的位置"></a>3-类模型与Class实例的位置</h3><ol><li><strong>类模型的位置</strong></li></ol><p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDK1.8 之前：永久代：JDK1.8 及之后：元空间）。</p><ol start="2"><li><strong>Class 实例的位置</strong></li></ol><p>类将.Class 文件加载至元空间后，会在堆中创建一个Java.lang. Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p><p><strong>图示</strong></p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622145233118-4785833.png" alt="image-20210622145233118" style="zoom:50%;"><h3 id="4-数组类的加载"><a href="#4-数组类的加载" class="headerlink" title="4-数组类的加载"></a>4-数组类的加载</h3><p>创建数组类的情况稍有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p><ol><li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li></ol><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为  public。</p><h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="1-环节1-链接阶段之Vertification（验证）"><a href="#1-环节1-链接阶段之Vertification（验证）" class="headerlink" title="1-环节1:链接阶段之Vertification（验证）"></a>1-环节1:链接阶段之Vertification（验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><strong>它的目的是保证加载的细节码是合法、合理并符合规范的。</strong></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622160921984-4785833.png" alt="image-20210622160921984" style="zoom:50%;"><p><strong>整体说明：</strong></p><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><strong>其中格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器オ会成功将类的二进制数据信息加载到方法区中。</li><li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><p><strong>具体说明：</strong></p><p>1.格式验证：是否以魔数 0xCAFEBABE 开头，主版本和副版本号是否在当前Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p><p>和加载阶段一起执行。</p><p>2.Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li><p>是否所有的类都有父类的存在（在Java 里，除了 Object 外，其他类都应该有父类）</p></li><li><p>是否一些被定义为 final 的方法或者类被重写或继承了</p></li><li><p>非抽象类是否实现了所有抽象方法或者接口方法</p></li><li><p>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract 情况下的方法，就不能是 fina 的了）</p></li></ul><p>3.Java 虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p><ul><li><p>在字节码的执行过程中，是否会跳转到一条不存在的指令</p></li><li><p>函数的调用是否传递了正确类型的参数</p></li><li><p>变量的赋值是不是给了正确的数据类型等</p></li></ul><p>栈映射帧（Stackmaptable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检査出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p><strong>在前面 3 次检查中，已经排除文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p><p>4.校验器还将进行符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。</p><p><strong>此阶段在解析环节才会执行。</strong></p><h3 id="2-环节2-链接阶段之Preparation（准备）"><a href="#2-环节2-链接阶段之Preparation（准备）" class="headerlink" title="2-环节2:链接阶段之Preparation（准备）"></a>2-环节2:链接阶段之Preparation（准备）</h3><p><strong>简言之，为类的静态变量分配内存，并将其初始化为默认值。</strong></p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623111059486-4785833.png" alt="image-20210623111059486" style="zoom:50%;"><p>注意：Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故对应的，boolean 的默认值就是 false。</p><p><strong>注意：</strong></p><ol><li>这里不包含基本数据类型的字段用 static final 修饰的情況，因为 final 在编译的时候就会分配了，准备阶段会显式赋值。</li><li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java 堆中。</li><li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li></ol><p><strong>对注意中的第1点分析：</strong> </p><p>注意：以下前3点的前提都是字段已经完成显示赋值（定义的后面已经赋了值）的前提下进行的</p><p>1、非final修饰的静态变量会在准备阶段赋初始值，然后在初始化中的<code>&lt;clinit&gt;</code>方法中显示赋值</p><p>2、静态常量（基本数据类型、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值</p><p>3、引用数据类型的静态常量，尤其是<code>new String(&quot;XXX&quot;)</code>这种形式，都是在初始化中的<code>&lt;clinit&gt;</code>中进行显示赋值的</p><p>4、如果在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在初始化中的&lt;<code>clinit</code>&gt;方法中显示赋值</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622164156502-4785833.png" alt="image-20210622164156502" style="zoom:50%;"> <h3 id="3-环节3-链接阶段之Resolution（解析）"><a href="#3-环节3-链接阶段之Resolution（解析）" class="headerlink" title="3-环节3:链接阶段之Resolution（解析）"></a>3-环节3:链接阶段之Resolution（解析）</h3><p>在准备阶段完成后，就进入了解析阶段。</p><p><strong>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p><p><strong>1.具体描述</strong></p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 <code>printin（）</code>方法被调用时，系统需要明确知道该方法的位置</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622165228307-4785833.png" alt="image-20210622165228307" style="zoom:50%;"><p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p><h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><h3 id="1-static与final的搭配问题"><a href="#1-static与final的搭配问题" class="headerlink" title="1-static与final的搭配问题"></a>1-static与final的搭配问题</h3><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623151818526-4785833.png" alt="image-20210623151818526" style="zoom:25%;"><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623152955662-4785833.png" alt="image-20210623152955662" style="zoom:25%;"><p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623154030811-4785833.png" alt="image-20210623154030811"></p><p>注意⚠️：结论1中的显示赋值是指直接赋值<strong>常量</strong>的形式，而非调用方法的场景</p><p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623153238864-4785833.png" alt="image-20210623153238864"></p><p>结论：只有String特殊</p><p><strong>最终结论：使用 static+ final 修，且显示赋值中不涉及到方法或构造器调用的基本数据类型或 string 类型的显式赋值，是在链接阶段的准备环节进行。</strong></p><h3 id="2-lt-clinit-gt-的线程安全性"><a href="#2-lt-clinit-gt-的线程安全性" class="headerlink" title="2-&lt;clinit&gt;()的线程安全性"></a>2-<code>&lt;clinit&gt;</code>()的线程安全性</h3><p>对于<code>&lt;clinit&gt;（）</code>方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;（）</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;（）</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;（）</code>方法完毕。</p><p>正是因为函数<code>&lt;clinit&gt;（）</code>带锁线程安全的，因此，如果在一个类的<code>&lt;clinit&gt;（）</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加了类，则等在队列中的线程就没有机会再执行<code>&lt;c1init&gt;（）</code>方法了。那么，当需要使用这个类时虚拟机会直接返回给它经准备好的信息。</p><h3 id="3-类的初始化情况：主动使用VS被动使用"><a href="#3-类的初始化情况：主动使用VS被动使用" class="headerlink" title="3-类的初始化情况：主动使用VS被动使用"></a>3-类的初始化情况：主动使用VS被动使用</h3><p>Java程序对类的使用有两种：<strong>主动使用</strong> 和 <strong>被动使用</strong></p><p><strong>主动使用</strong></p><ul><li>当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</li><li>当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</li><li>当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量赋值变量操作）</li><li>当使用 java.lang. Reflect 包中的方法反射类的方法时。比如：Class.forname (“com atguigu.java.Test”)</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main（）方法的那个类），虚拟机会先初始化这个主类。</li><li>当初次调用 Methodhandle 实例时，初始化该 Methodhandle 指向的方法所在的类。（涉及解析 REF_ getstatic、REF_ putstatic、REF_ invokestatic 方法句柄对应的类）</li></ul><p>针对 5， 补充说明：</p><p>当Java 虚拟机初始化一个类时，要求它的所有父类都己经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，会导致该接口的初始化。</p><p>针对 7， 说明</p><p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用 <code>public static void main (String []）</code>方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p><p>下面是主动初始化一些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化会触发类的主动使用&lt;clnit&gt;()方法演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列化过程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">            Order o = (Order) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量赋值变量操作）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Order3.NUM1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">// 执行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;<span class="comment">// 不执行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num3 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">// 执行初始化</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order2执行初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Order3</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接口中不能定义静态代码块，采取的方式是声明一个能使用匿名内部类的字段</span></span><br><span class="line">    <span class="comment">// 下面这个方法会存在于&lt;clinit&gt;方法中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Order3的初始化方法执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1=<span class="number">1</span>;<span class="comment">// 不执行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM2=<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">// 执行初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被动使用</strong></p><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p><p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</strong></p><ol><li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<br> 当通过子类引用父类的静态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。</li><li>调用 ClassLoader 类的 loadclass（）方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassaveUse1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Parent[] parents=<span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent初始化了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过程四：类Using（使用）"><a href="#过程四：类Using（使用）" class="headerlink" title="过程四：类Using（使用）"></a>过程四：类Using（使用）</h2><h2 id="过程五：类的Unloading（卸载）"><a href="#过程五：类的Unloading（卸载）" class="headerlink" title="过程五：类的Unloading（卸载）"></a>过程五：类的Unloading（卸载）</h2><h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</p><p> Hotspot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都己经被回收。也就是Java 堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器己经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li><li>该类对应的 java.lang. Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><h3 id="类的Unloading"><a href="#类的Unloading" class="headerlink" title="类的Unloading"></a>类的Unloading</h3><h4 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h4><p>在类加载器的内部实现中，用一个Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器调用 Class 对象的 getClassLoader（）方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass（）方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的Java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>当 Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，不可触及时，Class 对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p><p><strong>一个类何时结束生命周期，取决于代表它的 Class 对象何时结東生命周期。</strong></p><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210627165843275.png" alt="image-20210627165843275" style="zoom:50%;"><p>loader1 变量和 obj 变量间接应用代表 Sampe 类的 Class 对象，而 objClass 变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为 null, 此时 Sample对象结束生命周期，MyclassLoader 对象结生命周期，代表 Sample 类的 Cass 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载</p><p>当再次有需要时，会检查 Sample类的 Class 对象是否存在，<strong>如果存在会直接使用，不再重新加载</strong>；如果不存在 Sample 类会被重新加载，在Java 虚拟机的堆区会生成一个新的代表 Sampe 类的 Class 实例（可以通过哈希码查看是否是同一个实例）。</p><h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>(1) 启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p><p>(2) 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p><p>(3) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码和源码分析Integer</title>
      <link href="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/"/>
      <url>/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/</url>
      
        <content type="html"><![CDATA[<h1 id="先从一段代码讲起"><a href="#先从一段代码讲起" class="headerlink" title="先从一段代码讲起"></a>先从一段代码讲起</h1><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1=<span class="number">59</span>;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">59</span>;</span><br><span class="line">        Integer i3=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">        Integer i4=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i1==i3);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">        System.out.println(i2==i4);</span><br><span class="line">        <span class="comment">//System.out.println(i1==i4);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>引起我的好奇的不是单一个的结果，而是这几个结果的组合，我感觉违背了数学定律，<code>i1==i2,i2==i4,i1==i3</code>,是不是可以推导出<code>i3==i4</code>?有了这个问题，我就开始了对每一个==的研究。</p><h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p>打开字节码</p><h3 id="创建属性的字节码"><a href="#创建属性的字节码" class="headerlink" title="创建属性的字节码"></a>创建属性的字节码</h3><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624163619597.png" alt="image-20210624163619597" style="zoom:50%;"><p>可以看到<code>i1</code>虽然是直接赋值，仍然调用了<code>valueOf()</code>方法；<code>i2</code>是基本数据类型<code>int</code>，所以直接赋值；<code>i3</code>不用讲；<code>i4</code>是<code>new</code>的，所以调用了构造方法 。</p><h3 id="比较过程的字节码"><a href="#比较过程的字节码" class="headerlink" title="比较过程的字节码"></a>比较过程的字节码</h3><p><strong><code>i1==i2</code></strong></p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624164510827.png" alt="image-20210624164510827" style="zoom:50%;"><p>我首先看到的是<code>if_icmpne</code>指令，这是一个<code>int</code>类型的比较指令，到这里其实就能懂了，<code>Integer</code>成为了<code>int</code>，那肯定是自动拆箱了，那前面的<code>intValue</code>方法肯定就是拆箱的方法了，具体的执行过程的源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int类型的比较，数值相同肯定相同了。</p><p><strong><code>i1==i3</code></strong></p><p>前面分析创建过程的时候我们知道了<code>i1</code>和<code>i3</code>都调用了同一个函数valueOf，那么他俩相等时不适合这个函数有关呢？我们先看一下字节码</p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624165301236.png" alt="image-20210624165301236" style="zoom:50%;"><p>就是普通的引用类型比较过程，那问题一定出在了<code>valueOf</code>函数，我们打开源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要的是这一段，我们看到了条件判断，其中出现了一个<code>IntegerCache</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这是一个静态内部类，<code>low=-128,high=127</code>，内部类中有个数组<code>cache</code>放着-128～127，也就是说如果<code>Integer</code>的值在-128～127之间的话直接返回数组索引地址，因此<code>i1==i3</code>！！！</p><p><strong><code>i3==i4</code></strong></p><p>通过前面的分析，我们能想到这个是<code>false</code>的原因了，一个是数组某一索引的地址，一个是存放在堆内的引用类型地址，不是同一个地址。</p><p><strong><code>i2==i4</code></strong></p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624171530684.png" alt="image-20210624171530684" style="zoom:50%;"><p>拆箱了，因此相等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个是<code>Integer</code>和<code>int</code>进行比较时，引用数据类型要进行拆箱，再比较。</p><p>第二是<code>Integer.valueOf()</code>方法的作用。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客测试</title>
      <link href="/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/hexo%E5%92%8CTypora%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%BB%93%E5%90%88.jpg" alt="Typora与hexo的完美结合"></p><p><img src="/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/image-20210624100808040.png" alt="image-20210624100808040"></p><p><img src="/image-20210624164510827.png" alt="image-20210624164510827"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/23/hello-world/"/>
      <url>/2021/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
