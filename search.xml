<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字节码指令集与解析举例</title>
      <link href="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/"/>
      <url>/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当作最基本的执行模型来理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">  自动计算PC寄存器的值+1；</span><br><span class="line">  根据PC寄存器的指示位置，从字节码流中取出操作码；</span><br><span class="line">  if(字节码存在操作数)从字节码流中取出操作数；</span><br><span class="line">  执行操作码所定义的操作；</span><br><span class="line">&#125;while(字节码长度&gt;0)</span><br></pre></td></tr></table></figure><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，<code>iload</code> 指令用于从局部变量表中加载 <code>int</code> 型的数据到操作数栈中，而 <code>fload</code> 指令加载的则是 <code>float</code> 类型的数据。</p><p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：</p><p>代表对 <code>int</code> 类型的数据操作，</p><p>l 代表 <code>1ong</code> </p><p>s 代表 <code>short</code> </p><p>b 代表 <code>byte</code> </p><p>c 代表 <code>char</code> </p><p>f 代表 <code>float</code> </p><p>d 代表 <code>double</code></p><p>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如 <code>arraylength</code> 指令，它没有代表数据类型的特殊字符，但</p><p>操作数永远只能是一个数组类型的对象。</p><p>还有另外一些指令，如无条件跳转指令 <code>goto</code> 则是与<strong>数据类型无关的</strong>。</p><p>大部分的指令都没有支持整数类型 <code>byte</code>、<code>char</code> 和 <code>short</code>，甚至没有任何指令支持 <code>boolean</code> 类型。编译器会在编译期或运行期将 <code>byte</code> 和 <code>short</code> 类型的数据带符号扩展（<code>Sign- Extend</code>）为相应的 <code>int</code> 类型数据, 将 <code>boolean</code>/和<code>char</code> 类型数据零位扩展（<code>Zero- Extend</code>）为相应的 <code>int</code> 类型数据。与之类似，在处理 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型的数组时，也会转换为使用对应的 <code>int</code> 类型的字节码指令来处理。因此，大多数对于 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型数据的操作，实际上都是使用相应的 <code>int</code> 类型作为运算类型。</p><h3 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h3><h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><p><strong>1、作用</strong></p><p>加载和存储指令用于将数据从栈桢的局部变量表和操作数之间来回传递</p><p><strong>2、常用指令</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621082659746.png" alt="image-20210621082659746"></p><p>上面所例举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>)。这些助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了    <code>iload_0、iload_1、iload_2、iload_3</code>这几个指令）。这组指令都是某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式，<strong>对于这若干组特殊指令来说，他们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p><p>除此之外，它们的语义与原生的通用指令完全一致（例如 <code>iload_0</code> 的语义与操作数为0时的 <code>iload</code> 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是 int 类型数据，<code>&lt;l&gt;</code> 代表 long 类型，<code>&lt;f&gt;</code>代表 float 类型，<code>&lt;d&gt;</code>代表 double 类型。</p><p>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</p><h3 id="复习：再谈操作数栈与局部变量表"><a href="#复习：再谈操作数栈与局部变量表" class="headerlink" title="复习：再谈操作数栈与局部变量表"></a>复习：再谈操作数栈与局部变量表</h3><p><strong>1、操作数栈</strong></p><p>我们知道，Java 字节码是Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为<strong>操作数栈，来存放计算的操作数以及返回结果</strong>。</p><p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数機中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入中。</p><p><strong>2、局部变量表（Local Variables）</strong></p><p>Java 方法桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p><p>实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p><p>和操作数栈一样，Long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621084753169.png" alt="image-20210621084753169"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085050120.png" alt="image-20210621085050120"></p><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="1-局部变量压栈指令"><a href="#1-局部变量压栈指令" class="headerlink" title="1-局部变量压栈指令"></a>1-局部变量压栈指令</h3><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数。</p><p>这类指令大体可以分为：</p><p>​        &gt;<code>xload_ &lt;n&gt;</code> (x 为 i、l、f、d、a, n 为 0 到 3) </p><p>​        &gt;<code>xload</code> (x 为 i、l、f、d、a）</p><p>说明：在这里，x 的取值表示数据类型。</p><p>指令 xload_n 表示将第 n 个局部变量压入操作数，比如 iload_1、fload_0、aload_0 等指令。其中 aload_n 表示将个对象引用压栈。</p><p>指令 xload 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令 iload、fload 等</p><p><strong>￼举例分析</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085858658.png" alt="image-20210621085858658"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085922759.png" alt="image-20210621085922759"></p><h3 id="2-常量入栈指令"><a href="#2-常量入栈指令" class="headerlink" title="2-常量入栈指令"></a>2-常量入栈指令</h3><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 <code>const</code>系列、<code>push</code> 系列和 <code>ldc</code> 指令。</p><p><strong>指令 <code>const</code> 系列</strong>：用于对特定的常量入，入的常量隐含在指令本身里。指令有：<code>const_&lt;i&gt;</code> (i 从-1 到 5)、<code>lconst_&lt;l&gt;</code> (l 从 0 到 1)、<code>fconst_ &lt;f&gt;</code> (f 从 0 到 2)、<code>dconst_&lt;d&gt;</code> (d 从 0 到 1)、aconst_null。</p><p> 比如，</p><p> iconst_m1 将 -1 压入操作数栈；</p><p> iconst _x (x 为到 5) 将 x 压入栈：</p><p> lconst_0、lconst_1 分别将长整数 0 和 1 压入栈；</p><p> fconst_0、fconst_1、fconst_2 分别将浮点数0、1、2 压入栈；</p><p> dconst_0 和 dconst_1 分别将 doublet 型 0 和 1 压入栈。</p><p> aconst_null 将 null 压入操作数</p><p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整数，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p><p><strong>指令 <code>push</code> 系列</strong>：主要包括 biush 和 sipush。它们的区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数， sipus 接收 16 位整数，它们都将参数压入栈。</p><p><strong>指令 <code>ldc</code> 系列</strong>：如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。</p><p>类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。</p><p>如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。</p><p>总结如下：</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621091752821.png" alt="image-20210621091752821"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092109463.png" alt="image-20210621092109463"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092316340.png" alt="image-20210621092316340"></p><p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，本次的n代表数值或者对象，而不是局部变量表中的下标</p><h3 id="3-出栈入局部变量表指令"><a href="#3-出栈入局部变量表指令" class="headerlink" title="3-出栈入局部变量表指令"></a>3-出栈入局部变量表指令</h3><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以 store 的形式存在，比如 xstore (x 为 i、l、f、d、a）、xstore_n (x 为 i、l、f、d、a, n 为 0 至 3)。</p><p>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它值给局部变量索引 n 位置。</p><p>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</p><p><strong>说明：</strong></p><p>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有  istore_0、istore_2、istore_3, 它们分别表示从操作数顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。</p><p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然増加了指令数量，但是可以大大压缩生成的字节码的体积如果局部变量表很大，需要存储的槽位大于 3, 那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。</p><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><p><strong>1、作用：</strong></p><p>算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p><p><strong>2、分类：</strong></p><p>大体上算数指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令。</p><p><strong>3、byte、short、char和boolean类型说明</strong></p><p>在每一大类中，都有针对Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095121174.png" alt="image-20210621095121174"></p><p><strong>4、运算时的溢出</strong></p><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常 ArithmeticException。</p><p><strong>5、运算模式</strong></p><p>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p><p>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</p><p><strong>6、NaN值使用</strong></p><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</p><p><strong>对于无穷大和NaN的举例</strong></p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095607569.png" alt="image-20210621095607569" style="zoom:50%;"><h3 id="1-所有算数指令"><a href="#1-所有算数指令" class="headerlink" title="1-所有算数指令"></a>1-所有算数指令</h3><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095751219.png" alt="image-20210621095751219" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095952979.png" alt="image-20210621095952979" style="zoom:50%;"><p>参数i=5，绿色表示局部变量表，蓝色表示操作数栈。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621100011574.png" alt="image-20210621100011574" style="zoom:50%;"><h3 id="2-比较指令的说明"><a href="#2-比较指令的说明" class="headerlink" title="2-比较指令的说明"></a>2-比较指令的说明</h3><p>比较指令的作用是比较顶两个元素的大小，并将比较结果入栈。</p><p>比较指令有：dampg, dcmpl、fcmpg、fcmpl、lcmp。</p><p>​        与前面讲解的指令类似，首字符 d 表示 double 类型，f表示 float,l 表示 long。</p><p>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令。以 float 为例，有 fcmp 和 fcmpl 两个指</p><p>令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。</p><p>指令 dcmpl 和 dampg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令。</p><p><strong>举例</strong></p><p>指令 fcmpg 和 fcmpl 都从中弹出两个操作数，并将它们做比较，设顶的元素为 v2, 栈顶顺位第 2 位的元素为 v1, 若</p><p>v1=v2, 则压入0；若 v1&gt; v2 则压入 1: 若 v1 &lt;v2 则压入-1。</p><p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1, 而 fcmpl 会压入-1。</p><p>数值类型的数据，才与以谈大小！ </p><p>boolean、引用数据类型不能比较大小</p><p><strong>注意</strong>：NaN(Not a Number)表示不是一个数字，比如0.0/0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，只有double和float类型中可能出现NaN的情况，而long类型不会出现NaN，所以只有lcmp。</p><h3 id="3-i-amp-i"><a href="#3-i-amp-i" class="headerlink" title="3- ++i&amp;i++"></a>3- ++i&amp;i++</h3><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101720616.png" alt="image-20210621101720616" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101758904.png" alt="image-20210621101758904" style="zoom:33%;"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101835404.png" alt="image-20210621101835404" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101855081.png" alt="image-20210621101855081" style="zoom:33%;"></p><p><strong>结论</strong>：如果只是i++和++i，字节码相同</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102017955.png" alt="image-20210621102017955" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102040391.png" alt="image-20210621102040391" style="zoom:33%;"></p><p><strong>结论</strong>：a=i++是将局部变量表中的10先加载到操作数栈，再对局部变量表中的10+1；然后再将操作数栈中的10存储到局部变量表中索引为2的空间中</p><p>b=j++是先将局部变量表中的20自加1之后再加载到操作数栈，然后在存储到局部变量表中</p><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p><strong>1、类型转换指令说明</strong></p><p>①类型转换指令可以将两种不同的数值类型进行相互转换。</p><p>②这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><h3 id="1-宽化类型转换"><a href="#1-宽化类型转换" class="headerlink" title="1-宽化类型转换"></a>1-宽化类型转换</h3><p><strong>1.转换规则</strong></p><p>Java 虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：</p><p>​        从 int 类型到 long、float 或者 double 类型。对应的指令为：i21、i2f、i2d</p><p>​        从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</p><p>​        从 float 类型到 double 类型。对应的指令为：f2d</p><p>简化为：<code>int--&gt;long--&gt; foat--&gt; double</code></p><p><strong>2.精度损失问题</strong></p><p>2.1 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</p><p>2.2 从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数值。</p><p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java 虚拟机抛出运行时异常。</p><p><strong>3.补充说明</strong></p><p>从 byte、char 和 short类型到 int 类型的宽化类型转换实际上是不存在的。对于 byte 类型转为 int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将 byte 转为 long 时，使用的是 i2l, 可以看到在内部 byte 在这里己经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：</p><p>​        一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只意使用一个字节表示指令，因此指令总数不能超过 256个，为了节省指令资源，将 short/和 byte 当做 int 处理也在情理之中。</p><p>​        另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p><h3 id="2-窄化类型转换"><a href="#2-窄化类型转换" class="headerlink" title="2-窄化类型转换"></a>2-窄化类型转换</h3><p><strong>1.转化规则</strong></p><p>Java 虚拟机也直接支持以下窄化类型转换:</p><p>​        从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s </p><p>​        从 long 类型到 int 类型。对应的指令有：l2i</p><p>​        从行 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l</p><p>​        从 doub1e 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f</p><p><strong>2.精度损失问题</strong></p><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><p><strong>3.补充说明</strong></p><p>3.1 当将一个浮点值窄化转换为整数类型 T (T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：</p><p>​        如果浮点值是 NaN，那转换结果就是 int 或 long 类型的0。</p><p>​        如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果V在目标类型 T (int 或 long）的表示范围之内，那转换结果就是V。否则，将根据 V 的符号，转换为 T 所能表示的最大或者最小正数</p><p>3.2 当将一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</p><p>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：</p><p>​        如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</p><p>​        如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</p><p>​        对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</p><p><strong>注意</strong>：从float、double、long等类型往byte、short、char类型转换的时候，需要先把前面几种类型转换成int类型，然后在从int类型转换到后面这几种类型，所以int类型相等于一种过渡类型</p><h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><p>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><h3 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1-创建指令"></a>1-创建指令</h3><p>虽然类实例和数组都是对象，但Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p><p><strong>1. 创建类实例的指令：</strong></p><p>创建类实例的指令：new</p><p>​        它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</p><p><strong>2. 创建数组的指令：</strong></p><p>创建数组的指令：newarray、anewarray、mu tianewarray</p><p>​         newarray：创建基本类型数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anewarray：创建引用类型数</span><br><span class="line"></span><br><span class="line">multianewarray：创建多维数组</span><br></pre></td></tr></table></figure><p>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也非常高。</p><p><strong>需要注意的细节：</strong></p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105624505.png" alt="image-20210621105624505" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105652436.png" alt="image-20210621105652436" style="zoom:50%;"><p>两个创建二维数组的字节码中的差距需要注意</p><h3 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2-字段访问指令"></a>2-字段访问指令</h3><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p><p>​        <em>访问类字段（static 字段，或者称为类变量）的指令：getstatic、putstatic</em> </p><p>​        <em>访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfied、putfield</em></p><p>举例：</p><p>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的</p><p>对象或者值，并将其压入操作数栈。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113216931.png" alt="image-20210621113216931" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113249177.png" alt="image-20210621113249177" style="zoom:50%;"><p>注意：<code>get***</code>是入栈，而<code>put***</code>是出栈</p><h3 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3-数组操作指令"></a>3-数组操作指令</h3><p>数组操作指令主要有：xastore 和 xaload 指令。具体为：</p><p>​        把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aalad</p><p>​        将一个操作数的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、 faster、dastore、aastore</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621114243226.png" alt="image-20210621114243226" style="zoom:50%;"><p>取数组长度的指令：arraylength</p><p>​        该指令弹出顶的数组元素，获取数组的长度，将长度压入栈</p><p><strong>说明</strong></p><p>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令xaload 在执行时，要求操作数中栈顶元素为数组素引，顶顺位第 2 个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 <code>a[i]</code>重新压入栈。</p><p> xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，restores 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</p><h3 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4-类型检查指令"></a>4-类型检查指令</h3><p>检查类实例或数组类型的指令：instanceof、checkcast。</p><p>​        指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数，否则它会抛出 ClassCastException 异常。</p><p>​        指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</p><h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1-方法调用指令"></a>1-方法调用指令</h3><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p><p>以下 <strong>5 条指令</strong>用于方法调用：</p><p>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java 语言中最常见的方法分派方式。</p><p> invokeinterface 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p><p> invokespecia 指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）、私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</p><p> invokestatic 指令用于调用命名类中的类方法（static 方法）。这是<strong>静态绑定</strong>的。</p><p> invokedynamic：调用动态绑定的方法，这个是JDK1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</p><p><strong>注意：</strong> </p><p>1、invokedynamic老师不讲，估计是很少遇到吧</p><p>2、invokeinterface是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</p><p>3、invokespecial只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了.  这几种方法都是不会被重写的</p><p>4、invokestatic是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是invokestatic，也不难理解</p><p>5、invokevirtual是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如A a = new B();a.hello()，其中B类继承A类，并且B类重写了A类中的hello()方法，这种情况下就是invokevirtual了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是invokevirtual了</p><h3 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2-方法返回指令"></a>2-方法返回指令</h3><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p><p>​        包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、 dreturn 和 areturn</p><p>​        另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621133956414.png" alt="image-20210621133956414" style="zoom:50%;"><p>举例：</p><p>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p><p>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</p><p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621135828244.png" alt="image-20210621135828244"></p><h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆那样，JVM 提供的操作数管理指令，可以用于直接操作操作数的指令。</p><p>这类指令包括如下内容：</p><p>​        将一个或两个元素从栈顶弹出，并且直接废弃：pop, pop2</p><p>​        复制顶一个或两个数值并将复制值或双份的复制值重新压入顶：dup, dup2, dup_x1,  dup2 x1, dup_x2, dup2_x2:</p><p>​        将栈最顶端的两个Slot数值位置交换：swap。Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令。</p><p>​        指令 nop，是一个非常特殊的指令，它的字节码为 x。和汇编语言中的 nop 一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p><p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p><p><strong>说明：</strong></p><p>不带_x 的指令是复制栈顶数据并压入顶。包括两个指令，dup 和 dup2。dup 的系数代表要复制的 Slot 个数。</p><p>​        dup 开头的指令用于复制 1 个 Sot 的数据。例如 1 个 int 或 1 个 reference 类型数据</p><p>​        dup2 开头的指令用于复制 2 个 S1ot 的数据。例如 1 个 1ong，或 2 个 int，或 1 个 int+1 个 float 类型数据</p><p>带_x 的指令是复制栈顶数据并插入顶以下的某个位置。共有 4 个指令，dup_x1, dup2_x1,</p><p>dup_x2, dup2_x2. 对于带_x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插</p><p>入的位置。因此</p><p>​        dup_x1 插入位置：1+1=2, 即栈顶 2 个 Slot 下面</p><p>​        dup_x2 插入位置：1+2=3, 即栈顶 3 个 Slot 下面</p><p>​        dup2_x1 插入位置：2+1=3, 即栈顶 3 个 Slot 下面</p><p>​        dup2_x2 插入位置：2+2=4, 即栈顶 4 个 Slot 下面</p><p>pop：将顶的 1 个 Slot 数值出。例如 1 个 short 类型数值</p><p>pop2: 将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值</p><h2 id="控制转义指令"><a href="#控制转义指令" class="headerlink" title="控制转义指令"></a>控制转义指令</h2><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为 1) 比较指令、2) 条件跳转指令、3) 比较条件跳转指令、4) 多条件分支跳转指令、5) 无条件跳转指令等。</p><p>比较指令见算数指令</p><h3 id="1-条件跳转指令"><a href="#1-条件跳转指令" class="headerlink" title="1-条件跳转指令"></a>1-条件跳转指令</h3><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p><p>条件跳转指令有：ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull。这些指令都接收两个字节的操作数用于计算跳转的位置（16 位符号整数作为当前位置的 offset）。</p><p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621152715017.png" alt="image-20210621152715017"></p><p>注意</p><ol><li>与前面运算规则一致：</li></ol><p>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成</p><p>对于 long、float、double：类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转</p><ol><li><p>由于各类型的比较最终都会转为 int 类型的比较操作，所以Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621153319123.png" alt="image-20210621153319123"></p><p>⚠️这里是满足条件就跳转，而源程序中是满足条件则继续执行 </p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621155510988.png" alt="image-20210621155510988"></p><p>这里需要⚠️，print函数最后输出的是boolean类型的，当前操作数栈中的1作为参数传到print方法中以后，此处的print方法是调用的返回值为boolean的重载方法，如下图</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160314388.png" alt="image-20210621160314388"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160603355.png" alt="image-20210621160603355"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162110106.png" alt="image-20210621162110106"></p></li></ol><p><strong>注意：</strong> </p><p>1、对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用<strong>比较指令和条件跳转指令</strong> 来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型</p><p>2、int类型值（包含byte、char、short）比较 和 对象类型值比较需要使用<strong>比较条件跳转指令</strong> </p><h3 id="2-比较条件跳转指令"><a href="#2-比较条件跳转指令" class="headerlink" title="2-比较条件跳转指令"></a>2-比较条件跳转指令</h3><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p><p>这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_ icmpgt、if_ icmple、if_icmpge、if_ acmpeq和 if_ acmpne。其中指令助记符加上“if_”后，以字符“i”开头的指令针对int型整数操作（也包括 short 和 byte 类型），以字符“a”开头的指令表示对象引用的比较。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162346744.png" alt="image-20210621162346744"></p><p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入。<strong>如果预设条件成立，则执行跳转，否则，继续执行下条语句。</strong></p><p><strong>举例如下</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162751624.png" alt="image-20210621162751624"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621163632471.png" alt="image-20210621163632471"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164348661.png" alt="image-20210621164348661"></p><p><strong>总结：</strong></p><p>只有int或者用int表示的类型可以直接使用<strong>比较条件跳转指令</strong>；</p><p>double，float，long则需要<strong>比较指令</strong>和<strong>条件跳转指令</strong>共同使用才能完成跳转。</p><h3 id="3-多条件分支跳转"><a href="#3-多条件分支跳转" class="headerlink" title="3-多条件分支跳转"></a>3-多条件分支跳转</h3><p>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164743732.png" alt="image-20210621164743732"></p><p>从助记符上看，两者都是 switch 语句的实现，它们的区别：</p><p>​         tableswitch 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高。</p><p>​        指令 lookupswitch 内部存放着各个离散的 case- offset 对，每次执行都要搜索全部的 case- offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此效率较低。</p><p>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203815830.png" alt="image-20210621203815830"></p><p>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 <strong>case- offset 对按照 case 值大小排</strong>序，给定 index 时，需要査查找与 index 相等的 case，获得其offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203953038.png" alt="image-20210621203953038"></p><p><strong>举例如下</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171348274.png" alt="image-20210621171348274"></p><p>如果将case2中的break注释掉，</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171614629.png" alt="image-20210621171614629"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202029361.png" alt="image-20210621202029361"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202709783.png" alt="image-20210621202709783"></p><p>这里对字符串的比较，先比较哈希值，哈希值相同再比较值是否相等</p><h3 id="4-无条件跳转"><a href="#4-无条件跳转" class="headerlink" title="4-无条件跳转"></a>4-无条件跳转</h3><p>目前主要的无条件跳转指令为 goto。指令 goto 接收<strong>两个字节</strong>的操作数，共同组成一个带符号的整数，用于指定指令的偏移量指令执行的目的就是跳转到偏移量给定的位置处。</p><p>如果指令偏移量太大，超过双字节的帯符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它<strong>接收 4 个字节</strong>的操作数，可以表示更大的地址范围。</p><p>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且己经被虛拟机<em>逐渐废弃</em>，故不在这里介绍这两个指令。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204052272.png" alt="image-20210621204052272"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204647802.png" alt="image-20210621204647802"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205120603.png" alt="image-20210621205120603"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205408219.png" alt="image-20210621205408219"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205643514.png" alt="image-20210621205643514"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205815307.png" alt="image-20210621205815307"></p><h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>异常及异常的处理：</p><p>过程一：异常对象的生成过程—&gt; throw(手动/自动) —-&gt;指令：athrow </p><p>过程二：异常的处理：抓抛模型。try- catch- finaly —-&gt;使用异常表</p><h3 id="1-抛出异常指令"><a href="#1-抛出异常指令" class="headerlink" title="1-抛出异常指令"></a>1-抛出异常指令</h3><p>(1) athrow 指令</p><p>在Java 程序中显示抛出异常的操作（throw 语句）都是由 athrow 指令来实现。</p><p>除了使用 throw 语句显示抛出异常情况之外，JVM 规范还规定了许多运行时异常会在其他Java 虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出  ArithmeticException 异常。</p><p> (2) 注意</p><p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java 虚拟机会清除操作数上的所有内容，而后将异常实例压入调用者操作数栈上。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621221625270.png" alt="image-20210621221625270"></p><p>如果使用throw new 异常名称() 这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称 这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223049071.png" alt="image-20210621223049071"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223157782.png" alt="image-20210621223157782"></p><h3 id="2-异常处理与异常表"><a href="#2-异常处理与异常表" class="headerlink" title="2-异常处理与异常表"></a>2-异常处理与异常表</h3><p><strong>1、处理异常：</strong></p><p>在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是采用异常表来完成的。</p><p><strong>2、异常表</strong></p><p>如果一个方法定义了一个 try- catch 或者 try- finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者  finally 块的信息。异常表保存了每个异常处理信息。比如</p><p>​        起始位置</p><p>​        结束位置</p><p>​        程序计数器记录的代码处理的偏移地址</p><p>​        被捕获的异常类在常量池中的索引</p><p><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法（在调用方法帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM 自己终止，比如这个线程是个 main 线程。</p><p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finaly 块来完成目标</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622092751237.png" alt="image-20210622092751237"></p><p>栈中压入创建的异常实例信息后，会和异常表中的一场类型进行比对，因此说异常处理是通过异常表进行的</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622093823020.png" alt="image-20210622093823020"></p><p><strong>这里的异常处理，其实是重新做了一遍finally里面的事情，因为finally里面的代码时一定要执行，如果未发生异常，则上面的代码不会中断，顺利执行完finally中的代码，如果发生异常，在异常处理中也要执行finally中的代码。</strong></p><h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><p>组成</p><p>java 虚拟机支持两种同步结构：<strong>方法级的同步和方法内部一段指令序列的同</strong>步，这两种同步都是使用 monitor 来支持的</p><h3 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1-方法级的同步"></a>1-方法级的同步</h3><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONZED 访问标志得知一个方法是否声明为同步方法</p><p>当调用方法时，调用指令将会检方法的 ACC_SYNCHRONIZED 访问标志是否设置。</p><p>​        如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p><p>​        在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁</p><p>​        如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622112918956.png" alt="image-20210622112918956" style="zoom:50%;"><p>说明：</p><p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <strong>monitorenter 和 monitorexiti 进</strong>行同步区控制。这是因为，对于同步方法而言，当虚拟机通<strong>过方法的访问标示</strong>符判断是一个同步方法时<strong>，会自动在方法调用前进行加锁，当</strong>同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和  monitorexit 指令是<strong>隐式存在的</strong>，并未直接出现在字节码中。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622113055258.png" alt="image-20210622113055258"></p><h3 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2-方法内指令指令序列的同步"></a>2-方法内指令指令序列的同步</h3><p>同步一段指令集序列：通常是由 java 中的 synchronized 语句块来表示的。jvm 的指令集有 monitorenter 和  monitorexit 两条指令来支持 synchronized 关键字的语义。</p><p>当一个线程进入同步代码块时，它使用 monitorenterl 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入;若为 1, 则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p><p>当线程退出同步块时，需要使用 monitorexit 声明退出。在Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p><p>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p><p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程 4 离开临界区后，线程 1、2、3 才有可能进入。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622095830957.png" alt="image-20210622095830957" style="zoom:50%;"><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p><p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622101528989.png" alt="image-20210622101528989"></p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载过程（类的生命过程）详解</title>
      <link href="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</strong></p><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，他的整个生命周期包括如下7个阶段：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622143633263.png" alt="image-20210622143633263" style="zoom:50%;"><p>其中，验证、准备、解析3个部分统称为链接（Linking）</p><p>从程序中类的使用过程看：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622143915545.png" alt="image-20210622143915545" style="zoom:50%;"><p>注意：我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</p><h3 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h3><p><strong>蚂蚁金服：</strong></p><p>描述一下 JVM 加载 Class 文件的原理机制？</p><p>一面：类加载过程</p><p><strong>百度：</strong></p><p>类加载的时机 </p><p>java 类加载过程？</p><p>简述 java 类加载机制？</p><p><strong>腾讯：</strong></p><p>JVM 中类加载机制，类加载过程？</p><p><strong>滴滴：</strong></p><p>JVM 类加载机制</p><p><strong>美团：</strong></p><p>Java 类加载过程</p><p>描述一下 jvm 加载 class 文件的原理机制</p><p><strong>京东：</strong></p><p>什么是类的加载？</p><p>哪些情况会触发类的加载？</p><p>讲一下 JVM 加载一个类的过程</p><p> JVM 的类加载机制是什么？</p><h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="1-加载完成的操作"><a href="#1-加载完成的操作" class="headerlink" title="1-加载完成的操作"></a>1-加载完成的操作</h3><p><strong>加载的理解</strong></p><p>所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出Java 类的原型一一类模板对象。所谓类模板对象，其实就是Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM 在运行期便能通过类模板而获取java 类中的任意信息，能够对Java 类的成员变量进行遍历，也能进行Java 方法的调用。</p><p>反射的机制即基于这一基础。如果 JVM 没有将Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p><p><strong>加载完成的操作</strong></p><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例。</strong></p><p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p><ul><li><p>通过类的全名，获取类的二进制数据流</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p></li><li><p>创建 java.lang. Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><h3 id="2-二进制流的获取方式"><a href="#2-二进制流的获取方式" class="headerlink" title="2-二进制流的获取方式"></a>2-二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（<strong>只要所读取的字节码符合JVM 规范即</strong>可）</p><ul><li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）</li><li>读入 jar、zip 等归档数据包，提取类文件。</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于 HTTP 之类的协议通过网络进行加载</li><li>在运行时生成一段 C1ass 的二进制信息等</li></ul><p>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><h3 id="3-类模型与Class实例的位置"><a href="#3-类模型与Class实例的位置" class="headerlink" title="3-类模型与Class实例的位置"></a>3-类模型与Class实例的位置</h3><ol><li><strong>类模型的位置</strong></li></ol><p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDK1.8 之前：永久代：JDK1.8 及之后：元空间）。</p><ol start="2"><li><strong>Class 实例的位置</strong></li></ol><p>类将.Class 文件加载至元空间后，会在堆中创建一个Java.lang. Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p><p><strong>图示</strong></p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622145233118.png" alt="image-20210622145233118" style="zoom:50%;"><h3 id="4-数组类的加载"><a href="#4-数组类的加载" class="headerlink" title="4-数组类的加载"></a>4-数组类的加载</h3><p>创建数组类的情况稍有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p><ol><li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li></ol><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为  public。</p><h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="1-环节1-链接阶段之Vertification（验证）"><a href="#1-环节1-链接阶段之Vertification（验证）" class="headerlink" title="1-环节1:链接阶段之Vertification（验证）"></a>1-环节1:链接阶段之Vertification（验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><strong>它的目的是保证加载的细节码是合法、合理并符合规范的。</strong></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622160921984.png" alt="image-20210622160921984" style="zoom:50%;"><p><strong>整体说明：</strong></p><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><strong>其中格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器オ会成功将类的二进制数据信息加载到方法区中。</li><li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><p><strong>具体说明：</strong></p><p>1.格式验证：是否以魔数 0xCAFEBABE 开头，主版本和副版本号是否在当前Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p><p>和加载阶段一起执行。</p><p>2.Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li><p>是否所有的类都有父类的存在（在Java 里，除了 Object 外，其他类都应该有父类）</p></li><li><p>是否一些被定义为 final 的方法或者类被重写或继承了</p></li><li><p>非抽象类是否实现了所有抽象方法或者接口方法</p></li><li><p>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract 情况下的方法，就不能是 fina 的了）</p></li></ul><p>3.Java 虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p><ul><li><p>在字节码的执行过程中，是否会跳转到一条不存在的指令</p></li><li><p>函数的调用是否传递了正确类型的参数</p></li><li><p>变量的赋值是不是给了正确的数据类型等</p></li></ul><p>栈映射帧（Stackmaptable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检査出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p><strong>在前面 3 次检查中，已经排除文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p><p>4.校验器还将进行符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。</p><p><strong>此阶段在解析环节才会执行。</strong></p><h3 id="2-环节2-链接阶段之Preparation（准备）"><a href="#2-环节2-链接阶段之Preparation（准备）" class="headerlink" title="2-环节2:链接阶段之Preparation（准备）"></a>2-环节2:链接阶段之Preparation（准备）</h3><p><strong>简言之，为类的静态变量分配内存，并将其初始化为默认值。</strong></p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623111059486.png" alt="image-20210623111059486" style="zoom:50%;"><p>注意：Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故对应的，boolean 的默认值就是 false。</p><p><strong>注意：</strong></p><ol><li>这里不包含基本数据类型的字段用 static final 修饰的情況，因为 final 在编译的时候就会分配了，准备阶段会显式赋值。</li><li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java 堆中。</li><li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li></ol><p><strong>对注意中的第1点分析：</strong> </p><p>注意：以下前3点的前提都是字段已经完成显示赋值（定义的后面已经赋了值）的前提下进行的</p><p>1、非final修饰的静态变量会在准备阶段赋初始值，然后在初始化中的<code>&lt;client&gt;</code>方法中显示赋值</p><p>2、静态常量（基本数据类型、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值</p><p>3、引用数据类型的静态常量，尤其是<code>new String(&quot;XXX&quot;)</code>这种形式，都是在初始化中的&lt;<code>client</code>&gt;中进行显示赋值的</p><p>4、如果在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在初始化中的&lt;<code>client</code>&gt;方法中显示赋值</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622164156502.png" alt="image-20210622164156502" style="zoom:50%;"> <h3 id="3-环节3-链接阶段之Resolution（解析）"><a href="#3-环节3-链接阶段之Resolution（解析）" class="headerlink" title="3-环节3:链接阶段之Resolution（解析）"></a>3-环节3:链接阶段之Resolution（解析）</h3><p>在准备阶段完成后，就进入了解析阶段。</p><p><strong>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p><p><strong>1.具体描述</strong></p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 <code>printin（）</code>方法被调用时，系统需要明确知道该方法的位置</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622165228307.png" alt="image-20210622165228307" style="zoom:50%;"><p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p><h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623151818526.png" alt="image-20210623151818526" style="zoom:50%;"><p><img src="/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623152955662.png" alt="image-20210623152955662"></p><p><img src="/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623154030811.png" alt="image-20210623154030811"></p><p>注意⚠️：结论1中的显示赋值是指直接赋值<strong>常量</strong>的形式，而非调用方法的场景</p><p><img src="/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623153238864.png" alt="image-20210623153238864"></p><p>结论：只有String特殊</p><p><strong>最终结论：使用 static+ final 修，且显示赋值中不及到方法或构造器调用的基本数据类型或 string 类型的显式赋值，是在链接阶段的准备环节进行。</strong></p><h3 id="1-static与final的搭配问题"><a href="#1-static与final的搭配问题" class="headerlink" title="1-static与final的搭配问题"></a>1-static与final的搭配问题</h3><h3 id="2-lt-client-gt-的线程安全性"><a href="#2-lt-client-gt-的线程安全性" class="headerlink" title="2-&lt;client&gt;()的线程安全性"></a>2-<code>&lt;client&gt;</code>()的线程安全性</h3><h3 id="3-类的初始化情况：主动使用VS被动使用"><a href="#3-类的初始化情况：主动使用VS被动使用" class="headerlink" title="3-类的初始化情况：主动使用VS被动使用"></a>3-类的初始化情况：主动使用VS被动使用</h3><h2 id="过程四：类Using（使用）"><a href="#过程四：类Using（使用）" class="headerlink" title="过程四：类Using（使用）"></a>过程四：类Using（使用）</h2><h2 id="过程五：类的Unloading（卸载）"><a href="#过程五：类的Unloading（卸载）" class="headerlink" title="过程五：类的Unloading（卸载）"></a>过程五：类的Unloading（卸载）</h2><h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码和源码分析Integer</title>
      <link href="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/"/>
      <url>/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/</url>
      
        <content type="html"><![CDATA[<h1 id="先从一段代码讲起"><a href="#先从一段代码讲起" class="headerlink" title="先从一段代码讲起"></a>先从一段代码讲起</h1><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1=<span class="number">59</span>;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">59</span>;</span><br><span class="line">        Integer i3=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">        Integer i4=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i1==i3);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">        System.out.println(i2==i4);</span><br><span class="line">        <span class="comment">//System.out.println(i1==i4);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>引起我的好奇的不是单一个的结果，而是这几个结果的组合，我感觉违背了数学定律，<code>i1==i2,i2==i4,i1==i3</code>,是不是可以推导出<code>i3==i4</code>?有了这个问题，我就开始了对每一个==的研究。</p><h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p>打开字节码</p><h3 id="创建属性的字节码"><a href="#创建属性的字节码" class="headerlink" title="创建属性的字节码"></a>创建属性的字节码</h3><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624163619597.png" alt="image-20210624163619597" style="zoom:50%;"><p>可以看到<code>i1</code>虽然是直接赋值，仍然调用了<code>valueOf()</code>方法；<code>i2</code>是基本数据类型<code>int</code>，所以直接赋值；<code>i3</code>不用讲；<code>i4</code>是<code>new</code>的，所以调用了构造方法 。</p><h3 id="比较过程的字节码"><a href="#比较过程的字节码" class="headerlink" title="比较过程的字节码"></a>比较过程的字节码</h3><p><strong><code>i1==i2</code></strong></p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624164510827.png" alt="image-20210624164510827" style="zoom:50%;"><p>我首先看到的是<code>if_icmpne</code>指令，这是一个<code>int</code>类型的比较指令，到这里其实就能懂了，<code>Integer</code>成为了<code>int</code>，那肯定是自动拆箱了，那前面的<code>intValue</code>方法肯定就是拆箱的方法了，具体的执行过程的源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int类型的比较，数值相同肯定相同了。</p><p><strong><code>i1==i3</code></strong></p><p>前面分析创建过程的时候我们知道了<code>i1</code>和<code>i3</code>都调用了同一个函数valueOf，那么他俩相等时不适合这个函数有关呢？我们先看一下字节码</p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624165301236.png" alt="image-20210624165301236" style="zoom:50%;"><p>就是普通的引用类型比较过程，那问题一定出在了<code>valueOf</code>函数，我们打开源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要的是这一段，我们看到了条件判断，其中出现了一个<code>IntegerCache</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这是一个静态内部类，<code>low=-128,high=127</code>，内部类中有个数组<code>cache</code>放着-128～127，也就是说如果<code>Integer</code>的值在-128～127之间的话直接返回数组索引地址，因此<code>i1==i3</code>！！！</p><p><strong><code>i3==i4</code></strong></p><p>通过前面的分析，我们能想到这个是<code>false</code>的原因了，一个是数组某一索引的地址，一个是存放在堆内的引用类型地址，不是同一个地址。</p><p><strong><code>i2==i4</code></strong></p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624171530684.png" alt="image-20210624171530684" style="zoom:50%;"><p>拆箱了，因此相等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个是<code>Integer</code>和<code>int</code>进行比较时，引用数据类型要进行拆箱，再比较。</p><p>第二是<code>Integer.valueOf()</code>方法的作用。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客测试</title>
      <link href="/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/hexo%E5%92%8CTypora%E7%9A%84%E5%AE%8C%E7%BE%8E%E7%BB%93%E5%90%88.jpg" alt="Typora与hexo的完美结合"></p><p><img src="/2021/06/24/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/image-20210624100808040.png" alt="image-20210624100808040"></p><p><img src="/image-20210624164510827.png" alt="image-20210624164510827"></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/23/hello-world/"/>
      <url>/2021/06/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
