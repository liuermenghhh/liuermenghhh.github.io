<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/game32*32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/game16*16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuermenghhh.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM中篇，运行时数据区----本地方法栈、本地方法接口、堆 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="运行时数据区（本地方法栈&amp;堆）">
<meta property="og:url" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/index.html">
<meta property="og:site_name" content="刘二萌的博客">
<meta property="og:description" content="JVM中篇，运行时数据区----本地方法栈、本地方法接口、堆 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715213917030.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715221208704.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222534835.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222431571.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222707075.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715223410342.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716093835831.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716094133585.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716100056988.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103050211.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103615156.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103757241.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103832545.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105627607.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105736720.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105829050.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716110045243.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111230457.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111326098.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111609911.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111643799.png">
<meta property="article:published_time" content="2021-07-16T03:39:19.000Z">
<meta property="article:modified_time" content="2021-07-16T03:43:35.017Z">
<meta property="article:author" content="superBaby">
<meta property="article:tag" content="-JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715213917030.png">

<link rel="canonical" href="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>运行时数据区（本地方法栈&堆） | 刘二萌的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">刘二萌的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iu.GIF">
      <meta itemprop="name" content="superBaby">
      <meta itemprop="description" content="记录学习">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘二萌的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          运行时数据区（本地方法栈&堆）
        </h1>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              
    
              <time title="创建时间：2021-07-16 11:39:19 / 修改时间：11:43:35" itemprop="dateCreated datePublished" datetime="2021-07-16T11:39:19+08:00">2021-07-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">JVM学习</span></a>
                </span>
            </span>
    
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">JVM中篇，运行时数据区----本地方法栈、本地方法接口、堆 学习笔记</div>
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
        <img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715213917030.png" alt="image-20210715213917030" style="zoom: 50%;">

<h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><p>简单地讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。一个  Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern”c“告知 C++编译器去调用一个 C 的函数。</p>
<p>A native method is a Java method whose implementation is provided by non-java code</p>
<p>在定义ー个 native method 时，并不提供实现体（有些像定义ー个 Java  interface），因为其实现体是由非 java语言在外面实现的。</p>
<p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p>
<h2 id="为什么使用NativeMethod"><a href="#为什么使用NativeMethod" class="headerlink" title="为什么使用NativeMethod"></a>为什么使用NativeMethod</h2><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<p><strong>与 Java 环境外交互：</strong></p>
<ul>
<li>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</li>
</ul>
<p><strong>与操作系统交互：</strong></p>
<ul>
<li>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ul>
<p><strong>Sun ‘s Java</strong></p>
<ul>
<li>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang. Thread 的 setpriority（）方法是用 Java 实现的，但是它实现调用的是该类里的本地方法  setpriority0（）。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 windows95 的平台上，这个本地方法最终将调用 Win32 Setpriority () API。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVM 调用。</li>
</ul>
<h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p>
<h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p>
<p>本地方法栈，也是线程私有的</p>
<p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p>
<ul>
<li>如果线程请求分配的容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li>
<li>如果本地方法可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 outofmemoryerror 异常。</li>
</ul>
<p>本地方法是使用C语言实现的</p>
<p>它的具体做法是 Native Method Stack 中登记 native 方法，在  Execution Engine 执行时加载本地方法库。</p>
<p>当某个线程调用一个本地方它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥同样的权限。</p>
<ul>
<li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
</ul>
<p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现地方法栈</p>
<p>在 Hotspot JVM 中，直接将本地方法和虚拟机合二为一</p>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p>
<p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。堆内存的大小是可以调节的。</p>
<p>《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p>
<p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB)。</p>
<p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p>
<ul>
<li>“几乎”所有的对象实例都在这里分配内存。—-从实际的角度看的</li>
</ul>
<p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
<p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收时才会被移除。</p>
<p>堆，是GC（Garbage Collection）执行垃圾回收的重点区域。</p>
<p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715221208704.png" alt="image-20210715221208704"></p>
<p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222534835.png" alt="image-20210715222534835" style="zoom:50%;">

<p><strong>堆空间的内部结构（JDK7&amp;JDK8）</strong></p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222431571.png" alt="image-20210715222431571" style="zoom:50%;">



<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222707075.png" alt="image-20210715222707075" style="zoom: 33%;">

<h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项“-Xmx“和“-Xms“来进行设置。</p>
<ul>
<li>“-Xms“用于表示堆区的起始内存，等价于-XX: InitialHeapsize</li>
<li>“-Xmx“则用于表示堆区的最大内存，等价于-XX: MaxHeapsize</li>
</ul>
<p>一旦堆区中的内存大小超过“-Xmx“所指定的最大内存时，将会抛出  OutOfMemoryError 异常。</p>
<p>通常会将-Xms 和 -Xmx 两个参数配置相同的值，其目<strong>的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong></p>
<p>默认情況下, 初始内存大小：物理电脑内存大小1/64</p>
<p>最大内存大小：物理电脑内存大小1/4</p>
<h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM生命周期保持一致。</li>
</ul>
<p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）。</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715223410342.png" alt="image-20210715223410342" style="zoom:50%;">

<p>新生代和老年代的比例一般为1:2，默认- XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3。</p>
<p>在 Hotspot 中，Eden 空间和另外两个 Survivor空间缺省所占的比例是 8:1:1 当然开发人员可以通过选项“-XX: SurvivorRatlo”调整这个空间比例。比如-XX: SurvivorRatio=8</p>
<p>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。</p>
<p>绝大部分的 Java 对象的销毁都在新生代进行了。</p>
<ul>
<li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的</li>
</ul>
<p>可以使用选项-Xmn“设置新生代最大内存大小</p>
<ul>
<li>这个参数一般使用默认值就可以了。</li>
</ul>
<h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</li>
<li>New 的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是 15 次。<ul>
<li>可以设置参数：<code>--XX:MaxTenuringThreshold=&lt;N&gt;</code>进行设置</li>
</ul>
</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC: Major GC，进行养老区的内存清理</li>
<li>若养老区执行了 Maior GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常<ul>
<li>Java.lang.OutOfMemoryError:Java heap space</li>
</ul>
</li>
</ol>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716093835831.png" alt="image-20210716093835831" style="zoom:50%;">

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。</p>
<p>关于垃圾回收：频繁发生在新生区，很少在养老区收集，几乎不在永久区/元空间收集。</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716094133585.png" alt="image-20210716094133585" style="zoom:50%;">

<h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM 在进行 GC 时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。</p>
<p>针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC)</p>
<ul>
<li><p>部分收集：不是完整收集整个Java 堆的垃圾收集。其中又分为</p>
<ul>
<li><p>新生代收集（Minor GC/ Young GC）：只是新生代的垃圾收集</p>
</li>
<li><p>老年代收集 (Major GC/Old GC）：只是老年代的垃圾收集。</p>
<ul>
<li><p>目前，只有 CMS GC 会有单独收集老年代的行为。</p>
</li>
<li><p>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</p>
</li>
</ul>
</li>
<li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。</p>
<ul>
<li>目前，只有 G1 GC 会有这种行为</li>
</ul>
</li>
</ul>
</li>
<li><p>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</p>
</li>
</ul>
<h3 id="最简单的分代式GC策略的触发条件"><a href="#最简单的分代式GC策略的触发条件" class="headerlink" title="最简单的分代式GC策略的触发条件"></a>最简单的分代式GC策略的触发条件</h3><p><strong>年轻代GC（Minor GC）触发机制：</strong></p>
<ul>
<li>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存。）</li>
<li>因为 Java 对象大多都具备朝生タ灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解</li>
<li> Minor GC会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>
</ul>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716100056988.png" alt="image-20210716100056988" style="zoom: 33%;">

<p><strong>老年代GC（Major GC/Full GC）触发机制：</strong></p>
<ul>
<li><p>指发生在老年代的 GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>
</li>
<li><p>出现了 Major Gc，经常会伴随至少ー次的 Minor GC（但非绝对的，在 Parallel  Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足则触发 Major Gc</li>
</ul>
</li>
<li><p> Major GC 的速度一般会比 Minor GC慢10倍以上，STW 的时间更长。</p>
</li>
<li><p>如果 Major GC 后，内存还不足，就报 OOM 了。 </p>
</li>
</ul>
<p><strong>Full GC触发机制：</strong>（后面详细介绍）</p>
<p>触发 Fu11GC 执行的情况有如下五种：</p>
<ol>
<li>调用 System.gc（）时，系统建议执行 Full GC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li>
<li> 由 Eden 区、survivor space0 (From Space）区向 survivor space1 (To  Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
<p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些。</p>
<h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p><strong>为什么需要把Java堆分代？不分代就不能正常工作了吗？</strong></p>
<ul>
<li><p>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。</p>
<ul>
<li><p>新生代：有Eden、两块大小相同的Survivor构成，to总为空</p>
</li>
<li><p>老年代：存放新生代中经历多次GC仍然存活的对象</p>
</li>
</ul>
</li>
<li><p>其实不分代完全可以，分代的唯一理由就是优化 GC 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
</li>
</ul>
<h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在  Survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代中</p>
<p>对象晋升老年代的年龄阈值，可以通过选项-XX: MaxTenuringThreshold 来设置</p>
<p>针对不同年龄段的对象分配原则如下所示：</p>
<ul>
<li><p>优先分配到 Eden </p>
</li>
<li><p>大对象直接分配到老年代</p>
<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>
<li><p>动态对象年龄判断</p>
<ul>
<li>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到  MaxTenuringThreshold 中要求的年龄。</li>
</ul>
</li>
<li><p>空间分配担保</p>
<ul>
<li> -XX: HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="为什么会有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么会有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么会有TLAB（Thread Local Allocation Buffer）？"></a>为什么会有TLAB（Thread Local Allocation Buffer）？</h3><ul>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li>
</ul>
<h3 id="什么是TLAB？"><a href="#什么是TLAB？" class="headerlink" title="什么是TLAB？"></a>什么是TLAB？</h3><ul>
<li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。</li>
<li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li>
<li>据我所知所有 OPEN JDK 衍生出来的 JVM 都提供了 TLAB 的设计。</li>
</ul>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103050211.png" alt="image-20210716103050211" style="zoom: 33%;">

<h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ul>
<li>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将TLAB 作为内存分配的首选</li>
<li>在程序中，开发人员可以通过选项“-XX: UseTLAB”设置是否开启TLAB 空间</li>
<li>默认情況下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，当然我们可以通过选项“-XX: TLABWasteTargetPercent”设置 TLAB 空间所占用 Eden 空间的百分比大小。</li>
<li>一旦对象在 TLAB 空间分配内存失败时，JWM 就会尝试着通过使用<strong>加锁机制</strong>确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</li>
</ul>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103615156.png" alt="image-20210716103615156" style="zoom: 33%;">

<h2 id="小结堆空间的参数设置"><a href="#小结堆空间的参数设置" class="headerlink" title="小结堆空间的参数设置"></a>小结堆空间的参数设置</h2><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103757241.png" alt="image-20210716103757241" style="zoom: 33%;">

<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103832545.png" alt="image-20210716103832545" style="zoom:33%;">

<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<ul>
<li><p>如果大于，则此次 Minor GC 是安全的</p>
</li>
<li><p>如果小于，则虚拟机会查看-XX: HandlePromotionFailure 设置值是否允许担保失败。</p>
<ul>
<li><p>如果 HandlePromotionFailure=true，那么会继续检査老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</p>
<ul>
<li><p>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的</p>
</li>
<li><p>如果小于，则改为进行一次 Full GC。</p>
</li>
</ul>
</li>
<li><p>如果 HandlePromotionFailure= false，则改为进行一次 Full GC</p>
</li>
</ul>
</li>
</ul>
<p>在 JDK6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>就会进行 Minor GC，否则将进行 Full G。</p>
<h2 id="堆是分配对象的唯一选择吗"><a href="#堆是分配对象的唯一选择吗" class="headerlink" title="堆是分配对象的唯一选择吗"></a>堆是分配对象的唯一选择吗</h2><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p>
<p>随着 Java 编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
<p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有种特殊情况，那就是如果经过<strong>逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
<p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBao VM，其中创新的 GCIH (GC  invisible heap）技术实现。off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p>
<h3 id="逃逸分析概述"><a href="#逃逸分析概述" class="headerlink" title="逃逸分析概述"></a>逃逸分析概述</h3><ul>
<li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p>
</li>
<li><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p>
</li>
<li><p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p>
</li>
<li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p>
</li>
</ul>
</li>
</ul>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105627607.png" alt="image-20210716105627607" style="zoom:33%;">

<ul>
<li>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</li>
</ul>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105736720.png" alt="image-20210716105736720" style="zoom:33%;">

<p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105829050.png" alt="image-20210716105829050" style="zoom:33%;">

<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716110045243.png" alt="image-20210716110045243" style="zoom:33%;">

<p><strong>参数设置</strong></p>
<p>在 JDK6u23 版本之后，Hotspot 中默认就已经开启了逃逸分析。如果使用的是较早的版本，开发人员则可以通过</p>
<ul>
<li>选项“-XX: + DoEscapeAnalysis“显式开启逃逸分析</li>
<li>通过选项“-XX:+ PrintEscapeAnalysis“看逃逸分析的筛选结果。</li>
</ul>
<p><strong>结论：</strong></p>
<p>开发中能使用局部变量的，就不要使用在方法外定义。</p>
<h3 id="逃逸分析：代码优化"><a href="#逃逸分析：代码优化" class="headerlink" title="逃逸分析：代码优化"></a>逃逸分析：代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ul>
<li><strong>栈上分配</strong>。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li>
<li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li>
<li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中</li>
</ul>
<h4 id="代码优化之栈上分配"><a href="#代码优化之栈上分配" class="headerlink" title="代码优化之栈上分配"></a>代码优化之栈上分配</h4><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成上分配。分配完成后，继续在调用内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p>
<p>常见的上分配的场景</p>
<ul>
<li>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ul>
<h4 id="代码优化之同步省略（消除）"><a href="#代码优化之同步省略（消除）" class="headerlink" title="代码优化之同步省略（消除）"></a>代码优化之同步省略（消除）</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能</p>
<p>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断<strong>同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<strong>锁消除</strong></p>
<p>如下代码：</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111230457.png" alt="image-20210716111230457" style="zoom:33%;">

<p>代码中对 hollis 这个对象进行加锁，但是 hollis 对象的生命周期只在 f（）方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉。优化成：</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111326098.png" alt="image-20210716111326098" style="zoom:33%;">

<h4 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h4><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p>
<p>相对的，那些还可以分解的数据叫做聚合量（Aggregate), Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
<p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JVM 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111609911.png" alt="image-20210716111609911" style="zoom:33%;">

<p>以上代码经过标量替换后，就会变成：</p>
<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111643799.png" alt="image-20210716111643799" style="zoom:33%;">

<p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为旦不需要创建对象了，那么就不再需要分配堆内存了</p>
<p>标量替换为栈上分配提供了很好的基础。</p>
<p><strong>标量替换参数设置</strong></p>
<p>参数 XX: +ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p>
<p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p>
<h3 id="逃逸分析小结：逃逸分析并不成熟"><a href="#逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="逃逸分析小结：逃逸分析并不成熟"></a>逃逸分析小结：逃逸分析并不成熟</h3><ul>
<li>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是无法<strong>保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取決于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li>
<li>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是， intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</li>
</ul>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>年轻代是对象的延生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
<p>老年代放置长生命周期的对象，通常都是从 Survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p>
<p>当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC。当 GC 发生在老年代时则被称为 Major GC 或者 Full GC。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>

    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    <i class="fa fa-qrcode fa-2x" style="line-height:35px;"></i>
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="superBaby 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="superBaby 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>superBaby
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liuermenghhh.github.io/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/" title="运行时数据区（本地方法栈&amp;堆）">https://liuermenghhh.github.io/2021/07/16/运行时数据区（本地方法栈-堆）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

    
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"># -JVM</i></a>
          </div>
    
        

    
        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" rel="prev" title="运行时数据区">
      <i class="fa fa-chevron-left"></i> 运行时数据区
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/" rel="next" title="方法区">
      方法区 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.</span> <span class="nav-text">本地方法接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">本地方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8NativeMethod"><span class="nav-number">1.2.</span> <span class="nav-text">为什么使用NativeMethod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%B0%E7%8A%B6"><span class="nav-number">1.3.</span> <span class="nav-text">现状</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E8%BF%B0"><span class="nav-number">3.1.</span> <span class="nav-text">堆的核心概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A0%86%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E4%B8%8EOOM"><span class="nav-number">3.2.</span> <span class="nav-text">设置堆内存大小与OOM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.3.</span> <span class="nav-text">年轻代与老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">3.4.</span> <span class="nav-text">图解对象分配过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">3.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minor-GC%E3%80%81Major-GC%E3%80%81Full-GC"><span class="nav-number">3.5.</span> <span class="nav-text">Minor GC、Major GC、Full GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E4%BB%A3%E5%BC%8FGC%E7%AD%96%E7%95%A5%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.5.1.</span> <span class="nav-text">最简单的分代式GC策略的触发条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E5%88%86%E4%BB%A3%E6%80%9D%E6%83%B3"><span class="nav-number">3.6.</span> <span class="nav-text">堆空间分代思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">3.7.</span> <span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%EF%BC%9ATLAB"><span class="nav-number">3.8.</span> <span class="nav-text">为对象分配内存：TLAB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89TLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89%EF%BC%9F"><span class="nav-number">3.8.1.</span> <span class="nav-text">为什么会有TLAB（Thread Local Allocation Buffer）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTLAB%EF%BC%9F"><span class="nav-number">3.8.2.</span> <span class="nav-text">什么是TLAB？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLAB%E5%86%8D%E8%AF%B4%E6%98%8E"><span class="nav-number">3.8.3.</span> <span class="nav-text">TLAB再说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.9.</span> <span class="nav-text">小结堆空间的参数设置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">3.9.1.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%98%AF%E5%88%86%E9%85%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%94%AF%E4%B8%80%E9%80%89%E6%8B%A9%E5%90%97"><span class="nav-number">3.10.</span> <span class="nav-text">堆是分配对象的唯一选择吗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E6%A6%82%E8%BF%B0"><span class="nav-number">3.10.1.</span> <span class="nav-text">逃逸分析概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">3.10.2.</span> <span class="nav-text">逃逸分析：代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="nav-number">3.10.2.1.</span> <span class="nav-text">代码优化之栈上分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%8C%E6%AD%A5%E7%9C%81%E7%95%A5%EF%BC%88%E6%B6%88%E9%99%A4%EF%BC%89"><span class="nav-number">3.10.2.2.</span> <span class="nav-text">代码优化之同步省略（消除）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E4%B9%8B%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">3.10.2.3.</span> <span class="nav-text">代码优化之标量替换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B0%8F%E7%BB%93%EF%BC%9A%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%B9%B6%E4%B8%8D%E6%88%90%E7%86%9F"><span class="nav-number">3.10.3.</span> <span class="nav-text">逃逸分析小结：逃逸分析并不成熟</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">3.11.</span> <span class="nav-text">本章小结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="superBaby"
      src="/images/iu.GIF">
  <p class="site-author-name" itemprop="name">superBaby</p>
  <div class="site-description" itemprop="description">记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liuermenghhh/liuermenghhh.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuermenghhh&#x2F;liuermenghhh.github.io" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1259492465@qq.com" title="E-Mail → mailto:1259492465@qq.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5323074186/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5323074186&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘二哈</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xPozfJb4WQSAlH28uAjlNdoR-gzGzoHsz',
      appKey     : 'HyKcWABd0XnOctis8UvdK2OM',
      placeholder: ":-)来啊，快活啊",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
