<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/game32*32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/game16*16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuermenghhh.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM中篇，垃圾回收--垃圾收集器 学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="垃圾回收4--垃圾收集器">
<meta property="og:url" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/index.html">
<meta property="og:site_name" content="刘二萌的博客">
<meta property="og:description" content="JVM中篇，垃圾回收--垃圾收集器 学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134835477.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134937554.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719140742374.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719140728605.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141411684.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141154320.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141842822.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719142731335.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719143505067.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719144355299.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719150339206.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719153149378.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719153350757.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719154518482.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719162621035.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719162730848.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163025803.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163129690.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163155895.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163216644.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163249376.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163308129.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163342675.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163356331.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163407254.png">
<meta property="article:published_time" content="2021-07-19T08:48:28.000Z">
<meta property="article:modified_time" content="2021-07-19T08:55:54.283Z">
<meta property="article:author" content="superBaby">
<meta property="article:tag" content="-JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134835477.png">

<link rel="canonical" href="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>垃圾回收4--垃圾收集器 | 刘二萌的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">刘二萌的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iu.GIF">
      <meta itemprop="name" content="superBaby">
      <meta itemprop="description" content="记录学习">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘二萌的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          垃圾回收4--垃圾收集器
        </h1>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              
    
              <time title="创建时间：2021-07-19 16:48:28 / 修改时间：16:55:54" itemprop="dateCreated datePublished" datetime="2021-07-19T16:48:28+08:00">2021-07-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">JVM学习</span></a>
                </span>
            </span>
    
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">JVM中篇，垃圾回收--垃圾收集器 学习笔记</div>
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
        <h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p>
<p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p>
<p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p>
<h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><ul>
<li><p>按<strong>线程数</strong>分，可以分为串行垃圾回收器和并行垃圾回收器</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134835477.png" alt="image-20210719134835477" style="zoom:50%;">

<ul>
<li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束</p>
<ul>
<li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Cient 模式下的 JVM 中</li>
</ul>
</li>
<li><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制</p>
</li>
</ul>
</li>
<li><p>按照<strong>工作模式</strong>分，可以分为并发式垃圾回收器和独占式垃圾回收器</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134937554.png" alt="image-20210719134937554" style="zoom:50%;">

<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
</li>
<li><p>按碎片片处理方式分</p>
<ul>
<li>压缩式垃圾回收器会在回收完后，对存活对象进行压缩整理，消除回收后的碎片</li>
<li>非压缩式的垃圾回收器不进行这步操作</li>
</ul>
</li>
<li><p>按工作的内存区间分</p>
<ul>
<li>年轻代垃圾收集器</li>
<li>老年代垃圾回收器</li>
</ul>
</li>
</ul>
<h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul>
<li><p>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间：程序运行时间+内存回收的时间）</p>
<ul>
<li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内STW时间最短</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719140742374.png" alt="image-20210719140742374" style="zoom:50%;"></li>
</ul>
</li>
<li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</p>
<ul>
<li><p>暂停时间优先，意味着让单次STW的时间最短</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719140728605.png" alt="image-20210719140728605" style="zoom:50%;"></li>
</ul>
</li>
<li><p>内存占用：Java堆区所占的内存大小</p>
</li>
</ul>
<p>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：吞吐量、暂停时间</p>
<ul>
<li><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
</li>
<li><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的 20 毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p>
</li>
<li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</p>
</li>
<li><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降</p>
</li>
</ul>
</li>
<li><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
</li>
<li><p>现在标准：在最大吞吐量优先的情况下，降低停顿时间。</p>
</li>
</ul>
<h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141411684.png" alt="image-20210719141411684" style="zoom:40%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141154320.png" alt="image-20210719141154320" style="zoom:50%;">

<p>（红色虚线）由于维护和兼容性测试的成本，在 JDK8 时将 Serial+CMS、ParNew+ Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（EP214），即：移除。</p>
<p>（绿色虚线） JDK14 中：弃用 Parallel Scavenge 和 Serial OldGC 组合（EP366)</p>
<p>（青色虚线）JDK14 中：删除 CMS 垃圾回收器（JEP363)</p>
<h3 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h3><ul>
<li><p>串行回收器</p>
<ul>
<li>Serial、Serial Old</li>
</ul>
</li>
<li><p>并行回收器</p>
<ul>
<li>ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
</li>
<li><p>并发回收器</p>
<ul>
<li>CMS、G1</li>
</ul>
</li>
</ul>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141842822.png" alt="image-20210719141842822" style="zoom: 39%;">

<h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><ul>
<li>-XX：+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：jinfo  -flag  相关垃圾回收器参数  进程ID</li>
</ul>
<h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p>
<p>Serial 收集器作为 Hotspot 中 Client 模式下的默认新生代垃圾收集器。</p>
<p>Serial 收集器采用<strong>复制算法、串行回收和“Stop-the-world”</strong>的方式执行内存回收。</p>
<p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的  Serial Old 收集器。SerialOld 收集器同样也采用了串行回收和“stop the World“机制，只不过内存回收算法使用的是<strong>标记一压缩</strong>算法。</p>
<ul>
<li><p>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器</p>
</li>
<li><p>Serial Old 在 Server 模式下主要有两个用途：①与新生代的 Parallel Scavenge 配合使用②作为老年代 CMS 收集器的后备垃圾收集方案</p>
</li>
</ul>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719142731335.png" alt="image-20210719142731335" style="zoom:50%;">

<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。</p>
<p><strong>优势</strong>：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<ul>
<li>运行在 Client 模式下的虚拟机是个不错的选择。</li>
</ul>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB）可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在 Hotspoth 虚拟机中，使用-XX: + UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。</p>
<ul>
<li>等价于新生代用 Seral GC，且老年代用 Serial Old GC</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu可以用。现在都不是单核的了</li>
<li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</li>
</ul>
<h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本</p>
<ul>
<li> Par 是 Parallel 的缩写，New：只能处理的是新生代</li>
</ul>
<p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、“Stop-the-Word“机制</p>
<p>ParNew 是很多 JVM运行在 Server模式下新生代的默认垃圾收集器。</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719143505067.png" alt="image-20210719143505067" style="zoom:50%;">

<ul>
<li><p>对于新生代，回收次数频繁，使用并行方式高效。</p>
</li>
<li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</p>
</li>
</ul>
<p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p>
<ul>
<li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销</li>
</ul>
<p>除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p>
<p>在程序中，开发人员可以通过选项“-XX: + UseParNewGC“手动指定使用  ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p>-XX: ParallelGCThreads 限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
<h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>Hotspot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和“stop  the World“机制</p>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在<strong>后台运算而不需要太多交互的</strong>任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
<p>Parallel Old 收集器采用了<strong>标记-压缩算法，但同样也是基于并行回收和 “stop-the- World“</strong>机制。</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719144355299.png" alt="image-20210719144355299" style="zoom:50%;">

<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。</p>
<p>在 Java8 中，默认是此垃圾收集器</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul>
<li><p>-XX: + UseParallelGC 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务</p>
</li>
<li><p>-XX: + UseParallelOldGC 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li><p>分别适用于新生代和老年代。认 jdk8 是开启的。</p>
</li>
<li><p>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</p>
</li>
</ul>
</li>
<li><p>-XX: ParallelGCThreads 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<ul>
<li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于CPU 数量。</li>
<li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于3+ [5* CPU_Count]/8。</li>
</ul>
</li>
<li><p>-XX: MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒</p>
<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallell, 进行控制</li>
<li><strong>该参数使用需谨慎</strong></li>
</ul>
</li>
<li><p>-XX: GCTimeRatio 垃圾收集时间占总时间的比例（=1/ (N+1））。用于衡量吞吐量的大小</p>
<ul>
<li>取值范围（0,100)。默认值 99, 也就是垃圾回收时间不超过 1%</li>
<li>与前一个-XX:MaxGCPauseMillis 参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例？？？？？？？？？？？？？？？？</li>
</ul>
</li>
<li><p>-XX: +UseaAdaptiveSizePolicy 设置 Parallel Scavenge 收集器具有<strong>自适应调节策略</strong></p>
<ul>
<li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatlo）和停顿时间(MaxGCPauseMillis），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
<h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent-Mark- Sweep）收集器，这款收集器是 Hotspot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延退）就越适合与用户交互的程序，良好的响应速度能提升用户体验</p>
<ul>
<li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验 CMS 收集器就非常符合这类应用的需求。</li>
</ul>
<p>CMS 的垃圾收集算法采用<strong>标记清除算法，并且也会“Stop-the- world“</strong></p>
<p>不幸的是<strong>，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</strong></p>
<p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719150339206.png" alt="image-20210719150339206" style="zoom:50%;">

<ul>
<li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出  GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>
<li>并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为<strong>了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li>
<li>并发清除（Concurrent- Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-Morld”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the World”，只是尽可能地缩短暂停时间。</p>
<p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无<strong>法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</strong></p>
<h3 id="有人会觉得既然Mark-Sweep会造成内存碎片，那为什么不换成Mark-Compact呢？"><a href="#有人会觉得既然Mark-Sweep会造成内存碎片，那为什么不换成Mark-Compact呢？" class="headerlink" title="有人会觉得既然Mark Sweep会造成内存碎片，那为什么不换成Mark Compact呢？"></a>有人会觉得既然Mark Sweep会造成内存碎片，那为什么不换成Mark Compact呢？</h3><ul>
<li>答案其实很简答，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？<strong>要保证用户线程能继续执行，前提的它运行的资源不受影响嘛</strong>。Mark Compact 更适合“Stop the World”这种场景下使用</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p>优点</p>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><ol>
<li>会产生<strong>内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。</li>
</ol>
</li>
<li><ol start="2">
<li>CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总<strong>吞吐量会降低</strong>。</li>
</ol>
</li>
<li><ol start="3">
<li>CMS 收集器无法处理<strong>浮动垃圾</strong>。可能出现“Concurrent Mode Failure“失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li><p>-XX: + UseConcMarkSweepGC 手动指定使用 CMS 收集器执行内存回收任务</p>
<ul>
<li>开启该参数后会自动将-XX: + UseParNewGC 打开。即：ParNew (Young 区用）+CMS (old 区用）+ Serial Old 的组合。</li>
</ul>
</li>
<li><p>-XX: CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，旦达到该阈值，便开始进行回收。</p>
<ul>
<li>JDK5 及以前版本的默认值为 68, 即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。JDK6 及以上版本默认值为 92%</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 FullGC 的执行次数。</li>
</ul>
</li>
<li><p>-XX: +UseCMSCompactAtFullCollection 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了</p>
</li>
<li><p>-XX: CMSFullGCsBeforeCompaction 设置在执行多少次 FullGC 后对内存空间进行压缩整理。</p>
</li>
<li><p>-XX: ParallelCMSThreads 设置 CMS 的线程数量。</p>
<ul>
<li>CMS 默认启动的线程数是 (ParallelGCThreads+3)/4,ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>Hotspot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？</p>
<ul>
<li>如果你想要最小化地使用内存和并行开销，请选 Serial GC</li>
<li>如果你想要最大化应用程序的吞吐量，请选 ParallelGC</li>
<li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li>
</ul>
</li>
</ul>
<h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><ul>
<li><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291)</p>
<ul>
<li>如果对JDK9 及以上版本的 Hotspot 虚拟机使用参数-XX:+ UseConcMarkSweepGC 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li>
</ul>
</li>
<li><p>JDK14 新特性：删除 CMS 垃圾回收器（EP363) </p>
<ul>
<li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用-XX: + UseConcMarkSweepGC的话，JVM 不会报错，只是给出一个  warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动JVM</li>
</ul>
</li>
</ul>
<h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><p>官方给 G1 设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的</strong>重任与期望。</p>
<h3 id="为什么名字叫做Garbage-First（G1）呢？"><a href="#为什么名字叫做Garbage-First（G1）呢？" class="headerlink" title="为什么名字叫做Garbage First（G1）呢？"></a>为什么名字叫做Garbage First（G1）呢？</h3><ul>
<li>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region)（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</li>
<li>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First)</li>
</ul>
<p>G1 (Garbage- First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在 JDK1.7 版本正式启用，移除了 Experimenta 的标识，是 JDK9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“全功能的垃圾收集器”。</p>
<p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用 -XX: +UseG1GC 来启用。</p>
<h3 id="G1回收器的特点（优势）"><a href="#G1回收器的特点（优势）" class="headerlink" title="G1回收器的特点（优势）"></a>G1回收器的特点（优势）</h3><ul>
<li><p>并行与并发</p>
<ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li>
<li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><p>分代收集</p>
<ul>
<li>从分代上看，G1 依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代</li>
</ul>
</li>
<li><p>空间整合</p>
<ul>
<li>CMS：“标记一清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理 </li>
<li>G1 将内存划分为一个个的 region。内存的回收是以 reglon作为基本单位的。Region 之间是复制算法，但整体上实际可看作是标记-压缩（Mak- Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li>
</ul>
</li>
<li><p>可预测的停顿时间模型（即：软实时soft real-time）</p>
<ul>
<li><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<ul>
<li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于 CMS GC, G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="G1回收器的缺点"><a href="#G1回收器的缺点" class="headerlink" title="G1回收器的缺点"></a>G1回收器的缺点</h3><ul>
<li>相较于 CMS, G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</li>
<li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1, 而 G1 在大内存应用上则发挥其优势。平衡点在6-8G 之间。</li>
</ul>
<h3 id="G1回收器的参数设置"><a href="#G1回收器的参数设置" class="headerlink" title="G1回收器的参数设置"></a>G1回收器的参数设置</h3><ul>
<li>-XX: +UseG1GC 手动指定使用 G1 收集器执行内存回收任务。</li>
<li>-XX: G1HeapRegionSize 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的1/2000。</li>
<li>-XX: MaxGCPauseMillis 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms</li>
<li>-XX: ParalleGCThread 设置 STW 工作线程数的值。最多设置为 8</li>
<li>-XX: ConcGCThreads 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li>
<li>-XX: InitiatingHeapOccupancyPercent 设置触发并发 GC 周期的 Java 堆占用率值。超过此值，就触发 GC。默认值是 45。</li>
</ul>
<h3 id="G1回收器的常见操作步骤"><a href="#G1回收器的常见操作步骤" class="headerlink" title="G1回收器的常见操作步骤"></a>G1回收器的常见操作步骤</h3><ul>
<li><p>G1 的设计原则就是简化 JWM 性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启 G1 垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
</li>
<li><p>G1中提供了<strong>三种垃圾回收模式：Young GC、Mixed GC和FullGC</strong>，在不同的条件下被触发。</p>
</li>
</ul>
<h3 id="G1回收器的适用场景"><a href="#G1回收器的适用场景" class="headerlink" title="G1回收器的适用场景"></a>G1回收器的适用场景</h3><ul>
<li><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
</li>
<li><p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；</p>
</li>
<li><p>如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；(G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p>
</li>
<li><p>用来替换掉 JDK1.5 中的 CMS 收集器</p>
<ul>
<li>在下面的情况时，使用 G1 可能比 CMS 好：</li>
<li>①超过 50%的Java 堆被活动数据占用</li>
<li>②对象分配频率或年代提升频率变化很大</li>
<li>③GC 停顿时间过长（长于 0.5 至 1 秒）</li>
</ul>
</li>
<li><p>Hotspot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的JVM 线程执行 GC 的多线程操作，而 G1  GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
</li>
</ul>
<h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><ul>
<li><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB,2MB,4MB,8MB,16MB,32MB。可以通过 -XX: G1HeapRegionSize 设定。<strong>所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</strong></p>
</li>
<li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719153149378.png" alt="image-20210719153149378" style="zoom:50%;"></li>
<li><p>一个 region 有可能属于 Eden, Survivor 或者 old/ Tenured 内存区域。但是个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O表示属于 old 内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 0.5 个 region，就放到 H。</p>
</li>
<li><p>设置H的原因</p>
<p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。如果一个 H 区装不下ー个大对象，那么 G1 会寻找连续的 H 区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p>
</li>
</ul>
<h3 id="G1回收器垃圾回收过程"><a href="#G1回收器垃圾回收过程" class="headerlink" title="G1回收器垃圾回收过程"></a>G1回收器垃圾回收过程</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719153350757.png" alt="image-20210719153350757" style="zoom:50%;">

<p>年轻代 GC (Young Gc)</p>
<p>老年代并发标记过程（Concurrent Marking)</p>
<p>混合回收（Mixed GC)</p>
<p>（如果需要，单线程、独占式、高强度的 Fu11GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</p>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul>
<li>应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始年轻代回收过程</strong>；G1 的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。</strong></li>
<li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同, 老年代的G1回收器和其他GC不同,<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region，是和年轻代一起被回收的。</li>
<li>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ul>
<h4 id="Remember-Set"><a href="#Remember-Set" class="headerlink" title="Remember Set"></a><strong>Remember Set</strong></h4><ul>
<li>一个对象被不同区域引用的问题</li>
<li>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</li>
<li>在其他的分代收集器，也存在这样的问题（而 G1 更突出）</li>
<li>回收新生代也不得不同时扫描老年代？</li>
<li>这样的话会降低 Minor GC 的效率；</li>
</ul>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul>
<li><p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：<strong>每个 Region 都有一个对应的 Remembered Set</strong></p>
</li>
<li><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检査老年代对象是否引用了新生代对象）;</p>
</li>
<li><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的  Remembered Set 中；</p>
</li>
<li><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719154518482.png" alt="image-20210719154518482" style="zoom:50%;"></li>
</ul>
<h4 id="回收过程1：年轻代GC"><a href="#回收过程1：年轻代GC" class="headerlink" title="回收过程1：年轻代GC"></a>回收过程1：年轻代GC</h4><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p>
<p>首先 G1 停止应用程序的执行（Stop-The-world), G1 创建回收集 (Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段</p>
<p>然后开始如下回收过程：</p>
<ul>
<li><p>第一阶段：扫描根</p>
<p>根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</p>
</li>
<li><p>第二阶段：更新RSet</p>
<p>处理 dirty card queue 中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</p>
<ul>
<li><p>对于应用程序的引用值语句 object field= object, JVM 会在之前和之后执行特殊的操作以在 dirty card queue 中入队一个保存了对象引用信息的 card。在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系</p>
</li>
<li><p>那为什么不在引用赋值语句处直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。</p>
</li>
</ul>
</li>
<li><p>第三阶段：处理RSet</p>
<p>识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p>
</li>
<li><p>第四阶段：复制对象</p>
<p>此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段， Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1, 达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</p>
</li>
<li><p>第五阶段：处理引用</p>
<p>处理 Soft, Weak, Phantom, Final, JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p>
</li>
</ul>
<h4 id="回收过程2-并发标记过程"><a href="#回收过程2-并发标记过程" class="headerlink" title="回收过程2:并发标记过程"></a>回收过程2:并发标记过程</h4><ol>
<li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段<strong>是 STW</strong> 的，并且会触发一次年轻代 GC。</li>
<li><strong>根区域扫描</strong>（Root Region Scanning): G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 young GC 之前完成。</li>
<li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 young GC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li><strong>再次标记</strong>（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 <strong>STW</strong> 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the- beginning (SATB）。</li>
<li><strong>独占清理</strong>（cleanup，STM）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。<pre><code>这个阶段并不会实际上去做垃圾的收集
</code></pre>
</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li>
</ol>
<h4 id="回收过程3-混合回收"><a href="#回收过程3-混合回收" class="headerlink" title="回收过程3:混合回收"></a>回收过程3:混合回收</h4><p>当越来越多的对象晋升到老年代 old  region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 old  Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC并不是 Full GC。</p>
<ul>
<li>并发标记结東以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过 -XX: G1MixedGCCountTarget 设置）被回收。</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX: G1MixedGCLiveThresholdPercent，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行 8 次。有一个阈值-XX: G1HeapWastePercent，默认值为 10% 意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</li>
</ul>
<h4 id="可选过程4-Full-GC"><a href="#可选过程4-Full-GC" class="headerlink" title="可选过程4:Full GC"></a>可选过程4:Full GC</h4><ul>
<li><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时会很长</p>
</li>
<li><p>要避免 FullGC 的发生，一旦发生需要进行调整。什么时候会发生 FullGC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 full gc，这种情况可以通过增大内存解决。</p>
</li>
<li><p>导致 G1Full GC 的原因可能有两个：</p>
<ul>
<li><p>Evacuation 的时候没有足够的 to-Space 来存放晋升的对象 </p>
</li>
<li><p>并发处理过程完成之前空间耗尽。</p>
</li>
</ul>
</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>从 Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回收一部分 Reglon，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h3 id="G1回收器优化建议"><a href="#G1回收器优化建议" class="headerlink" title="G1回收器优化建议"></a>G1回收器优化建议</h3><ul>
<li><p>年轻代大小</p>
<ul>
<li>避免使用-Xmn 或-XX: NewRatio 等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
</li>
<li><p>暂停时间目标不要太过严苛</p>
<ul>
<li>G1GC 的春吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li>
<li>评估 G1GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719162621035.png" alt="image-20210719162621035" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719162730848.png" alt="image-20210719162730848" style="zoom:50%;">

<h3 id="怎么选择垃圾回收器？"><a href="#怎么选择垃圾回收器？" class="headerlink" title="怎么选择垃圾回收器？"></a>怎么选择垃圾回收器？</h3><ul>
<li><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p>
</li>
<li><p>怎么选择垃圾收集器呢？</p>
<ul>
<li><ol>
<li>优先调整堆的大小让 JVM 自适应完成 </li>
</ol>
</li>
<li><ol start="2">
<li>如果内存小于 100M，使用串行收集器</li>
</ol>
</li>
<li><ol start="3">
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
</ol>
</li>
<li><ol start="4">
<li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</li>
</ol>
</li>
<li><ol start="5">
<li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器。官方推荐 G1, 性能高。现在互联网的项目，基本都是使用 G1。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ul>
<li><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。这里较通用、基础性的部分如下：</p>
<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</p>
</li>
</ul>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163025803.png" alt="image-20210719163025803" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163129690.png" alt="image-20210719163129690" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163155895.png" alt="image-20210719163155895" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163216644.png" alt="image-20210719163216644" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163249376.png" alt="image-20210719163249376" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163308129.png" alt="image-20210719163308129" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163342675.png" alt="image-20210719163342675" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163356331.png" alt="image-20210719163356331" style="zoom:50%;">

<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163407254.png" alt="image-20210719163407254" style="zoom:50%;">

<h3 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h3><ul>
<li>常用的日志分析工具：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat</li>
</ul>
<h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项 G1GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在Serverlessa 等新的应用场景下，SerialGC 找到了新的舞台。</p>
<p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 DK9 中已经被标记为废弃，并在JDK14 版本中移除。</p>
<h3 id="引入的两个新的收集器"><a href="#引入的两个新的收集器" class="headerlink" title="引入的两个新的收集器"></a>引入的两个新的收集器</h3><ul>
<li><p>ZGC（JDK11出现）</p>
<ul>
<li>ZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</li>
<li>《深入理解 Java 虚拟机》一书中这样定义 ZGC:ZGC 收集器是一款基于  Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记压缩算法的，以低延迟为首要目标的一款垃圾收集器。</li>
<li>ZGC 的工作过程可以分为 4 个阶段：并发标记一并发预备重分配一并发重分配-并发重映射等。</li>
<li>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</li>
</ul>
</li>
<li><p>Shenandoah（JDK12）</p>
<ul>
<li><p>主打特点：低停顿时间（实验性）</p>
<ul>
<li><p>Shenandoah，无疑是众多 GC 中最孤独的一个。是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的受到官方的排挤。比如号称 openJDK 和 oracleJDK 没有区别的 Oracle 公司仍拒绝在 oracleJDK12 中支持 Shenandoah。</p>
</li>
<li><p>Shenandoah 垃圾回收器最初由 Redhat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给OpenJDK。</p>
</li>
<li><p>Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB,99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
</li>
<li><p>总结</p>
<ul>
<li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降 </li>
<li>Shenandoah GC 的强项：低延迟时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    <i class="fa fa-qrcode fa-2x" style="line-height:35px;"></i>
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="superBaby 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="superBaby 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>superBaby
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liuermenghhh.github.io/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="垃圾回收4--垃圾收集器">https://liuermenghhh.github.io/2021/07/19/垃圾回收4-垃圾收集器/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

    
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"># -JVM</i></a>
          </div>
    
        

    
        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" rel="prev" title="垃圾回收3--相关概念">
      <i class="fa fa-chevron-left"></i> 垃圾回收3--相关概念
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.1.</span> <span class="nav-text">GC分类与性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">垃圾回收器分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%84%E4%BC%B0GC%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-number">1.1.2.</span> <span class="nav-text">评估GC的性能指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">不同的垃圾回收器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="nav-number">1.2.1.</span> <span class="nav-text">垃圾回收器发展史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">常见的垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E9%BB%98%E8%AE%A4%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">如何查看默认垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serial%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">1.3.</span> <span class="nav-text">Serial回收器：串行回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ParNew%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">1.4.</span> <span class="nav-text">ParNew回收器：并行回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallel%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-number">1.5.</span> <span class="nav-text">Parallel回收器：吞吐量优先</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.1.</span> <span class="nav-text">参数配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.6.</span> <span class="nav-text">CMS回收器：低延迟</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.6.1.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E4%BA%BA%E4%BC%9A%E8%A7%89%E5%BE%97%E6%97%A2%E7%84%B6Mark-Sweep%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%EF%BC%8C%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8D%A2%E6%88%90Mark-Compact%E5%91%A2%EF%BC%9F"><span class="nav-number">1.6.2.</span> <span class="nav-text">有人会觉得既然Mark Sweep会造成内存碎片，那为什么不换成Mark Compact呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.6.3.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.6.4.</span> <span class="nav-text">参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E5%90%8E%E7%BB%AD%E7%89%88%E6%9C%AC%E4%B8%ADCMS%E7%9A%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.6.6.</span> <span class="nav-text">JDK后续版本中CMS的变化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">G1回收器：区域化分代式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8D%E5%AD%97%E5%8F%AB%E5%81%9AGarbage-First%EF%BC%88G1%EF%BC%89%E5%91%A2%EF%BC%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">为什么名字叫做Garbage First（G1）呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E4%BC%98%E5%8A%BF%EF%BC%89"><span class="nav-number">1.7.2.</span> <span class="nav-text">G1回收器的特点（优势）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.7.3.</span> <span class="nav-text">G1回收器的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.7.4.</span> <span class="nav-text">G1回收器的参数设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.7.5.</span> <span class="nav-text">G1回收器的常见操作步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.7.6.</span> <span class="nav-text">G1回收器的适用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BARegion%EF%BC%9A%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="nav-number">1.7.7.</span> <span class="nav-text">分区Region：化整为零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.8.</span> <span class="nav-text">G1回收器垃圾回收过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.8.1.</span> <span class="nav-text">具体过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Remember-Set"><span class="nav-number">1.7.8.2.</span> <span class="nav-text">Remember Set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">1.7.8.2.1.</span> <span class="nav-text">解决办法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B1%EF%BC%9A%E5%B9%B4%E8%BD%BB%E4%BB%A3GC"><span class="nav-number">1.7.8.3.</span> <span class="nav-text">回收过程1：年轻代GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B2-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.8.4.</span> <span class="nav-text">回收过程2:并发标记过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B3-%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="nav-number">1.7.8.5.</span> <span class="nav-text">回收过程3:混合回收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E8%BF%87%E7%A8%8B4-Full-GC"><span class="nav-number">1.7.8.6.</span> <span class="nav-text">可选过程4:Full GC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.7.8.7.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.7.9.</span> <span class="nav-text">G1回收器优化建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="nav-number">1.8.</span> <span class="nav-text">垃圾回收器总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="nav-number">1.8.1.</span> <span class="nav-text">怎么选择垃圾回收器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95"><span class="nav-number">1.8.2.</span> <span class="nav-text">面试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-number">1.9.</span> <span class="nav-text">GC日志分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="nav-number">1.9.1.</span> <span class="nav-text">GC 日志分析工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%96%B0%E5%8F%91%E5%B1%95"><span class="nav-number">1.10.</span> <span class="nav-text">垃圾回收器的新发展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B0%E7%9A%84%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.10.1.</span> <span class="nav-text">引入的两个新的收集器</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="superBaby"
      src="/images/iu.GIF">
  <p class="site-author-name" itemprop="name">superBaby</p>
  <div class="site-description" itemprop="description">记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liuermenghhh/liuermenghhh.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuermenghhh&#x2F;liuermenghhh.github.io" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1259492465@qq.com" title="E-Mail → mailto:1259492465@qq.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5323074186/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5323074186&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘二哈</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xPozfJb4WQSAlH28uAjlNdoR-gzGzoHsz',
      appKey     : 'HyKcWABd0XnOctis8UvdK2OM',
      placeholder: ":-)来啊，快活啊",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
