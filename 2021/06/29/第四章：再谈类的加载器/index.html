<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/game32*32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/game16*16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuermenghhh.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM中篇，第四章再谈类的加载器学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="第四章：再谈类的加载器">
<meta property="og:url" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/index.html">
<meta property="og:site_name" content="刘二萌的博客">
<meta property="og:description" content="JVM中篇，第四章再谈类的加载器学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194021203.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194649610.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627203246891.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204027345.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204324564.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628144346523.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150519826.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150910750-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150946026-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628160124899-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628161157283-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628162015161-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163159255-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163255917-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163339056-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163441756-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628184815857-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185218382-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185505425-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104356777-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104427185-4935529.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104449171-4935529.png">
<meta property="article:published_time" content="2021-06-29T02:48:49.000Z">
<meta property="article:modified_time" content="2021-06-29T03:02:42.290Z">
<meta property="article:author" content="superBaby">
<meta property="article:tag" content="-JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194021203.png">

<link rel="canonical" href="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第四章：再谈类的加载器 | 刘二萌的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">刘二萌的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iu.GIF">
      <meta itemprop="name" content="superBaby">
      <meta itemprop="description" content="记录学习">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘二萌的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第四章：再谈类的加载器
        </h1>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              
    
              <time title="创建时间：2021-06-29 10:48:49 / 修改时间：11:02:42" itemprop="dateCreated datePublished" datetime="2021-06-29T10:48:49+08:00">2021-06-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">JVM学习</span></a>
                </span>
            </span>
    
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">JVM中篇，第四章再谈类的加载器学习笔记</div>
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
        <h2 id="01-概述"><a href="#01-概述" class="headerlink" title="01-概述"></a>01-概述</h2><p>类加载器是JVM执行类加载机制的前提。</p>
<p><strong>ClassLoader的作用：</strong></p>
<p>Class Loader 是Java的核心组件，所有的 Class 都是由 Classloader 进行加载的，Classloader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang. Class 对象实例。然后交给Java 虚拟机进行链接、初始化等操作。因此，Classloader 在整个装载阶段，只能影响到类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为。至于它是否可以运行，则由 Execution Engine 决定。</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194021203.png" alt="image-20210627194021203" style="zoom:33%;">

<p>类加载器最早出现在Java1.0 版本中，那个时候只是单纯地为了满足Java Applet 应用而被研发出来。但如今类加载器却在 OSGi、字节码加解密领域大放异彩。这主要归功于Java 虚拟机的设计者们当初在设计挙加载器的时候，并没有考虑将它绑定在内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p>
<h3 id="1-大厂面试题"><a href="#1-大厂面试题" class="headerlink" title="1-大厂面试题"></a>1-大厂面试题</h3><p>蚂蚁金服：</p>
<p>深入分析 Classloader，双亲委派机制</p>
<p>类加载器的双亲委派模型是什么？</p>
<p>一面：双亲委派机制及使用原因</p>
<p>百度：</p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？</p>
<p>手写一个类加载器 Demo</p>
<p>Class 的 forname (“java.lang. String“）和 Class 的 getClassLoader（）的 loadClass (“java.1ang. String“）有什么区别？</p>
<p>腾讯：</p>
<p>什么是双亲委派模型？</p>
<p>类加载器有哪些？</p>
<p>小米</p>
<p>双亲委派模型介绍一下</p>
<p>滴滴：</p>
<p>简单说说你了解的类加载器</p>
<p>一面：讲一下双亲委派模型，以及其优点</p>
<p>字节跳动</p>
<p>什么是类加载器，类加载器有哪些？</p>
<p>京东</p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么</p>
<h3 id="2-类的加载分类"><a href="#2-类的加载分类" class="headerlink" title="2-类的加载分类"></a>2-类的加载分类</h3><p><strong>显示加载VS隐示加载</strong></p>
<p>Class 文件的显式加载与隐式加载的方式是指 JVM 加载 class 文件到内存的方式。</p>
<p><strong>显式加载</strong>指的是在代码中通过调用 ClassLoader 加载 class 对象，如直接使用 <code>Class. forName (name）</code>或 <code>this.GetClass().GetClassLoader().loadClass()</code>加载 class 对象。</p>
<p><strong>隐式加载</strong>则是不直接在代码中调用 Classloader 的方法加载 class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 class 文件时，该类的 class 文件中引用了另外一个类的对象，此时额外引用的类将通过JVM 自动加载到内存中。</p>
<p>在日常开发以上两种方式一般会混合使用。</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194649610.png" alt="image-20210627194649610" style="zoom: 25%;">

<h3 id="3-类加载器的必要性"><a href="#3-类加载器的必要性" class="headerlink" title="3-类加载器的必要性"></a>3-类加载器的必要性</h3><p>一般情況下，java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到 java.lang. ClassNotFoundException 异常或 java.lang. NoClassDeffoundError 异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h3 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4-命名空间"></a>4-命名空间</h3><ol>
<li>何为类的唯一性？</li>
</ol>
<p>对于任意一个类，都需要由加载<strong>它的类加载器和这个类本身</strong>一同确认其在Java 虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p>
<ol>
<li>命名空间</li>
</ol>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h3 id="5-类加载机制的基本特征"><a href="#5-类加载机制的基本特征" class="headerlink" title="5-类加载机制的基本特征"></a>5-类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p>
<ul>
<li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK 内部的 ServiceProvider/ ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>
<h3 id="6-类加载器之间的关系"><a href="#6-类加载器之间的关系" class="headerlink" title="6-类加载器之间的关系"></a>6-类加载器之间的关系</h3><p><strong>Launcher.java类：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Launcher.ExtClassLoader var1;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError( <span class="string">&quot;Could not create extension class loader&quot;</span> , var10);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span> .loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError( <span class="string">&quot;Could not create application class loader&quot;</span> , var9);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Thread.currentThread().setContextClassLoader( <span class="keyword">this</span> .loader); </span><br><span class="line"></span><br><span class="line">         …… </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>分析： </p>
<p><strong>1、验证扩展类加载器的父类是null</strong> </p>
<p>先看：</p>
<p> <code>var1 = Launcher.ExtClassLoader.getExtClassLoader();</code> </p>
<p>获取到扩展类加载器，点击该方法往里面追溯，在找到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Launcher.ExtClassLoader(var0);</span><br></pre></td></tr></table></figure>

<p>我们在点击该方法往里面追溯，在找到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super (getExtURLs(var1), (ClassLoader) null , Launcher.factory);</span><br></pre></td></tr></table></figure>

<p>然后点击super，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="params"><span class="function">            URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure>

<p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure>

<p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> ( checkCreateClassLoader (), parent);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>点击其中的parent就是null，我们点击this，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> . parent = parent; </span><br></pre></td></tr></table></figure>

<p>由于parent就是null，所以扩展类加载器的父类是null ，也就是引导类加载器，因此我们调用获取扩展类加载器父类的方法获得的结果是null</p>
<p> <strong>2、验证系统类加载器的父类是扩展类加载器</strong> </p>
<p>先看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> .loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br></pre></td></tr></table></figure>

<p>获取到系统类加载器，点击该方法往里面追溯，在找到：</p>
<p> <code>return new Launcher.AppClassLoader(var1x, var0);</code>  </p>
<p>其中var0就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">   <span class="keyword">super</span> (var1, var2, Launcher.factory);</span><br><span class="line">   <span class="keyword">this</span> .ucp.initLookupCache( <span class="keyword">this</span> );</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="params"><span class="function">            URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure>

<p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure>

<p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> ( checkCreateClassLoader (), parent);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<p>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> . parent = parent; </span><br></pre></td></tr></table></figure>

<p>由于parent就是扩展类加载器，所以系统类加载器的父类是扩展类加载器 ，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</p>
<p><strong>3、当前线程上下文的ClassLoader就是系统类加载器</strong> </p>
<p><code>Thread.currentThread().setContextClassLoader(this.loader)</code> 就是将系统类加载器设置为当前线程的上下文加载器，所以<code>Thread.currentThread().getContextClassLoader()</code> 获取到的就是系统类加载器</p>
<h2 id="02-复习"><a href="#02-复习" class="headerlink" title="02-复习"></a>02-复习</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-defined Classloader)</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 Classloader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627203246891.png" alt="image-20210627203246891" style="zoom:33%;">

<p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</p>
<p>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</p>
<p>下面的代码解释了包含的关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">// 父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">// parent=new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h3 id="1-引导类加载器"><a href="#1-引导类加载器" class="headerlink" title="1-引导类加载器"></a>1-引导类加载器</h3><ul>
<li>这个类加载使用C/C++语言实现的,嵌套在JVM内部</li>
<li>它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容)。用于提供JVM 自身需要的类。</li>
<li>并不继承自 java.lang.Classloader，没有父加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为 java、javax、sun 头的类</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
</ul>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204027345.png" alt="image-20210627204027345" style="zoom:33%;">

<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204324564.png" alt="image-20210627204324564" style="zoom:33%;">

<p>使用-XX:+TraceClassLoading参数得到。</p>
<p>启动类加载器使用C++编写的？yes！</p>
<ul>
<li>C/C++指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java：由 C++演变而来，(C++) –版，单继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;*******启动类加载器********&quot;</span>);</span><br><span class="line">    URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">    <span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">        System.out.println(urL.toExternalForm());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*******启动类加载器********</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/classes</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassLoader classLoader=java.security.Provider.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2-扩展类加载器"></a>2-扩展类加载器</h3><ul>
<li>Java 语言编写，由sun.misc. Launcher$ExtClassLoader 实现。</li>
<li>继承于 Classloader 类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库,或从]DK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR 放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png" alt="image-20210627205013180" style="zoom: 50%;">



<h3 id="3-系统类加载器"><a href="#3-系统类加载器" class="headerlink" title="3-系统类加载器"></a>3-系统类加载器</h3><ul>
<li>Java 语言编写，由 sun.misc. Launcher$AppClassLoader 实现</li>
<li>继承于 Classloader 类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 classpath 或系统属性java.class.path 指定路径下的类库应用程序中的类加载器默认是系统类加载器。它是用户自定义类加载器的默认父加载器</li>
<li>通过 Classloader 的 getsystemClassloader（）方法可以获取到该类加载器</li>
</ul>
<h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4-用户自定义类加载器"></a>4-用户自定义类加载器</h3><ul>
<li>在Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR 包，也可以是网络上的远程资源。</li>
<li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的 OSGI 组件框架，再如  Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，自定义加载器能够实现应用隔离，例如 Tomcat, Spring 等中间件和组件框架都在内部实现了自定义的加载器,并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改 C/C++程序就能为其新功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。自定义类加载器通常需要继承于 Classloader。</li>
</ul>
<h2 id="03-测试不同的类的加载器"><a href="#03-测试不同的类的加载器" class="headerlink" title="03-测试不同的类的加载器"></a>03-测试不同的类的加载器</h2><p>每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用。</p>
<p>获取 ClassLoader 的途径</p>
<p>获得当前类的 Classloade：<code>clazz. GetClassLoader ()</code></p>
<p>获得当前线程上下文的 ClassLoader:<code>Thread.currenThread (). GetContextClassLoader ()</code></p>
<p>获得系统的 Classloader: <code>ClassLoader.GetSystemClassLoader ()</code></p>
<p><strong>说明：</strong></p>
<p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用 C++语言编写而成的，而另外两种类加载器则是使用 Java 语言编写而成的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值。</p>
<p>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 <code>Class. GetClassLoader()</code>返回的，<strong>与数组当中元素类型的类加器</strong>是一样的：如果数<strong>组当中的元素类型是基本数据类型，数组类是没有类加载器的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@511d50c0</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line">            ClassLoader currentClassLoader = Class.forName(<span class="string">&quot;com.liuermeng.jvm.chapter04.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(currentClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">            <span class="comment">// 关于数组类型的加载:使用的类的加载器与数组元素的加载器相同</span></span><br><span class="line">            String[] arrStr=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null</span></span><br><span class="line">            ClassLoaderTest1[] arrClt=<span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrClt.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] arri=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arri.getClass().getClassLoader());<span class="comment">//null 基本数据类型，不需要类的加载器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="04-ClassLoader源码解析"><a href="#04-ClassLoader源码解析" class="headerlink" title="04-ClassLoader源码解析"></a>04-ClassLoader源码解析</h2><p><strong>ClassLoader与现有类加载器的关系：</strong></p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628144346523.png" alt="image-20210628144346523" style="zoom:33%;">

<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h3 id="1-ClassLoader的主要方法"><a href="#1-ClassLoader的主要方法" class="headerlink" title="1-ClassLoader的主要方法"></a>1-ClassLoader的主要方法</h3><p><strong>抽象类ClassLoader的主要方法：（内部没有抽象方法）</strong></p>
<p><code>public final ClassLoader getParent()</code> 返回该类加载器的超类加载器</p>
<p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code> 加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。该方法中的逻辑就是<strong>双亲委派模式</strong>的实现。</p>
<p><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code> 查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被 loadClass（）方法调用。</p>
<ul>
<li>在 JDK1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类。但是在 JDK1.2 之后已不再建议用户去覆盖 loadClass（）方法，而是建议把自定义的类加载逻辑写在  findClass（）方法中，从前面的分析可知findClass（）方法是在 loadClass（）方法中被调用的，当loadClass（）方法中父加载器加载失败后，则会调用自己的 findClass（）方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li>
<li>需要注意的是 ClassLoader 类中并没有实现 findClass（）方法的具体代码逻辑，取而代之的是抛出Classnotfoundexception 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法起使用的。一般情况下，在自定义类加载器时，会直接覆盖 Classloader 的 findClass方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defingClass（）方法生成类的Class对象。</li>
</ul>
<p><code>Protected final Class&lt;?&gt; defineClass(String name, byte[] b,int off,int len)</code> 根据给定的字节数组 b 转换为 class 的实例，off 千和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 Classloader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用。</p>
<ul>
<li>defineClass（）方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中已实现该方法逻辑），通过这个方法不仅能够通过 class 文件实例化 class对象，也可以通过其他方式实例化 class 对象，如通过络收一个类的字节码，然后转换 byte 字节流创建对应的 Class 对象。</li>
<li>defineClass（）方法通常与 findClass（）方法一起使用，一般情況下，在自定义类加载器时，会直接覆盖Classloader 的 findClass（）方法并编写加载规则，取得要加載类的字节码后转换成流，然后调用 defineclass（）方法生成类的 Class 对象</li>
</ul>
<p><code>protected final void resolveClass(Class&lt;?&gt; c)</code> 链接指定的一个Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>  查找名称为 name 的己经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改。</p>
<p><code>private final ClassLoader parent</code>  它也是一个 Classloader 的实例，这个字段所表示的 Classloader 也称为这个 Classloader 的双亲。在类加载的过程中，Classloader 可能会将某些请求交予自己的双亲处理</p>
<p><strong>loadClass()剖析</strong></p>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.liuermeng.User&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>涉及到如下方法的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">// resolve：true-加载class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// 首先，在缓存中判断是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果未加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// parent为null：父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; <span class="comment">// 当前类的加载器的父类加载器未加载此类</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findClass（）</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">// 是否进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SecureClassLoader与URLClassLoader"><a href="#2-SecureClassLoader与URLClassLoader" class="headerlink" title="2-SecureClassLoader与URLClassLoader"></a>2-SecureClassLoader与URLClassLoader</h3><p>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对 class 源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联。</p>
<p>前面说过，Classloader 是一个抽象类，很多方法是空的没有实现，比如 findClass（）、findResource（）等。而 URLClassLoader 这个实现类为这些方法提供了具体的实现。并新増了 URLClassPath 类协助取得 Class 字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findcass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png" alt="image-20210627205013180" style="zoom:50%;">

<h3 id="3-ExtClassLoader与AppClassLaoder"><a href="#3-ExtClassLoader与AppClassLaoder" class="headerlink" title="3-ExtClassLoader与AppClassLaoder"></a>3-ExtClassLoader与AppClassLaoder</h3><p>了解完 URLClassLoader 后接着看看剩余的两个类加载器，即拓展类加载器 ExtClassLoader 和系统类加载器  AppClassLoader，这两个类都继承自 URLClassLoader, 是sun.misc. Launcher 的静态内部类。 sun.misc. Launcher 主要被系统用于启动主应用程序，ExtClassLoader 和 AppClassLoader都是由 sun.misc. Launcher 创建的，其类主要类结构如下：</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150519826.png" alt="image-20210628150519826" style="zoom:50%;">

<p>ExtClassLoader 并没有重写 loadClass（）方法，这足矣说明其遵循双亲委派模式，而 AppClassLoader 重载了 loadClass（）方法，但最终调用的还是父类 loadClass（）方法，因此依然遵守双亲委派模式。</p>
<h3 id="4-Class-forName-与ClassLoader-loadClass"><a href="#4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4-Class.forName()与ClassLoader.loadClass()"></a>4-Class.forName()与ClassLoader.loadClass()</h3><p>Class.forName ()：是一个静态方法，最常用的是 Class.forName (String className）；根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。如：Class.forName (“com.liuermeng.Helloworld”)</p>
<p>ClassLoader.loadClass ()：这是一个实例方法，需要一个 CLassLoader 对象来调用该方法。该方法将Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。如：Classloader c1=……;  c1.loadClass (“com.liuermeng.Helloworld”);</p>
<h2 id="05-双亲委派机制"><a href="#05-双亲委派机制" class="headerlink" title="05-双亲委派机制"></a>05-双亲委派机制</h2><h3 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1-定义与本质"></a>1-定义与本质</h3><p>类加载器用来把类加载到Java 虚拟机中。从 JDK1.2 版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证 Java 平台的安全。</p>
<ol>
<li><strong>定义</strong></li>
</ol>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<ol start="2">
<li><strong>本质</strong></li>
</ol>
<p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，オ会由系统类加载器或自定义的类加载器进行加载。</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150910750-4935529.png" alt="image-20210628150910750" style="zoom:33%;">

<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150946026-4935529.png" alt="image-20210628150946026" style="zoom: 33%;">

<h3 id="2-优势与劣势"><a href="#2-优势与劣势" class="headerlink" title="2-优势与劣势"></a>2-优势与劣势</h3><ol>
<li><strong>双亲委派机制优势</strong></li>
</ol>
<ul>
<li><p>避免类的重复加载，确保一个类的全局唯一性</p>
<p>Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 Classloader 再加载一次。</p>
</li>
<li><p>保护程序安全，防止核心 API 被随意改</p>
</li>
</ul>
<ol start="2">
<li><strong>代码支持</strong></li>
</ol>
<p>双亲委派机制在 java.lang.Classloader.loadClass (String, boolean）接口中体现。该接口的逻辑如下：</p>
<p> (1) 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p>
<p> (2) 判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass (name, false）接口进行加载。</p>
<p> (3) 反之，如果当前加载器的父类加载器为空，则调用 findBootStrapClassOrNul (name）接口，让引导类加载器进行加载。</p>
<p> (4) 如果通过以上 3 条路径都没能成功加载，则调用 findClass (name）接口进行加载。该接口最终会调用 java.lang.Classloader 接口的 defineClass 系列的 native 接口加载目标Java 类。双亲委派的模型就隐藏在这第 2 和第 3 步中。</p>
<ol start="3">
<li><strong>举例</strong></li>
</ol>
<p>假设当前加载的是 java.lang.Object 这个类，很显然，该类属于JDK 中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载 java.lang.Object 时，JVM 默认会使用系统类加载器去加载，按照上面 4 步加载的逻辑，在第 1 步从系统类的缓存中肯定查找不到该类，于是进入第 2 步。由于系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第 1 步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第 2 步。扩展类的父加载器是 null, 因此系统调用 findclass (String），最终通过引导类加载器进行加载。</p>
<ol start="4">
<li><strong>思考</strong></li>
</ol>
<p>如果在自定义的类加载器中重写 java.lang.Classloader.loadClass (String）或java.lang.ClassLoader.loadClass (String, boolean）方法，抹去其中的双亲委派机制，仅保留上面这 4 步中的第 1 步与第 4 步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为JDK 还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.Classloader.defineClass (string, byte [], int, int,Protectiondomain）方法，而该方法会执行 preDefineClass（）接口，该接口中提供了对JDK 核心类库的保护。</p>
<ol start="5">
<li><strong>双亲委托模式的弊端</strong></li>
</ol>
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个 Classloader 的职责非常明确，但是同时会带来一个问题，即顶层的 Classloader 无法访问底层的 CLassloader 所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口该接口需要在应用类中得以实现，该接口述绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<ol start="6">
<li><strong>结论</strong></li>
</ol>
<p>由于Java 虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。</p>
<p>比如在 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet 规范推荐的一种做法。</p>
<h3 id="3-破坏双亲委派机制"><a href="#3-破坏双亲委派机制" class="headerlink" title="3-破坏双亲委派机制"></a>3-破坏双亲委派机制</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>双亲委派模型并不是一个具有强制性约的模型，而是Java 设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java 的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java 模块化出现为止，双亲委派模型主要出现过 3 次较大规模“被破坏”的情况。</p>
<h4 id="破坏双亲委派机制1"><a href="#破坏双亲委派机制1" class="headerlink" title="破坏双亲委派机制1"></a>破坏双亲委派机制1</h4><p>第一次破坏双亲委派机制：</p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一即JDK1.2 面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.Classloader 则在Java 的第1个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免 loadClass（）被子类覆盖的可能性，只能在JDK1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findclass (），并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass（）中编写代码。上节我们已经分析过 loadClass（）方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass（）方法的逻辑，如果父类加载失败，会自动调用自己的 findcass（）方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h4 id="破坏双亲委派机制2"><a href="#破坏双亲委派机制2" class="headerlink" title="破坏双亲委派机制2"></a>破坏双亲委派机制2</h4><p>第二次破坏双亲委派机制：线程上下文类加载器</p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码那该怎么办呢？</p>
<p>这并非是不可能出现的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是Java 的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3 时加入到 rt.jar 的），肯定属于Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 Classpath 下的 JNDI 服务提供者接口（Service Provider Interface, SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ (SPI：在Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI)</p>
<p>为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context Classloader）</strong>。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在 JDK6 时，JDK 提供了 java.Util. ServiceLoader 类，以 META-INF/services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案。</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628160124899-4935529.png" alt="image-20210628160124899" style="zoom:33%;">

<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<h4 id="破坏双亲委派机制3"><a href="#破坏双亲委派机制3" class="headerlink" title="破坏双亲委派机制3"></a>破坏双亲委派机制3</h4><p>第三次破坏双亲委派机制：</p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：<strong>代码热替换（Hot Swap）、模块热部署（Hot Deployment）</strong>等</p>
<p>IBM 公司主导的JSR-291（即 OSGi R4.2) 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p>
<p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p>
<p>*<em>1) 将以 java. <em>开头的类，委派给父类加载器加载。</em></em></p>
<p><strong>2) 否则，将委派列表名单内的类，委派给父类加载器加载。</strong></p>
<ol start="3">
<li><p>否则，将 Import 列表中的类，委派给 Export。这个类的 Bundle 的类加载器加载。</p>
</li>
<li><p>否则，查找当前 Bundle 的 Classpath，使用自己的类加载器加载。</p>
</li>
<li><p>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</p>
</li>
<li><p>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</p>
</li>
<li><p>否则，类查找失败。</p>
</li>
</ol>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结：</p>
<p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<strong>这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p>
<p>正如：OSGi 中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为 OSGI 中对类加载器的运用是值得学习的，完全弄懂了 OSGi 的实现，就算是掌握了类加载器的精粹</p>
<h3 id="4-热替换的实现"><a href="#4-热替换的实现" class="headerlink" title="4-热替换的实现"></a>4-热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了 PHP 源文件，这种改动就会立即生效，而无需重启 Web 服务器。</p>
<p>但对Java 来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加并重定义这个类。因此，在Java 中实现这一功能的一个可行的方法就是灵活运用 Classloader。</p>
<p>注意：由不同 Classloader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 Classloader 加载同个类，在虚拟机内部，会认为这 2 个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628161157283-4935529.png" alt="image-20210628161157283" style="zoom: 25%;">



<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628162015161-4935529.png" alt="image-20210628162015161" style="zoom: 20%;">

<h2 id="06-沙箱安全机制"><a href="#06-沙箱安全机制" class="headerlink" title="06-沙箱安全机制"></a>06-沙箱安全机制</h2><h3 id="1-JDK1-0时期"><a href="#1-JDK1-0时期" class="headerlink" title="1-JDK1.0时期"></a>1-JDK1.0时期</h3><p>在Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱（Sandbox）机制。如下图所示 JDK1.0 安全模型</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163159255-4935529.png" alt="image-20210628163159255" style="zoom: 25%;">

<h3 id="2-JDK1-1时期"><a href="#2-JDK1-1时期" class="headerlink" title="2-JDK1.1时期"></a>2-JDK1.1时期</h3><p>JDK1.0 中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的 Java1.1 版本中，针对安全机制做了改进，増加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<p>如下图所示JDK1.1 安全模型</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163255917-4935529.png" alt="image-20210628163255917" style="zoom:25%;">

<h3 id="3-JDK1-2时期"><a href="#3-JDK1-2时期" class="headerlink" title="3-JDK1.2时期"></a>3-JDK1.2时期</h3><p>在Java1.2 版本中，再次改进了安全机制，増加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 JDK1.2 安全模型</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163339056-4935529.png" alt="image-20210628163339056" style="zoom:25%;">

<h3 id="4-JDK1-6时期"><a href="#4-JDK1-6时期" class="headerlink" title="4-JDK1.6时期"></a>4-JDK1.6时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6)</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163441756-4935529.png" alt="image-20210628163441756" style="zoom:25%;">

<h2 id="07-自定义类的加载器"><a href="#07-自定义类的加载器" class="headerlink" title="07-自定义类的加载器"></a>07-自定义类的加载器</h2><ol>
<li><strong>为什么要自定义类加载器</strong>？</li>
</ol>
<ul>
<li>隔离加载类</li>
</ul>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。</p>
<ul>
<li>修改类加载的方式</li>
</ul>
<p>类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p>
<ul>
<li>扩展加载源</li>
</ul>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
<ul>
<li>防止源码泄漏</li>
</ul>
<p>Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
<ol start="2">
<li><strong>常见的场景</strong></li>
</ol>
<ul>
<li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE 和 OSGi、JPMS 等框架。</p>
</li>
<li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码动态修改或者生成类型。</p>
</li>
</ul>
<ol start="3">
<li><strong>注意</strong>：</li>
</ol>
<p>在一般情下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java 类型转换，则加载器反而容易产生不美好的事情。在做Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol>
<li><strong>实现方式</strong></li>
</ol>
<ul>
<li><p>Java 提供了抽象类 java.lang. Classloader，所有用户自定义的类加载器都应该继承 Classloader 类。</p>
</li>
<li><p>在自定义 Classloader 的子类时候，我们常见的会有两种做法：</p>
<ul>
<li><p>方式一：重写 loadClass（）方法</p>
</li>
<li><p>方式二：重写 findClass（）方法–&gt;推荐</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>对比</strong></li>
</ol>
<p>这两种方法本质上差不多，毕竟 loadClass（）也会调用 findClass (），但是从逻辑上讲我们最好不要直接修改 loadClass（）的内部逻辑。建议的做法是只在 findClass（）里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用。</p>
<ul>
<li><p>loadClass（）这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass（）方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p>
</li>
<li><p>当编写好自定义类加载器后，便可以在程序中调用 loadClass（）方法来实现类加载操作。</p>
</li>
</ul>
<ol start="3">
<li><strong>说明</strong></li>
</ol>
<ul>
<li><p>其父类加载器是系统类加载器</p>
</li>
<li><p>JVM中的所有类加载都会使用 java.lang.ClassLoader.loadClass (String）接口（自定义类加载器并重写java.lang.ClassLoader.loadClass (String）接口的除外），连 JDK 的核心类库也不能例外。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName=byteCodePath+className+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bos= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len=bis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(data,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] byteCodes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; aClass = defineClass(<span class="keyword">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader loader=<span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/Users/liumeng/Desktop/&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz= loader.loadClass(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类加载器为&quot;</span>+clazz.getClassLoader().getClass().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类加载器的父类加载器为&quot;</span>+clazz.getClassLoader().getParent().getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载此类的类加载器为com.liuermeng.jvm.classloader.MyClassLoader</span><br><span class="line">加载此类的类加载器的父类加载器为sun.misc.Launcher$AppClassLoader//我们并没有定义父类加载器，默认为系统类加载器</span><br></pre></td></tr></table></figure>



<h2 id="08-Java9新特性"><a href="#08-Java9新特性" class="headerlink" title="08-Java9新特性"></a>08-Java9新特性</h2><p>为了保证兼容性，JDK9 没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platformClassLoader）。可以通过 Classloaderl的新方法 getPlatformClassLoader（）来获取。</li>
</ol>
<p>JDK9 基于模块化进行构建 (原来的rt.jar和 tools.jar 被拆分成数十个 JMOD 文件）,其中的Java 类库就已天然地满足了可扩展的需求，那自然无须再保留<code>&lt;JAVA_HOME&gt; \liib\ext</code>目录, 此前使用这个 目录或者 java.ext.dirs 系统变量来扩展JDK 功能的机制已经没有继续存在的价值了</p>
<ol start="2">
<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</li>
</ol>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk. internall.loader.BuiltinClassLoader。</p>
 <img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628184815857-4935529.png" alt="image-20210628184815857" style="zoom:33%;">

<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185218382-4935529.png" alt="image-20210628185218382" style="zoom:33%;">

<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassloader 类的特定方法，那代码很可能会在 JDK9 及更高版本的 JDK 中崩溃。</p>
<ol start="3">
<li><p>在Java9 中，类加载器有了名称。该名称在构造方法中指定，可以通过 getName（）方法来获取。平台类加载器的名称是 platform，应用类加载器的名称是 app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p>
</li>
<li><p>启动类加载器现在是在 jvm 内部和 java 类库共同协作实现的类加载器（以前是c++实现），但为了与之前代码兼容在获取启动类加载器的场景中然会返回 null， 而不会得到 BootClassLoader 实例。</p>
</li>
<li><p>类加载的委派关系也发生了变动。</p>
</li>
</ol>
<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p>
<p>双亲委派模式示意图</p>
<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185505425-4935529.png" alt="image-20210628185505425" style="zoom: 25%;">

<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104356777-4935529.png" alt="image-20210629104356777" style="zoom: 50%;">

<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104427185-4935529.png" alt="image-20210629104427185" style="zoom:50%;">

<img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104449171-4935529.png" alt="image-20210629104449171" style="zoom:50%;">


    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    <i class="fa fa-qrcode fa-2x" style="line-height:35px;"></i>
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="superBaby 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="superBaby 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>superBaby
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liuermenghhh.github.io/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" title="第四章：再谈类的加载器">https://liuermenghhh.github.io/2021/06/29/第四章：再谈类的加载器/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

    
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"># -JVM</i></a>
          </div>
    
        

    
        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/" rel="prev" title="字节码指令集与解析举例">
      <i class="fa fa-chevron-left"></i> 字节码指令集与解析举例
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" rel="next" title="运行时数据区">
      运行时数据区 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">01-概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.1.</span> <span class="nav-text">1-大厂面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%88%86%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">2-类的加载分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">3-类加载器的必要性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.4.</span> <span class="nav-text">4-命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="nav-number">1.5.</span> <span class="nav-text">5-类加载机制的基本特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.6.</span> <span class="nav-text">6-类加载器之间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-%E5%A4%8D%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">02-复习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%BC%95%E5%AF%BC%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">1-引导类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2-扩展类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">3-系统类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">4-用户自定义类加载器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#03-%E6%B5%8B%E8%AF%95%E4%B8%8D%E5%90%8C%E7%9A%84%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">03-测试不同的类的加载器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#04-ClassLoader%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">04-ClassLoader源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ClassLoader%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">1-ClassLoader的主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-SecureClassLoader%E4%B8%8EURLClassLoader"><span class="nav-number">4.2.</span> <span class="nav-text">2-SecureClassLoader与URLClassLoader</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ExtClassLoader%E4%B8%8EAppClassLaoder"><span class="nav-number">4.3.</span> <span class="nav-text">3-ExtClassLoader与AppClassLaoder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Class-forName-%E4%B8%8EClassLoader-loadClass"><span class="nav-number">4.4.</span> <span class="nav-text">4-Class.forName()与ClassLoader.loadClass()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#05-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">05-双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AC%E8%B4%A8"><span class="nav-number">5.1.</span> <span class="nav-text">1-定义与本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-number">5.2.</span> <span class="nav-text">2-优势与劣势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">5.3.</span> <span class="nav-text">3-破坏双亲委派机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">5.3.1.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B61"><span class="nav-number">5.3.2.</span> <span class="nav-text">破坏双亲委派机制1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B62"><span class="nav-number">5.3.3.</span> <span class="nav-text">破坏双亲委派机制2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B63"><span class="nav-number">5.3.4.</span> <span class="nav-text">破坏双亲委派机制3</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%83%AD%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.</span> <span class="nav-text">4-热替换的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#06-%E6%B2%99%E7%AE%B1%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">06-沙箱安全机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-JDK1-0%E6%97%B6%E6%9C%9F"><span class="nav-number">6.1.</span> <span class="nav-text">1-JDK1.0时期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JDK1-1%E6%97%B6%E6%9C%9F"><span class="nav-number">6.2.</span> <span class="nav-text">2-JDK1.1时期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JDK1-2%E6%97%B6%E6%9C%9F"><span class="nav-number">6.3.</span> <span class="nav-text">3-JDK1.2时期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-JDK1-6%E6%97%B6%E6%9C%9F"><span class="nav-number">6.4.</span> <span class="nav-text">4-JDK1.6时期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#07-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">7.</span> <span class="nav-text">07-自定义类的加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">7.1.</span> <span class="nav-text">实现方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#08-Java9%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">8.</span> <span class="nav-text">08-Java9新特性</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="superBaby"
      src="/images/iu.GIF">
  <p class="site-author-name" itemprop="name">superBaby</p>
  <div class="site-description" itemprop="description">记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liuermenghhh/liuermenghhh.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuermenghhh&#x2F;liuermenghhh.github.io" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1259492465@qq.com" title="E-Mail → mailto:1259492465@qq.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5323074186/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5323074186&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘二哈</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xPozfJb4WQSAlH28uAjlNdoR-gzGzoHsz',
      appKey     : 'HyKcWABd0XnOctis8UvdK2OM',
      placeholder: ":-)来啊，快活啊",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
