<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>垃圾回收4--垃圾收集器</title>
      <link href="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC分类与性能指标"><a href="#GC分类与性能指标" class="headerlink" title="GC分类与性能指标"></a>GC分类与性能指标</h2><p>垃圾收集器有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><ul><li><p>按<strong>线程数</strong>分，可以分为串行垃圾回收器和并行垃圾回收器</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134835477.png" alt="image-20210719134835477" style="zoom:50%;"><ul><li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束</p><ul><li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的 Cient 模式下的 JVM 中</li></ul></li><li><p>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制</p></li></ul></li><li><p>按照<strong>工作模式</strong>分，可以分为并发式垃圾回收器和独占式垃圾回收器</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719134937554.png" alt="image-20210719134937554" style="zoom:50%;"><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul></li><li><p>按碎片片处理方式分</p><ul><li>压缩式垃圾回收器会在回收完后，对存活对象进行压缩整理，消除回收后的碎片</li><li>非压缩式的垃圾回收器不进行这步操作</li></ul></li><li><p>按工作的内存区间分</p><ul><li>年轻代垃圾收集器</li><li>老年代垃圾回收器</li></ul></li></ul><h3 id="评估GC的性能指标"><a href="#评估GC的性能指标" class="headerlink" title="评估GC的性能指标"></a>评估GC的性能指标</h3><ul><li><p>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间：程序运行时间+内存回收的时间）</p><ul><li><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p></li><li><p>吞吐量优先，意味着在单位时间内STW时间最短</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719140742374.png" alt="image-20210719140742374" style="zoom:50%;"></li></ul></li><li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</p><ul><li><p>暂停时间优先，意味着让单次STW的时间最短</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719140728605.png" alt="image-20210719140728605" style="zoom:50%;"></li></ul></li><li><p>内存占用：Java堆区所占的内存大小</p></li></ul><p>这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p>简单来说，主要抓住两点：吞吐量、暂停时间</p><ul><li><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p></li><li><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的 20 毫秒暂停都可能打断终端用户体验。因此，具有低的较大暂停时间是非常重要的，特别是对于一个交互式应用程序。</p></li><li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</p></li><li><p>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降</p></li></ul></li><li><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p></li><li><p>现在标准：在最大吞吐量优先的情况下，降低停顿时间。</p></li></ul><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><h3 id="垃圾回收器发展史"><a href="#垃圾回收器发展史" class="headerlink" title="垃圾回收器发展史"></a>垃圾回收器发展史</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141411684.png" alt="image-20210719141411684" style="zoom:40%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141154320.png" alt="image-20210719141154320" style="zoom:50%;"><p>（红色虚线）由于维护和兼容性测试的成本，在 JDK8 时将 Serial+CMS、ParNew+ Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（EP214），即：移除。</p><p>（绿色虚线） JDK14 中：弃用 Parallel Scavenge 和 Serial OldGC 组合（EP366)</p><p>（青色虚线）JDK14 中：删除 CMS 垃圾回收器（JEP363)</p><h3 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h3><ul><li><p>串行回收器</p><ul><li>Serial、Serial Old</li></ul></li><li><p>并行回收器</p><ul><li>ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li><p>并发回收器</p><ul><li>CMS、G1</li></ul></li></ul><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719141842822.png" alt="image-20210719141842822" style="zoom: 39%;"><h3 id="如何查看默认垃圾收集器"><a href="#如何查看默认垃圾收集器" class="headerlink" title="如何查看默认垃圾收集器"></a>如何查看默认垃圾收集器</h3><ul><li>-XX：+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令：jinfo  -flag  相关垃圾回收器参数  进程ID</li></ul><h2 id="Serial回收器：串行回收"><a href="#Serial回收器：串行回收" class="headerlink" title="Serial回收器：串行回收"></a>Serial回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 Hotspot 中 Client 模式下的默认新生代垃圾收集器。</p><p>Serial 收集器采用<strong>复制算法、串行回收和“Stop-the-world”</strong>的方式执行内存回收。</p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的  Serial Old 收集器。SerialOld 收集器同样也采用了串行回收和“stop the World“机制，只不过内存回收算法使用的是<strong>标记一压缩</strong>算法。</p><ul><li><p>Serial Old 是运行在 Client 模式下默认的老年代的垃圾回收器</p></li><li><p>Serial Old 在 Server 模式下主要有两个用途：①与新生代的 Parallel Scavenge 配合使用②作为老年代 CMS 收集器的后备垃圾收集方案</p></li></ul><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719142731335.png" alt="image-20210719142731335" style="zoom:50%;"><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）。</p><p><strong>优势</strong>：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p><ul><li>运行在 Client 模式下的虚拟机是个不错的选择。</li></ul><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB）可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在 Hotspoth 虚拟机中，使用-XX: + UseSerialGC 参数可以指定年轻代和老年代都使用串行收集器。</p><ul><li>等价于新生代用 Seral GC，且老年代用 Serial Old GC</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu可以用。现在都不是单核的了</li><li>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</li></ul><h2 id="ParNew回收器：并行回收"><a href="#ParNew回收器：并行回收" class="headerlink" title="ParNew回收器：并行回收"></a>ParNew回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本</p><ul><li> Par 是 Parallel 的缩写，New：只能处理的是新生代</li></ul><p>ParNew 收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用复制算法、“Stop-the-Word“机制</p><p>ParNew 是很多 JVM运行在 Server模式下新生代的默认垃圾收集器。</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719143505067.png" alt="image-20210719143505067" style="zoom:50%;"><ul><li><p>对于新生代，回收次数频繁，使用并行方式高效。</p></li><li><p>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</p></li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 Serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销</li></ul><p>除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p><p>在程序中，开发人员可以通过选项“-XX: + UseParNewGC“手动指定使用  ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p>-XX: ParallelGCThreads 限制线程数量，默认开启和 CPU 数据相同的线程数。</p><h2 id="Parallel回收器：吞吐量优先"><a href="#Parallel回收器：吞吐量优先" class="headerlink" title="Parallel回收器：吞吐量优先"></a>Parallel回收器：吞吐量优先</h2><p>Hotspot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了复制算法、并行回收和“stop  the World“机制</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，Parallel Scavenge 收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在<strong>后台运算而不需要太多交互的</strong>任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p><p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<strong>标记-压缩算法，但同样也是基于并行回收和 “stop-the- World“</strong>机制。</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719144355299.png" alt="image-20210719144355299" style="zoom:50%;"><p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。</p><p>在 Java8 中，默认是此垃圾收集器</p><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><ul><li><p>-XX: + UseParallelGC 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务</p></li><li><p>-XX: + UseParallelOldGC 手动指定老年代都是使用并行回收收集器。</p><ul><li><p>分别适用于新生代和老年代。认 jdk8 是开启的。</p></li><li><p>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</p></li></ul></li><li><p>-XX: ParallelGCThreads 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><ul><li>在默认情况下，当 CPU 数量小于 8 个，ParallelGCThreads 的值等于CPU 数量。</li><li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于3+ [5* CPU_Count]/8。</li></ul></li><li><p>-XX: MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即 STW 的时间）。单位是毫秒</p><ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallell, 进行控制</li><li><strong>该参数使用需谨慎</strong></li></ul></li><li><p>-XX: GCTimeRatio 垃圾收集时间占总时间的比例（=1/ (N+1））。用于衡量吞吐量的大小</p><ul><li>取值范围（0,100)。默认值 99, 也就是垃圾回收时间不超过 1%</li><li>与前一个-XX:MaxGCPauseMillis 参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例？？？？？？？？？？？？？？？？</li></ul></li><li><p>-XX: +UseaAdaptiveSizePolicy 设置 Parallel Scavenge 收集器具有<strong>自适应调节策略</strong></p><ul><li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatlo）和停顿时间(MaxGCPauseMillis），让虚拟机自己完成调优工作。</li></ul></li></ul><h2 id="CMS回收器：低延迟"><a href="#CMS回收器：低延迟" class="headerlink" title="CMS回收器：低延迟"></a>CMS回收器：低延迟</h2><p>在JDK1.5 时期，Hotspot 推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS (Concurrent-Mark- Sweep）收集器，这款收集器是 Hotspot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延退）就越适合与用户交互的程序，良好的响应速度能提升用户体验</p><ul><li>目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验 CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用<strong>标记清除算法，并且也会“Stop-the- world“</strong></p><p>不幸的是<strong>，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</strong></p><p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719150339206.png" alt="image-20210719150339206" style="zoom:50%;"><ul><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“stop-the-world”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出  GC Roots 能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li>并发标记（Concurrent-Mark）阶段：从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为<strong>了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除（Concurrent- Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-Morld”机制暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the World”，只是尽可能地缩短暂停时间。</p><p>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>另外，由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会产生一些内存碎片。那么 CMS 在为新对象分配内存空间时，将无<strong>法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</strong></p><h3 id="有人会觉得既然Mark-Sweep会造成内存碎片，那为什么不换成Mark-Compact呢？"><a href="#有人会觉得既然Mark-Sweep会造成内存碎片，那为什么不换成Mark-Compact呢？" class="headerlink" title="有人会觉得既然Mark Sweep会造成内存碎片，那为什么不换成Mark Compact呢？"></a>有人会觉得既然Mark Sweep会造成内存碎片，那为什么不换成Mark Compact呢？</h3><ul><li>答案其实很简答，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？<strong>要保证用户线程能继续执行，前提的它运行的资源不受影响嘛</strong>。Mark Compact 更适合“Stop the World”这种场景下使用</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p>优点</p><ul><li>并发收集</li><li>低延迟</li></ul></li><li><p>缺点</p><ul><li><ol><li>会产生<strong>内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC。</li></ol></li><li><ol start="2"><li>CMS 收集器对 CPU 资源非常敏感。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总<strong>吞吐量会降低</strong>。</li></ol></li><li><ol start="3"><li>CMS 收集器无法处理<strong>浮动垃圾</strong>。可能出现“Concurrent Mode Failure“失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ol></li></ul></li></ul><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li><p>-XX: + UseConcMarkSweepGC 手动指定使用 CMS 收集器执行内存回收任务</p><ul><li>开启该参数后会自动将-XX: + UseParNewGC 打开。即：ParNew (Young 区用）+CMS (old 区用）+ Serial Old 的组合。</li></ul></li><li><p>-XX: CMSInitiatingOccupanyFraction 设置堆内存使用率的阈值，旦达到该阈值，便开始进行回收。</p><ul><li>JDK5 及以前版本的默认值为 68, 即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。JDK6 及以上版本默认值为 92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 FullGC 的执行次数。</li></ul></li><li><p>-XX: +UseCMSCompactAtFullCollection 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了</p></li><li><p>-XX: CMSFullGCsBeforeCompaction 设置在执行多少次 FullGC 后对内存空间进行压缩整理。</p></li><li><p>-XX: ParallelCMSThreads 设置 CMS 的线程数量。</p><ul><li>CMS 默认启动的线程数是 (ParallelGCThreads+3)/4,ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>Hotspot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC 有什么不同呢？</p><ul><li>如果你想要最小化地使用内存和并行开销，请选 Serial GC</li><li>如果你想要最大化应用程序的吞吐量，请选 ParallelGC</li><li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li></ul></li></ul><h3 id="JDK后续版本中CMS的变化"><a href="#JDK后续版本中CMS的变化" class="headerlink" title="JDK后续版本中CMS的变化"></a>JDK后续版本中CMS的变化</h3><ul><li><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291)</p><ul><li>如果对JDK9 及以上版本的 Hotspot 虚拟机使用参数-XX:+ UseConcMarkSweepGC 来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li></ul></li><li><p>JDK14 新特性：删除 CMS 垃圾回收器（EP363) </p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用-XX: + UseConcMarkSweepGC的话，JVM 不会报错，只是给出一个  warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动JVM</li></ul></li></ul><h2 id="G1回收器：区域化分代式"><a href="#G1回收器：区域化分代式" class="headerlink" title="G1回收器：区域化分代式"></a>G1回收器：区域化分代式</h2><p>官方给 G1 设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的</strong>重任与期望。</p><h3 id="为什么名字叫做Garbage-First（G1）呢？"><a href="#为什么名字叫做Garbage-First（G1）呢？" class="headerlink" title="为什么名字叫做Garbage First（G1）呢？"></a>为什么名字叫做Garbage First（G1）呢？</h3><ul><li>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region)（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</li><li>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First)</li></ul><p>G1 (Garbage- First）是一款面向服务端应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK1.7 版本正式启用，移除了 Experimenta 的标识，是 JDK9 以后的默认垃圾回收器，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“全功能的垃圾收集器”。</p><p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用 -XX: +UseG1GC 来启用。</p><h3 id="G1回收器的特点（优势）"><a href="#G1回收器的特点（优势）" class="headerlink" title="G1回收器的特点（优势）"></a>G1回收器的特点（优势）</h3><ul><li><p>并行与并发</p><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li><p>分代收集</p><ul><li>从分代上看，G1 依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代</li></ul></li><li><p>空间整合</p><ul><li>CMS：“标记一清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理 </li><li>G1 将内存划分为一个个的 region。内存的回收是以 reglon作为基本单位的。Region 之间是复制算法，但整体上实际可看作是标记-压缩（Mak- Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul></li><li><p>可预测的停顿时间模型（即：软实时soft real-time）</p><ul><li><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><ul><li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于 CMS GC, G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li></ul></li></ul></li></ul><h3 id="G1回收器的缺点"><a href="#G1回收器的缺点" class="headerlink" title="G1回收器的缺点"></a>G1回收器的缺点</h3><ul><li>相较于 CMS, G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</li><li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1, 而 G1 在大内存应用上则发挥其优势。平衡点在6-8G 之间。</li></ul><h3 id="G1回收器的参数设置"><a href="#G1回收器的参数设置" class="headerlink" title="G1回收器的参数设置"></a>G1回收器的参数设置</h3><ul><li>-XX: +UseG1GC 手动指定使用 G1 收集器执行内存回收任务。</li><li>-XX: G1HeapRegionSize 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的1/2000。</li><li>-XX: MaxGCPauseMillis 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms</li><li>-XX: ParalleGCThread 设置 STW 工作线程数的值。最多设置为 8</li><li>-XX: ConcGCThreads 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li>-XX: InitiatingHeapOccupancyPercent 设置触发并发 GC 周期的 Java 堆占用率值。超过此值，就触发 GC。默认值是 45。</li></ul><h3 id="G1回收器的常见操作步骤"><a href="#G1回收器的常见操作步骤" class="headerlink" title="G1回收器的常见操作步骤"></a>G1回收器的常见操作步骤</h3><ul><li><p>G1 的设计原则就是简化 JWM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul></li><li><p>G1中提供了<strong>三种垃圾回收模式：Young GC、Mixed GC和FullGC</strong>，在不同的条件下被触发。</p></li></ul><h3 id="G1回收器的适用场景"><a href="#G1回收器的适用场景" class="headerlink" title="G1回收器的适用场景"></a>G1回收器的适用场景</h3><ul><li><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p></li><li><p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；</p></li><li><p>如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；(G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p></li><li><p>用来替换掉 JDK1.5 中的 CMS 收集器</p><ul><li>在下面的情况时，使用 G1 可能比 CMS 好：</li><li>①超过 50%的Java 堆被活动数据占用</li><li>②对象分配频率或年代提升频率变化很大</li><li>③GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul></li><li><p>Hotspot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的JVM 线程执行 GC 的多线程操作，而 G1  GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p></li></ul><h3 id="分区Region：化整为零"><a href="#分区Region：化整为零" class="headerlink" title="分区Region：化整为零"></a>分区Region：化整为零</h3><ul><li><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB,2MB,4MB,8MB,16MB,32MB。可以通过 -XX: G1HeapRegionSize 设定。<strong>所有的 Region 大小相同，且在 JVM 生命周期内不会被改变。</strong></p></li><li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719153149378.png" alt="image-20210719153149378" style="zoom:50%;"></li><li><p>一个 region 有可能属于 Eden, Survivor 或者 old/ Tenured 内存区域。但是个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 Survivor 内存区域，O表示属于 old 内存区域。图中空白的表示未使用的内存空间。</p></li><li><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 0.5 个 region，就放到 H。</p></li><li><p>设置H的原因</p><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。如果一个 H 区装不下ー个大对象，那么 G1 会寻找连续的 H 区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p></li></ul><h3 id="G1回收器垃圾回收过程"><a href="#G1回收器垃圾回收过程" class="headerlink" title="G1回收器垃圾回收过程"></a>G1回收器垃圾回收过程</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719153350757.png" alt="image-20210719153350757" style="zoom:50%;"><p>年轻代 GC (Young Gc)</p><p>老年代并发标记过程（Concurrent Marking)</p><p>混合回收（Mixed GC)</p><p>（如果需要，单线程、独占式、高强度的 Fu11GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。）</p><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ul><li>应用程序分配内存，<strong>当年轻代的 Eden 区用尽时开始年轻代回收过程</strong>；G1 的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及。</strong></li><li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</li><li>标记完成马上开始混合回收过程。对于一个混合回收期，G1GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同, 老年代的G1回收器和其他GC不同,<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收小部分老年代的 Region 就可以了</strong>。同时，这个老年代 Region，是和年轻代一起被回收的。</li><li>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li></ul><h4 id="Remember-Set"><a href="#Remember-Set" class="headerlink" title="Remember Set"></a><strong>Remember Set</strong></h4><ul><li>一个对象被不同区域引用的问题</li><li>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而 G1 更突出）</li><li>回收新生代也不得不同时扫描老年代？</li><li>这样的话会降低 Minor GC 的效率；</li></ul><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ul><li><p>无论 G1 还是其他分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描：<strong>每个 Region 都有一个对应的 Remembered Set</strong></p></li><li><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检査老年代对象是否引用了新生代对象）;</p></li><li><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的  Remembered Set 中；</p></li><li><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719154518482.png" alt="image-20210719154518482" style="zoom:50%;"></li></ul><h4 id="回收过程1：年轻代GC"><a href="#回收过程1：年轻代GC" class="headerlink" title="回收过程1：年轻代GC"></a>回收过程1：年轻代GC</h4><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p><p>首先 G1 停止应用程序的执行（Stop-The-world), G1 创建回收集 (Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段</p><p>然后开始如下回收过程：</p><ul><li><p>第一阶段：扫描根</p><p>根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</p></li><li><p>第二阶段：更新RSet</p><p>处理 dirty card queue 中的 card，更新 RSet。此阶段完成后，RSet 可以准确的反映老年代对所在的内存分段中对象的引用。</p><ul><li><p>对于应用程序的引用值语句 object field= object, JVM 会在之前和之后执行特殊的操作以在 dirty card queue 中入队一个保存了对象引用信息的 card。在年轻代回收的时候，G1 会对 Dirty Card Queue 中所有的 card 进行处理，以更新 RSet，保证 RSet 实时准确的反映引用关系</p></li><li><p>那为什么不在引用赋值语句处直接更新 RSet 呢？这是为了性能的需要，RSet 的处理需要线程同步，开销会很大，使用队列性能会好很多。</p></li></ul></li><li><p>第三阶段：处理RSet</p><p>识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</p></li><li><p>第四阶段：复制对象</p><p>此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段， Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1, 达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</p></li><li><p>第五阶段：处理引用</p><p>处理 Soft, Weak, Phantom, Final, JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ul><h4 id="回收过程2-并发标记过程"><a href="#回收过程2-并发标记过程" class="headerlink" title="回收过程2:并发标记过程"></a>回收过程2:并发标记过程</h4><ol><li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段<strong>是 STW</strong> 的，并且会触发一次年轻代 GC。</li><li><strong>根区域扫描</strong>（Root Region Scanning): G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 young GC 之前完成。</li><li><strong>并发标记</strong>（Concurrent Marking）：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 young GC 中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><strong>再次标记</strong>（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是 <strong>STW</strong> 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the- beginning (SATB）。</li><li><strong>独占清理</strong>（cleanup，STM）：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。<pre><code>这个阶段并不会实际上去做垃圾的收集</code></pre></li><li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li></ol><h4 id="回收过程3-混合回收"><a href="#回收过程3-混合回收" class="headerlink" title="回收过程3:混合回收"></a>回收过程3:混合回收</h4><p>当越来越多的对象晋升到老年代 old  region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些 old  Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC并不是 Full GC。</p><ul><li>并发标记结東以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过 -XX: G1MixedGCCountTarget 设置）被回收。</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX: G1MixedGCLiveThresholdPercent，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行 8 次。有一个阈值-XX: G1HeapWastePercent，默认值为 10% 意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</li></ul><h4 id="可选过程4-Full-GC"><a href="#可选过程4-Full-GC" class="headerlink" title="可选过程4:Full GC"></a>可选过程4:Full GC</h4><ul><li><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时会很长</p></li><li><p>要避免 FullGC 的发生，一旦发生需要进行调整。什么时候会发生 FullGC 呢？比如堆内存太小，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 full gc，这种情况可以通过增大内存解决。</p></li><li><p>导致 G1Full GC 的原因可能有两个：</p><ul><li><p>Evacuation 的时候没有足够的 to-Space 来存放晋升的对象 </p></li><li><p>并发处理过程完成之前空间耗尽。</p></li></ul></li></ul><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>从 Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回收一部分 Reglon，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h3 id="G1回收器优化建议"><a href="#G1回收器优化建议" class="headerlink" title="G1回收器优化建议"></a>G1回收器优化建议</h3><ul><li><p>年轻代大小</p><ul><li>避免使用-Xmn 或-XX: NewRatio 等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ul></li><li><p>暂停时间目标不要太过严苛</p><ul><li>G1GC 的春吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li><li>评估 G1GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ul><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719162621035.png" alt="image-20210719162621035" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719162730848.png" alt="image-20210719162730848" style="zoom:50%;"><h3 id="怎么选择垃圾回收器？"><a href="#怎么选择垃圾回收器？" class="headerlink" title="怎么选择垃圾回收器？"></a>怎么选择垃圾回收器？</h3><ul><li><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p></li><li><p>怎么选择垃圾收集器呢？</p><ul><li><ol><li>优先调整堆的大小让 JVM 自适应完成 </li></ol></li><li><ol start="2"><li>如果内存小于 100M，使用串行收集器</li></ol></li><li><ol start="3"><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li></ol></li><li><ol start="4"><li>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</li></ol></li><li><ol start="5"><li>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器。官方推荐 G1, 性能高。现在互联网的项目，基本都是使用 G1。</li></ol></li></ul></li></ul><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><ul><li><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。这里较通用、基础性的部分如下：</p><ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul></li><li><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数。</p></li></ul><h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163025803.png" alt="image-20210719163025803" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163129690.png" alt="image-20210719163129690" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163155895.png" alt="image-20210719163155895" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163216644.png" alt="image-20210719163216644" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163249376.png" alt="image-20210719163249376" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163308129.png" alt="image-20210719163308129" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163342675.png" alt="image-20210719163342675" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163356331.png" alt="image-20210719163356331" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B64-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/image-20210719163407254.png" alt="image-20210719163407254" style="zoom:50%;"><h3 id="GC-日志分析工具"><a href="#GC-日志分析工具" class="headerlink" title="GC 日志分析工具"></a>GC 日志分析工具</h3><ul><li>常用的日志分析工具：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat</li></ul><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项 G1GC 在不断的进行改进，很多我们原来认为的缺点，例如串行的 Full GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Full GC 已经是并行运行，在很多场景下，其表现还略优于 Parallel GC 的并行 Full GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在Serverlessa 等新的应用场景下，SerialGC 找到了新的舞台。</p><p>比较不幸的是 CMS GC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 DK9 中已经被标记为废弃，并在JDK14 版本中移除。</p><h3 id="引入的两个新的收集器"><a href="#引入的两个新的收集器" class="headerlink" title="引入的两个新的收集器"></a>引入的两个新的收集器</h3><ul><li><p>ZGC（JDK11出现）</p><ul><li>ZGC 与 Shenandoah 目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</li><li>《深入理解 Java 虚拟机》一书中这样定义 ZGC:ZGC 收集器是一款基于  Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记压缩算法的，以低延迟为首要目标的一款垃圾收集器。</li><li>ZGC 的工作过程可以分为 4 个阶段：并发标记一并发预备重分配一并发重分配-并发重映射等。</li><li>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</li></ul></li><li><p>Shenandoah（JDK12）</p><ul><li><p>主打特点：低停顿时间（实验性）</p><ul><li><p>Shenandoah，无疑是众多 GC 中最孤独的一个。是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的受到官方的排挤。比如号称 openJDK 和 oracleJDK 没有区别的 Oracle 公司仍拒绝在 oracleJDK12 中支持 Shenandoah。</p></li><li><p>Shenandoah 垃圾回收器最初由 Redhat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在针对 JVM 上的内存回收实现低停顿的需求。在 2014 年贡献给OpenJDK。</p></li><li><p>Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB,99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p></li><li><p>总结</p><ul><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降 </li><li>Shenandoah GC 的强项：低延迟时间</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收3--相关概念</title>
      <link href="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc（）的理解"><a href="#System-gc（）的理解" class="headerlink" title="System.gc（）的理解"></a>System.gc（）的理解</h2><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719095933539.png" alt="image-20210719095933539" style="zoom:50%;"><p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719095745989.png" alt="image-20210719095745989"></p><p>在默认情况下，通过 System.gc（）或者 Runtime. Getruntime.gc（）的调用，会显式触发 Full  GC，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而 system.gc（）调用附带一个免责声明，无法保证对垃圾收集器的调用。</p><p>JVM 实现者可以通过 System.gc（）调用来定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用  System. gc ()</p><h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><ul><li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p></li><li><p>由于 GC 一直在发展，所以一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收经跟不上内存消耗的速度，否则不太容易出现 OOM 的情况。</p></li><li><p>大多数情況下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p></li><li><p>Javadoc 中对 Outofmemoryerror 的解释是，<strong>没有空闲内存，并且垃圾收集器也无法提供更多内存。</strong></p><ul><li><p>首先说没有空闲内存的情况：说明Java 虚拟机的堆内存不够。原因有二：</p><ul><li><p>Java虚拟机的堆内存设置不够</p><ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx 来调整。</li></ul></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><ul><li>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 Outofmemoryerror 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“java.lang. Outofmemoryerror: PermGen space“。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 OOM 有所改观，出现 OOM，异常信息则变成了：“java.lang. Outofmemoryerror: Metaspace“。直接内存不足，也会导致 OOM</li></ul></li></ul></li><li><p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。 </li><li>在java.nio.BITs. reserveMemory（）方法中，我们能清楚的看到, System.gc（）会被调用，以清理空间。</li></ul></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 Outofmemoryerror。</li></ul></li></ul></li></ul><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719101102717.png" alt="image-20210719101102717" style="zoom:50%;"><ul><li>也称作“存储渗漏”。<strong>严格来说，只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。</strong></li><li>但实际情很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做<strong>宽泛意义上的“内存泄漏”</strong></li><li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 Outofmemory 异常，导致程序崩溃。</li><li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生</p></li><li><p>一些提供close的资源为关闭导致内存泄漏</p><p>数据库连接（datasource. getConnection (），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p></li></ul><h2 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h2><p>Stop-the- World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW。</p><ul><li><p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</li></ul></li></ul><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p><p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p><p>哪怕是 G1 也不能完全避免 Stop-the-word 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间</p><p>STW 是 JVM 在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉</p><p>开发中不要用 system.gc (）；会导致 Stop-the-word 的发生。</p><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719101508544.png" alt="image-20210719101508544" style="zoom:33%;"><ul><li>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</li><li>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</li></ul><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719101550266.png" alt="image-20210719101550266" style="zoom:33%;"><ul><li>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel)。</li><li>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行</li><li>适合科学计算，后台处理等弱交互场景</li></ul><h3 id="并发与并行对比"><a href="#并发与并行对比" class="headerlink" title="并发与并行对比"></a>并发与并行对比</h3><ul><li>并发，指的是多个事情，在<strong>同一时间段内同时发生了</strong>。并行，指的是多个事情，在<strong>同一时间点上同时发生了。</strong></li><li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li><li>只有在多 CPU 或者一个 CPU 多核的情況中，オ会发生并行。否则，看似同时发生的事情，其实都是并发执行的</li></ul><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><ul><li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p><ul><li>如ParNew,Parallel Scavenge,Parallel Old</li></ul></li><li><p>串行（Serial）</p><ul><li>相较于并行的概念，单线程执行</li><li>如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</li></ul><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719101923600.png" alt="image-20210719101923600" style="zoom:50%;"><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719101942638.png" alt="image-20210719101942638" style="zoom:50%;"></li><li><p>并发（Concurrent）</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719102959156.png" alt="image-20210719102959156" style="zoom:50%;"><ul><li>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>用户程序继续执行，而垃圾收集程序线程运行于另一个CPU上</li><li>如：CMS、G1</li></ul></li></ul></li></ul><p>​     </p><h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ul><li><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC 这些位置称为“安全点（Safepoint）”。</p></li><li><p>Safe Point 的选择很重要，<strong>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题。</strong>大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择些执行时间较长的指令作为 Safe Point，如方法调用、循环跳转和异常跳转等</p></li><li><p>如何在 Gc 发生时，检査所有线程都跑到最近的安全点停顿下来呢？</p><ul><li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断：设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ul></li></ul><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><ul><li><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p></li><li><p>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的。我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p></li><li><p>实际执行时</p><ul><li>1、当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC, JVM 会忽略标识为 Safe Region 状态的线程</li><li>2、当线程即将离开 Safe Region 时，会检査 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止</li></ul></li></ul><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><h3 id="再谈引用-1"><a href="#再谈引用-1" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既偏门又非常高频的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p><p>在 JDK1.2 版之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong  Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference)4 种，这 4 种引用强度依次逐渐减弱。</p><p>除强引用外，其他 3 种引用均可以在java.lang.ref 包中找到它们的身影。开发人员可以在应用程序中直接使用它们。</p><p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public,可以在应用程序中直接使用</p><ul><li><strong>强引用</strong>（Strongreference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“object obj= new Object（）”这种引用关系。无论任何情下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><strong>软引用</strong>（Softreference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li><strong>弱引用</strong>（Weakreference）：被弱引用关联的对象只能生存到下次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li><strong>虚引用</strong>（Phantomreference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><ul><li><p>在Java 程序中，最常见的引用类型是强引用（普通系统 99%以上都是强引用），也就是我们最常见的普通对象引用，也是默认的引用类型。</p></li><li><p>当在Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用</p></li><li><p>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象</p></li><li><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null, 就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策路</p></li><li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在定条件下，都是可以被回收的。所以，<strong>强引用是造成 Java 内存泄漏的主要原因之</strong></p></li><li><p>特点</p><ul><li>强引用可以直接访问目标对象</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向的对象</li><li>强引用可能导致内存泄漏</li></ul></li></ul><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><ul><li><p>内存不足即回收</p></li><li><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第2次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p></li><li><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li><li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p></li><li><p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719111326047.png" alt="image-20210719111326047" style="zoom:50%;"></li></ul><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><ul><li><p>发现即回收</p></li><li><p>弱引用也是用来描述那些非必需对象，只被弱引用关联的对象只能生存到下次垃圾收集发生为止。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p></li><li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p></li><li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p></li><li><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p></li><li><p>WeakHashMap</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B63-%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/image-20210719111423860.png" alt="image-20210719111423860" style="zoom:50%;"></li></ul><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><ul><li>对象回收跟踪</li><li>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</li><li>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li><li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get（）方法取得对象时，总是 null。</li><li>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</li><li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</li><li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li></ul><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><ul><li>它用以实现对象的 finalize（）方法，也可以称为终结器引用。</li><li>无需手动编码，其内部配合引用队列使用。</li><li>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize（）方法，第二次 GC 时才能回收被引用对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收2--算法</title>
      <link href="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="垃圾标记阶段：对象存活判断"><a href="#垃圾标记阶段：对象存活判断" class="headerlink" title="垃圾标记阶段：对象存活判断"></a>垃圾标记阶段：对象存活判断</h3><ul><li>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GCオ会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段。</li><li>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：引用计数算法和可达性分析算法。</li></ul><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ul><li><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个<strong>整形的引用计数器属性。用于记录对象被引用的情况</strong>。</p></li><li><p>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1; 当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0, 即表示对象 A 不可能再被使用，可进行回收。</p></li><li><p>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性</p></li><li><p>缺点：</p><ul><li><p>他需要单独的字段存储计数器，这样的做法增加了存储空间的开销</p></li><li><p>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销</p></li><li><p>引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法</p><ul><li><p>循环引用–<strong>内存泄漏</strong></p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/image-20210718171809144.png" alt="image-20210718171809144" style="zoom:50%;"></li></ul></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 python，它更是同时支持引用计数和垃圾收集机制。</p></li><li><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p></li><li><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</p></li><li><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系</li><li>使用弱引用 weakref, weakref 是 python 提供的标准库，旨在解决循环引用。</li></ul></li></ul><h2 id="标记阶段：可达性分析算法（或根搜索算法、追踪性垃圾收集）"><a href="#标记阶段：可达性分析算法（或根搜索算法、追踪性垃圾收集）" class="headerlink" title="标记阶段：可达性分析算法（或根搜索算法、追踪性垃圾收集）"></a>标记阶段：可达性分析算法（或根搜索算法、追踪性垃圾收集）</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止<strong>内存泄漏</strong>的发生。</li><li>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）。</li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li><p>可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上<strong>至下的方式搜索被根对象集合所连接的目标对象是否可达。</strong></p></li><li><p>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链（Reference Chain)</strong></p></li><li><p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p></li><li><p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/image-20210718172246794.png" alt="image-20210718172246794" style="zoom:50%;"></li></ul><h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><p>所谓“GC Roots”<strong>根集合是一组必须活跃的引用</strong></p><p>在Java语言中，GC Roots包括以下几类元素：</p><ol><li><p>虚拟机栈中引用的对象</p><ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等</li></ul></li><li><p>本地方法栈内JNI（通常说的本地方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p><ul><li>比如：Java类的引用类型静态变量</li></ul></li><li><p>方法区中常量引用的对象</p><ul><li>比如：字符串常量池（String Table）里的引用</li></ul></li><li><p>所有被同步锁synchronized持有的对象</p></li><li><p>Java虚拟机内部的引用</p><ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器</li></ul></li><li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</p></li></ol><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（Partial GC）。</p><ul><li>如果只针对Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GC Roots 集合中去考虑，才能保证可达性分析的准确性。</li></ul><p>小技巧：由于 Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证</p><p>这点也是导致 GC 进行时必须 “Stop The World“的一个重要原因</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是<strong>必须要停顿的</strong>。</li></ul><h2 id="对象的finalization机制"><a href="#对象的finalization机制" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h2><h3 id="对象的finalization机制-1"><a href="#对象的finalization机制-1" class="headerlink" title="对象的finalization机制"></a>对象的finalization机制</h3><ul><li><p>Java 语言提供了对象终止（finallization）机制来允许开发人员提供对象被销毀之前的自定义处理逻辑。</p></li><li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize（）方法。</p></li><li><p>finalize（）方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p></li><li><p>永远不要主调用某个对象的 finalize（）方法，应该交给垃圾回收机制调用。理由包括下面三点：</p><ul><li>在 finalize（）时可能会导致对象复活。</li><li>finalize（）方法的执行时间是没有保障的，它完全由 GC 线程决定，极端情况下若不发生 GC，则 finalize（）方法将没有执行机会。</li><li>一个糟糕的 finalize（）会严重影响 GC 的性能。</li></ul></li><li><p>从功能上来说，finalize（）方法与 C++中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize（）方法在本质上不同于 C++中的析构函数。</p></li><li><p>由于 finalize（）方法的存在，虚拟机中的对象一般处于三种可能的状态</p><ul><li><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><strong>可触及的</strong>：从根节点开始，可以到达这个对象。</li><li><strong>可复活的</strong>：对象的所有引用都被释放，但是对象有可能在 finalize（）中复活。</li><li><strong>不可触及的</strong>：对象的 finalize（）被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize（）只会被调用一次。</li></ul></li><li><p>以上 3 种状态中，是由于 finalize（）方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p></li></ul></li></ul><h3 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h3><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p><p>1.如果对象objA到GC Roots没有引用链，则进行第一次标记</p><p>2.进行筛选，判断此对象是否有必要执行finalize（）方法</p><ul><li>①如果对象 objA 没有重写 finalize（）方法，或者 finalize（）方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li><li>②如果对象 objA 重写了 finalize（）方法，且还未执行过，那么 objA会被插入到 F- Queue队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize（）方法执行。</li><li>③finalize（）方法是对象逃脱死亡的最后机会，稍后 GC 会对 F- Queue 队列中的对象进行第二次标记。如果 objA 在 finalize（）方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情況下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的 finalize 方法只会被调用一次。</li></ul><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><h3 id="垃圾清除阶段"><a href="#垃圾清除阶段" class="headerlink" title="垃圾清除阶段"></a>垃圾清除阶段</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在JVM中比较常见的三种垃圾收集算法是标记-清除算法（Mark-Sweep）、复制算法（Copying）、标记-压缩算法（Mark-Comapct）</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>标记清除算法（Mark- Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J. Mccarthy 等人在 1960 年提出并并应用于 Lisp 语言。</li></ul><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/image-20210719090258090.png" alt="image-20210719090258090" style="zoom:50%;"><ul><li><p>当堆中的有效内存空间（avallable memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li>标记：Collector 从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的 Header 中记录为可达对象</li><li>清除：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收。</li></ul></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>效率不高</li><li>在执行GC的时候，需要停止整个应用程序，导致用户体验差</li><li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表</li></ul><h4 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h4><ul><li>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放。</li></ul><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul><li>为了解决标记一清除算法在垃圾收集效率方面的缺陷，M. L. Minsky 于 1963 年发表了著名的论文，“使用双存储区的Lisp 语言垃圾收集器 CA  LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M. L. Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M. L. Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</li></ul><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/image-20210719090509036.png" alt="image-20210719090509036" style="zoom:50%;"><ul><li>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现碎片的问题</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>缺点明显，就是需要两倍的内存空间</li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小。</li></ul><h3 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h3><ul><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</li><li>即特别适合垃圾对象很多，存活对象很少的场景；例如 Young 区的 Survivor0 和 Survivor1 区</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在新生代，对常规应用的垃圾回收，一次通常可以回收 70%-99%的内存空间回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ul><h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><ul><li>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</li><li>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记压缩（Mark- Compact）算法由此诞生。</li></ul><h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B62-%E7%AE%97%E6%B3%95/image-20210719091714298.png" alt="image-20210719091714298" style="zoom:50%;"><ul><li>第一阶段和标记清除算法一样从根节点开始标记所有被引用对象</li><li>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</li><li>之后，清理边界外所有的空间。</li></ul><h3 id="与标记-清除算法的差异"><a href="#与标记-清除算法的差异" class="headerlink" title="与标记-清除算法的差异"></a>与标记-清除算法的差异</h3><ul><li>标记压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记一清除一压缩（Mark- Sweep -Compact）算法。</li><li>二者的本质差异在于标记-清除算法是一种非移动式的回收算法，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策</li><li>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</li></ul><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><ul><li>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer)</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可</li><li>消除了复制算法当中，内存减半的高额代价</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>从效率上来说，标记-整理算法要低于复制算法</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存</p><p>而为了尽量兼顾上面提到的三个指标，标记一整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：string 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p>目前几乎所有的 GC 都是用分代收集（Generational Collecting）算法执行垃圾回收的。</p><p>在 Hotspot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点</p><ul><li><p>年轻代（Young Gen）</p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</li></ul></li><li><p>老年代（Tenured Gen）</p><ul><li><p>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</p></li><li><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记一清除或者是标记一清除与标记整理的混合实现。</p><ul><li>Mark 阶段的开销与存活对象的数量成正比。 </li><li>Sweep 阶段的开销与所管理区域的大小成正相关。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul></li></ul></li></ul><p>以 Hotspot 中的 CMS 回收器为例，CMS 是基于 Mark- Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark- Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode  Failure 时），将采用 Serial 执行 Full GC 以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代。</p><h2 id="增量收集算法、分区算法"><a href="#增量收集算法、分区算法" class="headerlink" title="增量收集算法、分区算法"></a>增量收集算法、分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><ul><li><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the Word 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p></li><li><p>基本思想</p><ul><li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</li><li>总的来说，增量收集算法的基础仍是传统的标记一清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</li></ul></li><li><p>缺点</p><ul><li>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。</li></ul></li></ul><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><ul><li>般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 Gc 所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间</li><li>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收1--概述</title>
      <link href="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61-%E6%A6%82%E8%BF%B0/"/>
      <url>/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61-%E6%A6%82%E8%BF%B0/image-20210718165400800.png" alt="image-20210718165400800" style="zoom:50%;"><h2 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h2><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>那些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><h3 id="什么是垃圾呢？"><a href="#什么是垃圾呢？" class="headerlink" title="什么是垃圾呢？"></a>什么是垃圾呢？</h3><ul><li>垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾</li></ul><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</p><h2 id="为什么需要GC"><a href="#为什么需要GC" class="headerlink" title="为什么需要GC"></a>为什么需要GC</h2><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有 GC 就不能保证应用程序的正常进行。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><p>在早期的C/C++时代,垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61-%E6%A6%82%E8%BF%B0/image-20210718165910701.png" alt="image-20210718165910701" style="zoom:50%;"><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来频繁申请和释放内存的管理负担。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生内存泄漏，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><p>在有了垃圾回收机制后，上述代码块极有可能变成这样：</p><img src="/2021/07/19/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B61-%E6%A6%82%E8%BF%B0/image-20210718165920875.png" alt="image-20210718165920875" style="zoom:50%;"><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势。可以说，这种自动化的内存分配和垃圾回收的方式己经成为现代开发语言必备的标准。</p><h2 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h2><p>自动内存管无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p><h3 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h3><ul><li>对于 Java 开发人员而言自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力。</li><li>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofmemoryerrorl 时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节</li></ul><h3 id="垃圾回收的范围"><a href="#垃圾回收的范围" class="headerlink" title="垃圾回收的范围"></a>垃圾回收的范围</h3><ul><li><p>垃圾回收可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收</p><ul><li>其中，Java堆是垃圾收集器的工作重点</li></ul></li><li><p>从次数上讲</p><ul><li>频繁收集Young区</li><li>较少收集OLd区</li><li>基本不动Perm区</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String Table</title>
      <link href="/2021/07/18/String-Table/"/>
      <url>/2021/07/18/String-Table/</url>
      
        <content type="html"><![CDATA[<h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><p>String：字符使用一对““引起来表示。</p><p>string 声明为 final 的，不可被继承</p><p>String 实现了 Serializable 接口：表示字符串是支持序列化的。实现了 Comparabe 接口：表示 string 可以比较大小</p><p>string 在 jdk8 及以前内部定义了 final char [] value 用于存储字符串数据。dk9 时改为 byte []</p><p>String：代表不可变的字符序列。简称：不可变性</p><ul><li>当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的value进行赋值</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li><li>当调用String的replace（）方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</li></ul><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中</p><p>字符串常量池中是不会存储相同内容的字符串的</p><ul><li>String 的 string Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 string Pool 的 string 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用 Sting. intern 时性能会大幅下降</li><li>使用-XX: StringTableSize 可设置 Stringtable 的长度</li><li>在 jdk6 中 stringtabe 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。Stringtablesize 设置没有要求</li><li>在 jdk7 中，Stringtable 的长度默认值是 60013, String Tablesize 设置没有要求</li><li>Jdk8 开始，设置 stringtablel 的长度的话，1009 是可设置的最小值。</li></ul><h2 id="String的内存分配"><a href="#String的内存分配" class="headerlink" title="String的内存分配"></a>String的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，string 类型的常量池比较特殊。它的主要使用方法有两种。</p><ul><li>直接使用双引号声明出来的String对象会直接存储在常量池中</li><li>如果不是双引号声明的String对象，可以使用String提供的intern（）方法</li></ul><p>Java6及以前，字符串常量池存放在永久代</p><p>Java7中Oracle 的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java7 中使用 string. Intern（）。</li></ul><p>Java8元空间，字符串常量在堆</p><img src="/2021/07/18/String-Table/image-20210718093850240.png" alt="image-20210718093850240" style="zoom: 50%;"><img src="/2021/07/18/String-Table/image-20210718093922151.png" alt="image-20210718093922151" style="zoom:50%;"><p>StringTable为什么要调整？因为永久代的回收效率很低，在full GC的时候才会触发。而Full GC是老年代空间不足、永久代空间不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h2 id="String的基本操作"><a href="#String的基本操作" class="headerlink" title="String的基本操作"></a>String的基本操作</h2><p>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例</p><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><p>常量与常量的拼接结果在常量池，原理是编译期优化</p><img src="/2021/07/18/String-Table/image-20210718101150948.png" alt="image-20210718101150948" style="zoom:50%;"><p>常量池中不会存在相同内容的常量</p><p>只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</p><img src="/2021/07/18/String-Table/image-20210718101256427.png" alt="image-20210718101256427" style="zoom:50%;"><p>如果是两个final类型的String变量进行拼接操作拼接结果在常量池</p><img src="/2021/07/18/String-Table/image-20210718101423998.png" alt="image-20210718101423998" style="zoom:50%;"><p>如果拼接的结果调用intern（）方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址 </p><img src="/2021/07/18/String-Table/image-20210718101452860.png" alt="image-20210718101452860" style="zoom:50%;"><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern()的使用"></a>intern()的使用</h2><img src="/2021/07/18/String-Table/image-20210718153858341.png" alt="image-20210718153858341" style="zoom:50%;"><p>如果不是用双引号声明的 string 对象，可以使用 string 提供的 intern 方法：intern方法会从字符串常量池中查询当前字符申是否存在，若不存在就会将当前字符串放入常量池中。</p><p>也就是说，如果在任意字符串上调用 string. Intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true:</p><p>(“a”+“b”+”c“). intern==”abc“</p><p>通俗点讲，Interned String。就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool)</p><h3 id="总结String的intern（）的使用"><a href="#总结String的intern（）的使用" class="headerlink" title="总结String的intern（）的使用"></a>总结String的intern（）的使用</h3><ul><li><p>jdk 1.6中，将这个字符串对象尝试放入串池</p><img src="/2021/07/18/String-Table/image-20210718155123589.png" alt="image-20210718155123589" style="zoom:50%;"><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把<strong>此对象复制一份，放入串池，</strong>并返回串池中的对象地址</li></ul></li><li><p>jdk 1.7起，将这个字符串对象尝试放入串池</p><img src="/2021/07/18/String-Table/image-20210718155153834.png" alt="image-20210718155153834" style="zoom:50%;"><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<strong>对象的引用地址复制一份</strong>，放入串池，并返回串池中的引用地址</li></ul></li></ul><img src="/2021/07/18/String-Table/image-20210718155334594.png" alt="image-20210718155334594" style="zoom:50%;"><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ul><li><p>new String（“ab”）会创建几个对象？</p></li><li><p>new String（“a“）+new String（”b“）呢？</p><img src="/2021/07/18/String-Table/image-20210718155950844.png" alt="image-20210718155950844" style="zoom:50%;"></li></ul><h3 id="intern（）的效率测试（空间角度）"><a href="#intern（）的效率测试（空间角度）" class="headerlink" title="intern（）的效率测试（空间角度）"></a>intern（）的效率测试（空间角度）</h3><ul><li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用  intern（）方法，就会明显降低内存的大小。</li></ul><h2 id="StringTable的垃圾回收"><a href="#StringTable的垃圾回收" class="headerlink" title="StringTable的垃圾回收"></a>StringTable的垃圾回收</h2><h2 id="G1中的String去重操作"><a href="#G1中的String去重操作" class="headerlink" title="G1中的String去重操作"></a>G1中的String去重操作</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>对许多 Java 应用（有大的也有小的）做的测试得出以下结果</p><ul><li>堆存活数据集合里面 string，对象占了 25% </li><li>堆存活数据集合里面重复的 string 对象有 13.5% </li><li>String 对象的平均长度是 45</li></ul><p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java 堆中存活的数据集合差不多 25%是 string 对象。更进一步，这里面差不多一半 string 对象是重复的，重复的意思是说：string1. Equals (string2) =true。堆上存在重复的 String 对象必然是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 string 对象进行去重，这样就能避免浪费内存。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的 string对象</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 string 对象。</li><li>使用一个 hashtable 来记录所有的被 string对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的char 数组</li><li>如果存在，string 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果査找失败，char 数组会被插入到 hashtable，这样以后的时候就可以共享这个数组了。</li></ul><h4 id="命令行选项"><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h4><ul><li>UsestringDeduplication (bool）：开启 string 去重，默认是不开启的，需要手动开启。</li><li>PrintstringDeduplicationStatistics (bool）：打印详细的去重统计信息  </li><li>StringDeduplicationAgeThreshold (uintx）：达到这个年龄的 string。对象被认为是去重的候选对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直接内存与执行引擎</title>
      <link href="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域</p><p>直接内存是在Java堆外、直接向系统申请的内存空间</p><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存</li><li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li></ul><p>也可能导致OutOfMemoryError异常</p><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul><p>直接内存大小可以通过MaxDirectMemorySize设置</p><p>如果不指定，默认与堆的最大值-Xmx参数值一致</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要内存如图的操作。使用IO，见图。这里需要两份内存存储重复数据，效率低</p><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717130500734.png" alt="image-20210717130500734" style="zoom:50%;"><p>使用NIO时，见图。操作系统划出的直接缓存区可以被Java代码直接访问，只有一份。NIO适合对大文件的读写操作</p><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717130520263.png" alt="image-20210717130520263" style="zoom:50%;"><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717130617006.png" alt="image-20210717130617006" style="zoom:50%;"><p>简单理解：Java process memory=Java heap+native memory</p><h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717131325759.png" alt="image-20210717131325759" style="zoom:50%;"><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>执行引擎是Java 虚拟机核心的组成部分之一</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。</li><li>JVM 的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息</li><li>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine) 的任务就是将字节码指令解释/编译为对应平台上的本地机器指令オ可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ul><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717131933797.png" alt="image-20210717131933797" style="zoom: 50%;"><p>1）执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</p><p>2）每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</p><p>3）当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息</p><p>从外观上来看，所有的Java 虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。</p><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717132344648.png" alt="image-20210717132344648" style="zoom:50%;"><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤。</p><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717132104281.png" alt="image-20210717132104281" style="zoom:50%;"><p>Java代码编译是由Java源码编译器来完成，流程图如上所示</p><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717132114842.png" alt="image-20210717132114842" style="zoom:50%;"><p>Java代码的执行是由JVM执行引擎来完成，流程图如上所示</p><h3 id="问题：什么是解释器（Interpreter），什么是JIT编译器？"><a href="#问题：什么是解释器（Interpreter），什么是JIT编译器？" class="headerlink" title="问题：什么是解释器（Interpreter），什么是JIT编译器？"></a>问题：什么是解释器（Interpreter），什么是JIT编译器？</h3><ul><li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行</li><li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li></ul><h3 id="问题：为什么说Java是半编译半解释的语言？"><a href="#问题：为什么说Java是半编译半解释的语言？" class="headerlink" title="问题：为什么说Java是半编译半解释的语言？"></a>问题：为什么说Java是半编译半解释的语言？</h3><ul><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li></ul><h2 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h2><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717132537675.png" alt="image-20210717132537675" style="zoom: 33%;"><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ul><li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同</li></ul><h3 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h3><ul><li><p>指令</p><ul><li>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mo, inc 等），可读性稍好</li><li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</li></ul></li><li><p>指令集</p><ul><li><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</p></li><li><p>如常见的</p><ul><li>X86 指令集，对应的是 x86 架构的平台 </li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul></li></ul></li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p></li><li><p>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbo）或标号（Labe1) 代替指令或操作数的地址</p></li><li><p>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</p><ul><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行。</li></ul></li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</li><li>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</li></ul><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ul><li><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p></li><li><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p></li><li><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p><ul><li>字节码的典型应用为Java bytecode</li></ul></li></ul><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><img src="/2021/07/18/%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/image-20210717132554410.png" alt="image-20210717132554410" style="zoom:33%;"><ul><li>编译过程：读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</li><li>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程</li></ul><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p>JVM 设计者们的初衷仅仅只是单纯地为了满足 Java 程序实现跨平台特性，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><h3 id="解释器工作机制"><a href="#解释器工作机制" class="headerlink" title="解释器工作机制"></a>解释器工作机制</h3><ul><li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li></ul><h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ul><li>古老的字节码解释器</li><li>现在普遍使用的模板解释器</li></ul><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><ul><li>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 python、Perl、Ruby 等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些 C/C++程序员所调侃。</li><li>为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即<strong>时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，</strong>每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</li><li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li></ul><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java代码的执行分类"><a href="#Java代码的执行分类" class="headerlink" title="Java代码的执行分类"></a>Java代码的执行分类</h3><ul><li>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</li><li>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT, Just In Time ）将方法编译成机器码后再执行</li></ul><p>Hotspot VM 是目前市面上高性能虚拟机的代表作之一。它采用解释器与即时编译器并存的架构。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代的时间和直接解释执行代码的时间</p><p>在今天,Java程序的运行性能早已脱胎换骨,已经达到了可以和C/C++ 程序一较高下的地步</p><p>有些开发人员会感觉到诧异，既然 Hotspot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><p><strong>首先明确</strong>：</p><p>当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。</p><p>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p><strong>所以：</strong></p><p>尽管 Jrockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="HotSpot-JVM的执行方式"><a href="#HotSpot-JVM的执行方式" class="headerlink" title="HotSpot JVM的执行方式"></a>HotSpot JVM的执行方式</h3><p>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</p><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><ul><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译器的前端”更准确一些）把 java 文件转变成.Class 文件的过程</li><li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程。</li><li>还可能是指使用<strong>静态提前编译器</strong>（AOT 编译器，Ahead Of Time Compiler）直接把.java 文件编译成本地机器代码的过程</li></ul><h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p><ul><li><p>一<strong>个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为 OSR (On Stack  Replacement）编译。</p></li><li><p>个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环オ可以达到这个标准？必然需要一个明确的阈值，JIT 编译器オ会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<strong>热点探测功能</strong>。</p></li><li><p>目<strong>前 Hotspot VM 所采用的热点探测方式是基于计数器的热点探测</strong>。</p></li><li><p>采用基于计数器的热点探测，Hotspot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back  Edge Counter)</p><ul><li><p><strong>方法调用计数器</strong>用于统计方法的调用次数</p><ul><li>这个计数器就用于统计方法被调用的次数，它的默认值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发JIT编译。</li><li>这个阈值可以通过虚拟机参数-XX: CompileThreshold来人为设定。</li><li>当一个方法被调用时，会先检査该方法是否存在被 JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1, 然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li><strong>热度衰减</strong><ul><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个<strong>相对的执行频率</strong>，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time)</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX: - UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX: CounterHalfLifeTime 参数设置半衰周期的时间，单位是秒。</li></ul></li></ul></li><li><p><strong>回边计数器</strong>则用于统计循环体执行的循环次数</p><ul><li>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</li></ul></li></ul></li></ul><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot  VM"></a>HotSpot  VM</h3><h4 id="HotSpot-VM可以设置程序执行方式"><a href="#HotSpot-VM可以设置程序执行方式" class="headerlink" title="HotSpot  VM可以设置程序执行方式"></a>HotSpot  VM可以设置程序执行方式</h4><p>缺省情况下 Hotspot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ul><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><h4 id="HotSpot-VM中JIT分类"><a href="#HotSpot-VM中JIT分类" class="headerlink" title="HotSpot VM中JIT分类"></a>HotSpot VM中JIT分类</h4><ul><li><p>在 Hotspot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server  Compiler，但大多数情況下我们简称为 C1 编译器和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器。C1 编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。 </li><li>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器。C2 进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。</li></ul></li><li><p>分层编译</p><ul><li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</li><li>不过在 Java7 版本之后，一开发人员在程序中显式指定命令“- server “时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</li></ul></li><li><p>C1和C2编译器不同的优化策略</p><ul><li><p>在不同的编译器上有不同的优化策略，C1 译器上主要有方法内联，去虚拟化、冗余消除。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li><p>C2 的优化主要是在全局层面，逃逸分析是优化的基础。基于<strong>逃逸分析</strong>在 C2 上有如下几种优化：</p><ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指 synchronized</li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>一般来讲，JIT 编译出来的机器码性能比解释器高。</li><li>C2 编译器启动时长比 C1 编译器慢，系统稳定执行以后，C2 编译器执行速度远远快于 C1 编译器。</li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>1：Graal编译器</p><ul><li>自 JDK10 起，Hotspot 又加入个全新的即时编译器：Graal 编译器。</li><li>编译效果短短几年时间就追评了 C2 编译器。未来可期。</li><li>目前，带着“实验状态标签，需要使用开关参数-XX: +UnlockExperimentalVMOptions   -XX: +UseJVMCICompiler 去激活，才可以使用。</li></ul><p>2：关于AOT编译器</p><ul><li><p>Jdk9 引入了 AOT 编译器（静态提前编译器，Ahead Of Time Compiler)</p></li><li><p>Java9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而 AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程</p></li><li><p>最大好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少 Java 应用给人带来“第一次运行慢”的不良体验。</p></li><li><p>缺点：</p><ul><li>破坏了 java “一次编译，到处运行”，必须为每个不同硬件、OS 编译对应的发行包。</li><li>降低了 Java 链接过程的动态性，加载的代码在编译期就必须全部已知还需要继续优化中，最初只支持 Linux x64 java base</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的实例化、内存布局与访问定位</title>
      <link href="/2021/07/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
      <url>/2021/07/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ul><li><p>new</p><ul><li>最常见的方式</li><li>变形一：XXX的静态方法</li><li>变形二：XXXBuilder/XXXFactory的静态方法</li></ul></li><li><p>class的newInstance（）：反射的方式，只能调用空参的构造器，权限必须是public</p></li><li><p>constructor的newInstance（）：反射的方式，可以调空参、带参的构造器，权限没有要求</p></li><li><p>使用clone（）：不调用任何构造器，当前类需要实例化cloneable接口，实现clone（）方法</p></li><li><p>使用反序列化：从文件中、网络中获取一个对象的二进制流</p></li><li><p>第三方Objnesis</p></li></ul><h2 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h2><p>1.判断对象对应的类是否加载、链接、初始化</p><p>2.为对象分配内存</p><ul><li><p>如果内存规整-指针碰撞</p></li><li><p>如果内存不规整</p><ul><li>虚拟机需要维护一个列表</li><li>空闲列表分配</li></ul></li></ul><p>3.处理并发安全问题</p><ul><li>采用CAS配上失败重试保证更新的原子性</li><li>每个线程预先分配一块TLAB</li></ul><p>4.初始化分配到的空间——所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p><p>5.设置对象的对象头</p><p>6.执行init方法进行初始化    </p><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><h2 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h2><ul><li><p>包含两部分</p><ul><li><p>运行时元数据（Mark Word）</p><ul><li>哈希值（hashCode）</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li><p>类型指针—指向类元数据InstanceKlass，确定该对象所属的类型</p></li></ul></li><li><p>说明：如果是数组，还需记录数组长度</p></li></ul><h2 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h2><ul><li><p>说明</p><ul><li>他是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身的拥有的字段）</li></ul></li><li><p>规则</p><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果CompactFields参数为true（默认为true）：子类的窄变量可能插入到父类变量的空隙</li></ul></li></ul><h2 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h2><ul><li>不是必须的，也没有特别含义，仅仅起到占位符的作用</li></ul><h2 id="小结：图示"><a href="#小结：图示" class="headerlink" title="小结：图示"></a>小结：图示</h2><img src="/2021/07/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210716172234605.png" alt="image-20210716172234605" style="zoom:50%;"><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>图示</p><img src="/2021/07/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210716172827776.png" alt="image-20210716172827776" style="zoom: 33%;"><p>创建对象的目的是为了使用它</p><p>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢</p><ul><li>定位，通过栈上reference访问</li></ul><p>对象访问方式主要有两种</p><ul><li><p>句柄访问</p><img src="/2021/07/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210716172942067.png" alt="image-20210716172942067" style="zoom:50%;"><ul><li>子主题 1</li><li>优势：Reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很音遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改。</li></ul></li><li><p>直接指针（HotSpot采用）</p><img src="/2021/07/17/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/image-20210716173000190.png" alt="image-20210716173000190" style="zoom:50%;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法区</title>
      <link href="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/"/>
      <url>/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><h3 id="从线程共享与否的角度"><a href="#从线程共享与否的角度" class="headerlink" title="从线程共享与否的角度"></a>从线程共享与否的角度</h3><ul><li>线程共享：堆、元空间</li><li>线程私有：虚拟机栈、本地方法栈、程序计数器</li><li><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716152516943.png" alt="image-20210716152516943" style="zoom: 50%;"></li></ul><h3 id="交互关系图1"><a href="#交互关系图1" class="headerlink" title="交互关系图1"></a>交互关系图1</h3><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716152616139.png" alt="image-20210716152616139" style="zoom:50%;"><h3 id="交互关系图2"><a href="#交互关系图2" class="headerlink" title="交互关系图2"></a>交互关系图2</h3><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716152625592.png" alt="image-20210716152625592" style="zoom:50%;"><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 Hotspot JVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，<strong>方法区看作是一块独立于 Java 堆的内存空间</strong>。</p><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p>方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域。</p><p>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。</p><p>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</p><p>方法区的大小決定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang. OutOfMemoryError:  PermGen space或者 java.lang. Outofmemoryerror: Metaspace</p><ul><li>加载大量的第三方的 Jar 包</li><li>Tomcat 部署的工程过多（30-50 个）</li><li>大量动态的生成反射类</li></ul><p>关闭 JVM 就会释放这个区域的内存。</p><h3 id="Hotspot中方法区的演进"><a href="#Hotspot中方法区的演进" class="headerlink" title="Hotspot中方法区的演进"></a>Hotspot中方法区的演进</h3><p>在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。</p><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如： BEA Jrockit/IBM J9中不存在永久代的概念。</p><ul><li>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过-XX: MaxPermSize 上限）</li></ul><p>而到了 JDK8, 终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代</p><p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常</p><h2 id="设置方法区大小与OOM"><a href="#设置方法区大小与OOM" class="headerlink" title="设置方法区大小与OOM"></a>设置方法区大小与OOM</h2><h3 id="设置方法区内存大小"><a href="#设置方法区内存大小" class="headerlink" title="设置方法区内存大小"></a>设置方法区内存大小</h3><p>方法区的大小不必是固定的，jvm可以根据应用的需要动态调整</p><ul><li><p>jdk7及以前</p><ul><li>-XX:PermSize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermSize来设定永久代最大可分配空间。32位机器默认是64M，64位机器默认是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError：PremGen space</li></ul></li><li><p>jdk8及以后</p><ul><li>元数据区大小可以使用参数-XX: MetaspacesSize 和-XX: MaxMetaspaceSize：指定，替代上述原有的两个参数</li><li>默认值依赖于平台。windows 下，-XX: Metaspacesize 是 21M, -XX: Maxmetaspacesize 的值是-1, 即没有限制</li><li>与永久代不同，如果不指定大小，默认情下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虛拟机一样会抛出异常 OutOfMemoryError: Metaspace</li><li>-XX: Metaspacesize：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说其默认的-XX: MetaspaceSize 值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将- XX: Metaspacesize 设置为一个相对较高的值。</li></ul></li></ul><h3 id="如何解决这些OOM"><a href="#如何解决这些OOM" class="headerlink" title="如何解决这些OOM"></a>如何解决这些OOM</h3><p>1、要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</p><p>2、如果是内存泄漏，可进一步通过工具看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GC Roots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p><p>3、如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检査虚拟机的堆参数（-Xmx 与-Xms），与机器物理内存对比看是否还可以调大，从代码上检是否存在某些对象生命周期过长、持有状态时间过长的情，尝试减少程序运行期的内存消耗。</p><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716155320069.png" alt="image-20210716155320069" style="zoom:50%;"><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等</p><h4 id="类型信息："><a href="#类型信息：" class="headerlink" title="类型信息："></a>类型信息：</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation), JVM 必须在方法区中存储以下类型信息：</p><p>①这个类型的完整有效名称（全名=包名.类名）</p><p>②这个类型直接父类的完整有效名（对于 interface 或是 java.lang.Object，都没有父类）</p><p>③这个类型的修饰符（public, abstract, final 的某个子集）</p><p>④这个类型直接接口的一个有序列表</p><h4 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h4><ul><li>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</li><li>域的相关信息包括：域名称、域类型、域修饰符（public, private,  protected, static, final, volatile, transient 的某个子集）</li></ul><h4 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h4><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li><p>方法名称</p></li><li><p>方法的返回类型（或 void)</p></li><li><p>方法参数的数量和类型（按顺序）</p></li><li><p>方法的修饰符（public, private, protected, static, final,  synchronized, native, abstract 的一个子集）</p></li><li><p>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和  native 方法除外）</p></li><li><p>异常表（abstract 和 native 方法除外）</p><ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ul><h4 id="non-final的类变量"><a href="#non-final的类变量" class="headerlink" title="non-final的类变量"></a>non-final的类变量</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分</li><li>类变量被类的所有实例共享，即使没有类实例时你也可以访问它</li><li>补充说明：全局常量：static final <pre><code>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了</code></pre></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li><p>运行时常量池VS常量池</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716160713758.png" alt="image-20210716160713758" style="zoom:50%;"><ul><li><p>方法区，内部包含了运行时常量池。</p></li><li><p>字节码文件，内部包含了常量池。</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716161219400.png" alt="image-20210716161219400" style="zoom:50%;"><ul><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（COnstant pool table），包括各种字面量和对类型、域和方法的符号引用</li></ul></li><li><p>要弄清楚方法区，需要理解清楚 classfile，因为加载类的信息都在方法区</p></li><li><p>要弄清楚方法区的运行时常量池，需要理解清楚 Classfile 中的常量池</p></li></ul></li><li><p>为什么需要常量池？</p><ul><li>个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍</li></ul></li><li><p>常量池中有什么</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li><li><p>运行时常量池</p><ul><li><p>运行时常量池（Runtime Constant Pool) 是方法区的一部分</p></li><li><p>常量池表（Constant Pool Table）是 class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p></li><li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p></li><li><p>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</p></li><li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。</p><ul><li><p>运行时常量池，相对于 class 文件常量池的另一重要特征是：<strong>具备动态性</strong>。</p><ul><li>string.intern ()</li></ul></li></ul></li><li><p>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p></li><li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 Outofmemoryerror 异常。</p></li></ul></li></ul><h2 id="方法区使用举例"><a href="#方法区使用举例" class="headerlink" title="方法区使用举例"></a>方法区使用举例</h2><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716161822143.png" alt="image-20210716161822143" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716161928984.png" alt="image-20210716161928984" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162105728.png" alt="image-20210716162105728" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162139774.png" alt="image-20210716162139774" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162214532.png" alt="image-20210716162214532" style="zoom:50%;"><p>…</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162605067.png" alt="image-20210716162605067" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162624778.png" alt="image-20210716162624778" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162641334.png" alt="image-20210716162641334" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162657792.png" alt="image-20210716162657792" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162716102.png" alt="image-20210716162716102" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716162733342.png" alt="image-20210716162733342" style="zoom:50%;"><h2 id="方法区的演进细节"><a href="#方法区的演进细节" class="headerlink" title="方法区的演进细节"></a>方法区的演进细节</h2><h3 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h3><p>1.首先明确：只有HotSpot才有永久代</p><p>2.HotSpot中方法区的变化</p><ul><li>Jk1.6 及之前有永久代（permanent generation），静态变量（对象）存放在永久代上（对象实例永远放在堆空间）</li><li>jdk1.7有永久代，但己经逐步“去永久代”，<strong>字符串常量池、静态变量移除，保存在堆中</strong></li><li>jk1.8 及之后无永久代，<strong>类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆</strong></li></ul><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716163013781.png" alt="image-20210716163013781" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716163032069.png" alt="image-20210716163032069" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716163044355.png" alt="image-20210716163044355" style="zoom:50%;"><h3 id="永久代为什么要被元空间替换"><a href="#永久代为什么要被元空间替换" class="headerlink" title="永久代为什么要被元空间替换"></a>永久代为什么要被元空间替换</h3><ul><li><p>随着 Java8 的到来，Hotspot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</p></li><li><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空。</p></li><li><p>这项改动是很有必要的，原因有：</p><ol><li>为永久代设置空间大小是很难确定的。</li></ol><p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。比如某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</p><p>而<strong>元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存因此，默认情况下，元空间的大小仅受本地内存限制。</strong></p><ol start="2"><li>对永久代进行调优是很困难的。</li></ol></li></ul><h3 id="String-Table-为什么要调整"><a href="#String-Table-为什么要调整" class="headerlink" title="String Table 为什么要调整"></a>String Table 为什么要调整</h3><ul><li>Jdk7 中将 stringtable 放到了堆空间中。因为永久代的回收效率很低，在 full gc 的时候オ会触发。而 full gc 是老年代的空间不足、永久代不足时会触发。这就导致 Stringtable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</li></ul><h3 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h3><ul><li>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7 及其以后版本的 Hotspot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 class 对象存放在一起，存储于Java 堆之中，从我们的实验中也明确验证了这一点</li></ul><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 ZGC收集器就不支持类卸载）。</p><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 Hotspot 虚拟机对此区域未完全回收而导致内存泄漏。</p><p><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</strong></p><ul><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量</p><p>1、类和接口的全限定名</p><p>2、字段的名称和描述符</p><p>3、方法的名称和描述符</p></li><li><p>Hotspot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java 堆中的对象非常类似。</p></li><li><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi 、JSP 的重加载等，否则通常是很难达成的</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li><li><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收， Hotspot 虚拟机提供了-Xnoclassgc 参数进行控制，还可以使用- verbose: class 以及 -XX: + TracedClass- Loading、-XX: + TracedClassUnLoading 查看类加载和卸载信息</p></li><li><p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%89/image-20210716163952588.png" alt="image-20210716163952588" style="zoom:50%;"><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><ul><li>说一下JVM内存模型吧，有哪些区？分别干什么的？</li><li>Java8的内存分代改进</li><li>JVM内存分为哪几个区，每个区的作用是什么？</li><li>JVM内存分布/内存结构？堆和栈的区别？堆的结构？为什么有两个survivor区？</li><li>Eden和Survivor的比例分配？</li><li>jvm内存分区，为什么要有新生代和老年代</li><li>讲讲JVM运行时数据区</li><li>什么时候对象会进入老年代</li><li>JVM的永久代中会发生垃圾回收吗？</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区（本地方法栈&amp;堆）</title>
      <link href="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/"/>
      <url>/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715213917030.png" alt="image-20210715213917030" style="zoom: 50%;"><h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><p>简单地讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。一个  Native Method 是这样一个 Java 方法：该方法的实现由非 Java 语言实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C++中，你可以用 extern”c“告知 C++编译器去调用一个 C 的函数。</p><p>A native method is a Java method whose implementation is provided by non-java code</p><p>在定义ー个 native method 时，并不提供实现体（有些像定义ー个 Java  interface），因为其实现体是由非 java语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。</p><h2 id="为什么使用NativeMethod"><a href="#为什么使用NativeMethod" class="headerlink" title="为什么使用NativeMethod"></a>为什么使用NativeMethod</h2><p>Java 使用起来非常方便，然而有些层次的任务用 Java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><p><strong>与 Java 环境外交互：</strong></p><ul><li>有时 Java 应用需要与 Java 外面的环境交互，这是本地方法存在的主要原因。你可以想想 Java 需要与一些底层系统，如操作系统或某些硬件交换信息时的情。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</li></ul><p><strong>与操作系统交互：</strong></p><ul><li>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。还有，如果我们要使用一些 Java 语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ul><p><strong>Sun ‘s Java</strong></p><ul><li>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang. Thread 的 setpriority（）方法是用 Java 实现的，但是它实现调用的是该类里的本地方法  setpriority0（）。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 windows95 的平台上，这个本地方法最终将调用 Win32 Setpriority () API。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVM 调用。</li></ul><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><p>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</p><p>本地方法栈，也是线程私有的</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 outofmemoryerror 异常。</li></ul><p>本地方法是使用C语言实现的</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在  Execution Engine 执行时加载本地方法库。</p><p>当某个线程调用一个本地方它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥同样的权限。</p><ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul><p>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 native 方法，也可以无需实现地方法栈</p><p>在 Hotspot JVM 中，直接将本地方法和虚拟机合二为一</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。堆内存的大小是可以调节的。</p><p>《Java 虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p><p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB)。</p><p>《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。</p><ul><li>“几乎”所有的对象实例都在这里分配内存。—-从实际的角度看的</li></ul><p>数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收时才会被移除。</p><p>堆，是GC（Garbage Collection）执行垃圾回收的重点区域。</p><p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715221208704.png" alt="image-20210715221208704"></p><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222534835.png" alt="image-20210715222534835" style="zoom:50%;"><p><strong>堆空间的内部结构（JDK7&amp;JDK8）</strong></p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222431571.png" alt="image-20210715222431571" style="zoom:50%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715222707075.png" alt="image-20210715222707075" style="zoom: 33%;"><h2 id="设置堆内存大小与OOM"><a href="#设置堆内存大小与OOM" class="headerlink" title="设置堆内存大小与OOM"></a>设置堆内存大小与OOM</h2><p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项“-Xmx“和“-Xms“来进行设置。</p><ul><li>“-Xms“用于表示堆区的起始内存，等价于-XX: InitialHeapsize</li><li>“-Xmx“则用于表示堆区的最大内存，等价于-XX: MaxHeapsize</li></ul><p>一旦堆区中的内存大小超过“-Xmx“所指定的最大内存时，将会抛出  OutOfMemoryError 异常。</p><p>通常会将-Xms 和 -Xmx 两个参数配置相同的值，其目<strong>的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</strong></p><p>默认情況下, 初始内存大小：物理电脑内存大小1/64</p><p>最大内存大小：物理电脑内存大小1/4</p><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>存储在JVM中的Java对象可以被划分为两类：</p><ul><li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM生命周期保持一致。</li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）。</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210715223410342.png" alt="image-20210715223410342" style="zoom:50%;"><p>新生代和老年代的比例一般为1:2，默认- XX：NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3。</p><p>在 Hotspot 中，Eden 空间和另外两个 Survivor空间缺省所占的比例是 8:1:1 当然开发人员可以通过选项“-XX: SurvivorRatlo”调整这个空间比例。比如-XX: SurvivorRatio=8</p><p>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。</p><p>绝大部分的 Java 对象的销毁都在新生代进行了。</p><ul><li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的</li></ul><p>可以使用选项-Xmn“设置新生代最大内存大小</p><ul><li>这个参数一般使用默认值就可以了。</li></ul><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</li><li>New 的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到幸存者0区</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</li><li>啥时候能去养老区呢？可以设置次数。默认是 15 次。<ul><li>可以设置参数：<code>--XX:MaxTenuringThreshold=&lt;N&gt;</code>进行设置</li></ul></li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC: Major GC，进行养老区的内存清理</li><li>若养老区执行了 Maior GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常<ul><li>Java.lang.OutOfMemoryError:Java heap space</li></ul></li></ol><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716093835831.png" alt="image-20210716093835831" style="zoom:50%;"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to。</p><p>关于垃圾回收：频繁发生在新生区，很少在养老区收集，几乎不在永久区/元空间收集。</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716094133585.png" alt="image-20210716094133585" style="zoom:50%;"><h2 id="Minor-GC、Major-GC、Full-GC"><a href="#Minor-GC、Major-GC、Full-GC" class="headerlink" title="Minor GC、Major GC、Full GC"></a>Minor GC、Major GC、Full GC</h2><p>JVM 在进行 GC 时，并非每次都对上面三个内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC)</p><ul><li><p>部分收集：不是完整收集整个Java 堆的垃圾收集。其中又分为</p><ul><li><p>新生代收集（Minor GC/ Young GC）：只是新生代的垃圾收集</p></li><li><p>老年代收集 (Major GC/Old GC）：只是老年代的垃圾收集。</p><ul><li><p>目前，只有 CMS GC 会有单独收集老年代的行为。</p></li><li><p>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</p></li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。</p><ul><li>目前，只有 G1 GC 会有这种行为</li></ul></li></ul></li><li><p>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</p></li></ul><h3 id="最简单的分代式GC策略的触发条件"><a href="#最简单的分代式GC策略的触发条件" class="headerlink" title="最简单的分代式GC策略的触发条件"></a>最简单的分代式GC策略的触发条件</h3><p><strong>年轻代GC（Minor GC）触发机制：</strong></p><ul><li>当年轻代空间不足时，就会触发 Minor GC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存。）</li><li>因为 Java 对象大多都具备朝生タ灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解</li><li> Minor GC会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li></ul><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716100056988.png" alt="image-20210716100056988" style="zoom: 33%;"><p><strong>老年代GC（Major GC/Full GC）触发机制：</strong></p><ul><li><p>指发生在老年代的 GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p></li><li><p>出现了 Major Gc，经常会伴随至少ー次的 Minor GC（但非绝对的，在 Parallel  Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足则触发 Major Gc</li></ul></li><li><p> Major GC 的速度一般会比 Minor GC慢10倍以上，STW 的时间更长。</p></li><li><p>如果 Major GC 后，内存还不足，就报 OOM 了。 </p></li></ul><p><strong>Full GC触发机制：</strong>（后面详细介绍）</p><p>触发 Fu11GC 执行的情况有如下五种：</p><ol><li>调用 System.gc（）时，系统建议执行 Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li> 由 Eden 区、survivor space0 (From Space）区向 survivor space1 (To  Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些。</p><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p><strong>为什么需要把Java堆分代？不分代就不能正常工作了吗？</strong></p><ul><li><p>经研究，不同对象的生命周期不同。70%-99%的对象都是临时对象。</p><ul><li><p>新生代：有Eden、两块大小相同的Survivor构成，to总为空</p></li><li><p>老年代：存放新生代中经历多次GC仍然存活的对象</p></li></ul></li><li><p>其实不分代完全可以，分代的唯一理由就是优化 GC 性能。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p></li></ul><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。对象在  Survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代中</p><p>对象晋升老年代的年龄阈值，可以通过选项-XX: MaxTenuringThreshold 来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li><p>优先分配到 Eden </p></li><li><p>大对象直接分配到老年代</p><ul><li>尽量避免程序中出现过多的大对象</li></ul></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断</p><ul><li>如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到  MaxTenuringThreshold 中要求的年龄。</li></ul></li><li><p>空间分配担保</p><ul><li> -XX: HandlePromotionFailure</li></ul></li></ul><h2 id="为对象分配内存：TLAB"><a href="#为对象分配内存：TLAB" class="headerlink" title="为对象分配内存：TLAB"></a>为对象分配内存：TLAB</h2><h3 id="为什么会有TLAB（Thread-Local-Allocation-Buffer）？"><a href="#为什么会有TLAB（Thread-Local-Allocation-Buffer）？" class="headerlink" title="为什么会有TLAB（Thread Local Allocation Buffer）？"></a>为什么会有TLAB（Thread Local Allocation Buffer）？</h3><ul><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</li></ul><h3 id="什么是TLAB？"><a href="#什么是TLAB？" class="headerlink" title="什么是TLAB？"></a>什么是TLAB？</h3><ul><li>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为每个线程分配了一个私有缓存区域，它包含在 Eden 空间内。</li><li>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li>据我所知所有 OPEN JDK 衍生出来的 JVM 都提供了 TLAB 的设计。</li></ul><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103050211.png" alt="image-20210716103050211" style="zoom: 33%;"><h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ul><li>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但 JVM 确实是将TLAB 作为内存分配的首选</li><li>在程序中，开发人员可以通过选项“-XX: UseTLAB”设置是否开启TLAB 空间</li><li>默认情況下，TLAB 空间的内存非常小，仅占有整个 Eden 空间的 1%，当然我们可以通过选项“-XX: TLABWasteTargetPercent”设置 TLAB 空间所占用 Eden 空间的百分比大小。</li><li>一旦对象在 TLAB 空间分配内存失败时，JWM 就会尝试着通过使用<strong>加锁机制</strong>确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</li></ul><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103615156.png" alt="image-20210716103615156" style="zoom: 33%;"><h2 id="小结堆空间的参数设置"><a href="#小结堆空间的参数设置" class="headerlink" title="小结堆空间的参数设置"></a>小结堆空间的参数设置</h2><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103757241.png" alt="image-20210716103757241" style="zoom: 33%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716103832545.png" alt="image-20210716103832545" style="zoom:33%;"><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li><p>如果大于，则此次 Minor GC 是安全的</p></li><li><p>如果小于，则虚拟机会查看-XX: HandlePromotionFailure 设置值是否允许担保失败。</p><ul><li><p>如果 HandlePromotionFailure=true，那么会继续检査老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。</p><ul><li><p>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的</p></li><li><p>如果小于，则改为进行一次 Full GC。</p></li></ul></li><li><p>如果 HandlePromotionFailure= false，则改为进行一次 Full GC</p></li></ul></li></ul><p>在 JDK6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 OpenJDK 中的源码变化，虽然源码中还定义了HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小</strong>就会进行 Minor GC，否则将进行 Full G。</p><h2 id="堆是分配对象的唯一选择吗"><a href="#堆是分配对象的唯一选择吗" class="headerlink" title="堆是分配对象的唯一选择吗"></a>堆是分配对象的唯一选择吗</h2><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p><p>随着 Java 编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有种特殊情况，那就是如果经过<strong>逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。</strong>这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p><p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBao VM，其中创新的 GCIH (GC  invisible heap）技术实现。off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p><h3 id="逃逸分析概述"><a href="#逃逸分析概述" class="headerlink" title="逃逸分析概述"></a>逃逸分析概述</h3><ul><li><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p></li><li><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</p></li><li><p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上</p></li><li><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li><p>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</p></li><li><p>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</p></li></ul></li></ul><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105627607.png" alt="image-20210716105627607" style="zoom:33%;"><ul><li>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除。</li></ul><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105736720.png" alt="image-20210716105736720" style="zoom:33%;"><p>上述代码如果想要StringBuffer sb不逃出方法，可以这样写：</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716105829050.png" alt="image-20210716105829050" style="zoom:33%;"><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716110045243.png" alt="image-20210716110045243" style="zoom:33%;"><p><strong>参数设置</strong></p><p>在 JDK6u23 版本之后，Hotspot 中默认就已经开启了逃逸分析。如果使用的是较早的版本，开发人员则可以通过</p><ul><li>选项“-XX: + DoEscapeAnalysis“显式开启逃逸分析</li><li>通过选项“-XX:+ PrintEscapeAnalysis“看逃逸分析的筛选结果。</li></ul><p><strong>结论：</strong></p><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><h3 id="逃逸分析：代码优化"><a href="#逃逸分析：代码优化" class="headerlink" title="逃逸分析：代码优化"></a>逃逸分析：代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li><strong>栈上分配</strong>。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中</li></ul><h4 id="代码优化之栈上分配"><a href="#代码优化之栈上分配" class="headerlink" title="代码优化之栈上分配"></a>代码优化之栈上分配</h4><p>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成上分配。分配完成后，继续在调用内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p>常见的上分配的场景</p><ul><li>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</li></ul><h4 id="代码优化之同步省略（消除）"><a href="#代码优化之同步省略（消除）" class="headerlink" title="代码优化之同步省略（消除）"></a>代码优化之同步省略（消除）</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能</p><p>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断<strong>同步块所使用的锁对象是否只能够被一个线程访问</strong>而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<strong>锁消除</strong></p><p>如下代码：</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111230457.png" alt="image-20210716111230457" style="zoom:33%;"><p>代码中对 hollis 这个对象进行加锁，但是 hollis 对象的生命周期只在 f（）方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉。优化成：</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111326098.png" alt="image-20210716111326098" style="zoom:33%;"><h4 id="代码优化之标量替换"><a href="#代码优化之标量替换" class="headerlink" title="代码优化之标量替换"></a>代码优化之标量替换</h4><p>标量（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate), Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JVM 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111609911.png" alt="image-20210716111609911" style="zoom:33%;"><p>以上代码经过标量替换后，就会变成：</p><img src="/2021/07/16/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88-%E5%A0%86%EF%BC%89/image-20210716111643799.png" alt="image-20210716111643799" style="zoom:33%;"><p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为旦不需要创建对象了，那么就不再需要分配堆内存了</p><p>标量替换为栈上分配提供了很好的基础。</p><p><strong>标量替换参数设置</strong></p><p>参数 XX: +ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p><h3 id="逃逸分析小结：逃逸分析并不成熟"><a href="#逃逸分析小结：逃逸分析并不成熟" class="headerlink" title="逃逸分析小结：逃逸分析并不成熟"></a>逃逸分析小结：逃逸分析并不成熟</h3><ul><li>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法<strong>保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li><li>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取決于 JVM 设计者的选择。据我所知，Oracle Hotspot JVM 中并未这么做，这一点在逃逸分析相关的文档里已经说明，所以可以明确所有的对象实例都是创建在堆上。</li><li>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是， intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</li></ul><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>年轻代是对象的延生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从 Survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。</p><p>当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 Minor GC。当 GC 发生在老年代时则被称为 Major GC 或者 Full GC。一般的，Minor GC 的发生频率要比 Major GC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区</title>
      <link href="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
      <url>/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630191719146.png" alt="image-20210630191719146" style="zoom: 50%;"><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630191758617.png" alt="image-20210630191758617" style="zoom: 50%;"><p>运行时数据区结构图：灰色的表示单独线程私有，红色的为多个线程共享</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行。</p><p>Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。</p><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul><p>操作系统负责所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，他会调用Java线程中的run（）方法。</p><p>如果你使用 jconsole 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用 public static void main (String []）的 main 线程以及所有这个 maih 线程自己创建的线程。</p><p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li>虚拟机线程：这种线程的操作是需要 JVM 达到安全点会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆オ不会变化。这种线程的执行类型包括”stop-the-world“的垃圾收集，线程收集，线程挂起以及偏向锁撤销。</li><li>周期任务线程：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li>GC 线程：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li>编译线程：这种线程在运行时会将字节码编译成到本地代码。</li><li>信号调度线程：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li></ul><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><p>程序计数器又叫PC寄存器（Program Counter Register）</p><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630195700935.png" alt="image-20210630195700935" style="zoom:50%;"><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在 JVM 规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址：或者，如果是在执行 native 方法，则是未指定值（undefined）。</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依个计数器来完成</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li><li>它是唯一一个在 Java 虚拟机规范中没有规定任何 outofmemoryerror情况的区域</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630195745436.png" alt="image-20210630195745436" style="zoom:50%;"><p>PC寄存器用来存储指向下一条指令的地址，由执行引擎读取下一条指令。</p><h3 id="两个常见的问题"><a href="#两个常见的问题" class="headerlink" title="两个常见的问题"></a>两个常见的问题</h3><ul><li><p>使用PC寄存器存储字节码指令地址有什么用？<br>为什么使用PC寄存器记录当前线程的执行地址？</p><ul><li>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</li><li>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</li></ul></li><li><p>PC寄存器为什么被设定为线程私有</p><ul><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和帧，程序计数器在各个线程之间互不影响。</li></ul></li></ul><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>虚拟机栈出现的背景</p><ul><li>为了跨平台</li></ul></li><li><p>优缺点</p><ul><li>指令集小，编译器容易实现</li><li>性能下降，实现同样的功能需要更多的指令</li></ul></li><li><p>内存中的栈与堆</p><ul><li>栈是运行时的单位，堆是存储的单位</li><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解的是数据存储的问题，即数据怎么放、放在哪儿。</li></ul></li><li><p>虚拟机栈基本内容</p><ul><li><p>Java虚拟机栈是什么</p><ul><li>Java 虚拟机（Java virtua Machine Stack），早期也叫 Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用</li><li>是线程私有的</li></ul></li><li><p>生命周期</p><ul><li>和线程一致</li></ul></li><li><p>作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回</li></ul></li><li><p>栈的特点（优点）</p><ul><li>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器</li><li>JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进栈；执行结束后得出栈工作</li><li>对于栈来说不存在垃圾回收问题</li></ul></li><li><p>面试题：开发中遇到的异常有哪些</p><ul><li>栈中可能出现的异常</li><li>Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的<ul><li>如果采用固定大小的 Java 虚拟机，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机允许的最大容量，Java 虚拟机将会抛出一个  Stackoverflowerror 异常。如图</li><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630200412469.png" alt="image-20210630200412469" style="zoom:50%;"></li><li>如果 Java 虚拟机可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个 ourtofmemoryerror 异常</li></ul></li></ul></li></ul></li></ul><h3 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h3><p>栈中存储什么</p><ul><li>每个线程都有自己的栈，栈中的数据都是以栈帧（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li></ul><p>栈运行原理</p><ul><li>JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。</li><li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为当前帧（Current Frame），与当前栈帧相对应的方法就是当前方法（Current  Method），定义这个方法的类就是当前类（Current Class）。</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</li><li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</li><li>不同线程中所包含的帧是不允许存在相互引用的，即不可能在一个帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前帧，使得前一个帧重新成为当前栈帧</li><li>Java 方法<strong>有两种返回函数的方式，一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出。</strong></li></ul><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><h4 id="局部变量表（Local-Variables"><a href="#局部变量表（Local-Variables" class="headerlink" title="局部变量表（Local Variables)"></a><strong>局部变量表</strong>（Local Variables)</h4><ul><li><p>基本概念</p><ul><li>局部变量表也被称之为局部变量数组或本地变量表</li><li>定义为一个<strong>数字数组</strong>，主要用于存储<strong>方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及  returnAddress 类型。</strong></li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题</li><li>局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的</li><li>方法嵌套调用的次数由栈的大小決定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的空间，导致其嵌套调用次数就会少。</li><li>局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li><li><p>slot</p><ul><li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束</p></li><li><p>局部变量表，最基本的存储单元是 Slot（变量槽）</p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference), returnaddress 类型的变量。</p></li><li><p>在局部变量表里，32 位以内的类型只占用一个 slot（包括returnaddress 类型）,64 位的类型（long 和 double）占用两个 slot</p><ul><li>byte、short、char 在存储前被转换为 int, boolean 也被转换为 int,0 表示 false，非 0 表示 true。</li><li>long 和 double 则占据两个 slot。</li></ul></li><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问素引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个<strong>实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个 slot 上</strong></p></li><li><p>如果需要访问局部变量表中个 64bit 的局部变量值时，只需要使用前一个素引即可。（比如：访问 long 或 doublea 类型变量）</p></li><li><p>如果<strong>当前帧是由构造方法或者实例方法创建的，那么该对象引用 this 将会存放在 index 为 0 的 slot 处，</strong>其余的参数按照参数表顺序继续排列。</p></li></ul></li><li><p>slot的重复利用</p><ul><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630202519548.png" alt="image-20210630202519548" style="zoom: 44%;"></li><li>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的的</li></ul></li><li><p>静态变量与局部变量的对比</p><ul><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li><strong>我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值</strong>。</li><li>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一定义了局部变量则必须人为的初始化，否则无法使用。</li></ul></li><li><p>补充说明</p><ul><li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</li><li>局部变量表<strong>中的变量也是重要的垃圾回收根节</strong>点，只要被局部变量表中直接或间接引用的对象都不会被回收</li></ul></li></ul><h4 id="操作数栈（Operand-Stack-（或表达式栈）"><a href="#操作数栈（Operand-Stack-（或表达式栈）" class="headerlink" title="操作数栈（Operand Stack)（或表达式栈）"></a><strong>操作数栈（</strong>Operand Stack)（或表达式栈）</h4><ul><li><p>基本概念</p><ul><li><p>每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出（Last-In First-Out）的操作数栈，也可以称之为表达式栈（Expression Stack)</p></li><li><p>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据,即入(push)/出栈(pop）</p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul></li></ul></li><li><p>操作数栈</p><ul><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630203203881.png" alt="image-20210630203203881" style="zoom:40%;"></li><li>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</li><li>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</li><li>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 code 属性中，为 max stack 的值</li><li>栈中的任何一个元素都是可以任意的 Java 数据类型</li><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li><li>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入（push）和出（pop）操作来完成一次数据访问</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新 PC 寄存器中下一条需要执行的字节码指令</li><li>操作数中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</li><li>另外，我们说 Java <strong>虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong></li></ul></li><li><p>栈顶缓存技术（Top-of-Stack  Cashing）</p><ul><li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧湊，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数</li><li>由于操作数是存储在内存中的,因此频繁地执行内存读/写操作必然会影 响执行速度。为了解决这个问题，Hotspot JVM 的设计者们提出了顶缓存（TS, Top-of- Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中,以此降低对内存的读/写次数，提升执行引擎的执行效率</li></ul></li></ul><h4 id="动态链接（Dynamic-Linking-（或指向运行时常量池的方法引用）"><a href="#动态链接（Dynamic-Linking-（或指向运行时常量池的方法引用）" class="headerlink" title="动态链接（Dynamic Linking)（或指向运行时常量池的方法引用）"></a><strong>动态链接（Dynamic Linking)（或指向运行时常量池的方法引用）</strong></h4><ul><li><img src="/2021/07/15/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/image-20210630204322351.png" alt="image-20210630204322351" style="zoom:40%;"></li><li><p>每一个帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p></li><li><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</p></li><li><p>为什么需要常量池？</p><ul><li>常量池的作用，就是为了提供一些符号和常量，便于指令的识别</li></ul></li><li><p>class文件中的常量池进入方法区就成了运行时常量池</p></li></ul><h5 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h5><h6 id="方法的绑定"><a href="#方法的绑定" class="headerlink" title="方法的绑定"></a>方法的绑定</h6><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。</p><ul><li><p>静态链接：</p><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情況下将调用方法的符号引用转换为直接引用的过程称之为静态链接。</p></li><li><p>动态链接：</p><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。</p></li></ul><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</strong></p><ul><li><p>早期绑定：</p><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p></li><li><p>晚期绑定：</p><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p></li></ul><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p><p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p><h6 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h6><ul><li>非虚方法：如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li><strong>静态方法、私有方法、final 方法、实例构造器、父类方法</strong>都是非虚方法</li><li>其他方法称为虚方法</li></ul><p><strong>非虚方法在类加载的解析阶段就可以进行解析。</strong></p><p>虚拟机中提供了以下几条方法调用指令：</p><ul><li>普通调用指令：</li></ul><ol><li>Invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>Invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本 </li><li>Invokevirtual: 调用所有虚方法 </li><li>Invokeinterface：调用接口方法</li></ol><ul><li>动态调用指令</li></ul><ol start="5"><li>Invokedynamic：动态解析出需要用的方法，然后执行</li></ol><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（final 修饰的除外）称为虚方法。</p><p>关于Invokedynamic指令：</p><ul><li>JVM 字节码指令集一直比较稳定，一直到 Java7 中才増加了一个 invokedynamic 指令，这是 Java 为了实现「动态类型语言」支持而做的一种改进。</li><li>但是在 Java7 中并没有提供直接生成 invokedynamic：指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</li><li>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 台的动态语言的编译器。</li></ul><p>动态类型语言和静态类型语言</p><ul><li>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言</li><li>说的再直白一点就是，静态类型语言是判断变量自身的类型信息：动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</li></ul><h6 id="方法重写的本质"><a href="#方法重写的本质" class="headerlink" title="方法重写的本质"></a>方法重写的本质</h6><p>Java 语言中方法重写的本质：</p><ol><li><p>找到操作数顶的第一个元素所执行的对象的实际类型，记作 C</p></li><li><p>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结東；如果不通过，则返回 java.lang. IllegalAccesserror 异常。</p></li><li><p>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</p></li><li><p>如果始终没有找到合适的方法，则抛出 java.lang. AbstractMethodError 异常。</p></li></ol><p>IllegalAccessError 介绍：</p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h6 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h6><ul><li><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表（virtual method tabe)（非虚方法不会出现在中）来实现。使用索引表来代替找。</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>那么虚方法表什么时候被创建？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p></li></ul><h4 id="方法返回地址（Return-Address-（或方法正常退出或者异常退出的定义）"><a href="#方法返回地址（Return-Address-（或方法正常退出或者异常退出的定义）" class="headerlink" title="方法返回地址（Return Address)（或方法正常退出或者异常退出的定义）"></a>方法返回地址（Return Address)（或方法正常退出或者异常退出的定义）</h4><ul><li><p>存放调用该方法的pc寄存器的值。</p></li><li><p>一个方法的结束，有两种方式：</p><p>​    正常执行完成</p><p>​    出现未处理的异常，非正常退出</p></li><li><p>无论通过哪种方式退出，<strong>在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定，帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去</p></li><li><p><strong>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</strong></p></li></ul><p>当一个方法开始执行后，只有两种方式可以退出这个方法</p><p>1、执行引擎遇到任一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称正常完成出口</p><ul><li>一个方法在正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含 i return（当返回值是 boolean、byte、char、 shorth 和 int 类型时使用）、lreturn、freturn、dreturn 以及 areturn，另外还有一个 return 指令供声明为 void 的方法、实例初始化方法、类和接口的初始化方法使用。</li></ul><p>2、在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。简称异常完成出口。</p><ul><li>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码。</li></ul><p>本质上，方法的退出就是当前帧出的过程。此时，需要恢复上层防法的局部变量表、操作数、将返回值压入调用者栈帧的操作数、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p><h4 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h4><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：再谈类的加载器</title>
      <link href="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="01-概述"><a href="#01-概述" class="headerlink" title="01-概述"></a>01-概述</h2><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>Class Loader 是Java的核心组件，所有的 Class 都是由 Classloader 进行加载的，Classloader 负责通过各种方式将 Class 信息的二进制数据流读入 JVM 内部，转换为一个与目标类对应的 java.lang. Class 对象实例。然后交给Java 虚拟机进行链接、初始化等操作。因此，Classloader 在整个装载阶段，只能影响到类的加载，而无法通过 ClassLoader 去改变类的链接和初始化行为。至于它是否可以运行，则由 Execution Engine 决定。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194021203.png" alt="image-20210627194021203" style="zoom:33%;"><p>类加载器最早出现在Java1.0 版本中，那个时候只是单纯地为了满足Java Applet 应用而被研发出来。但如今类加载器却在 OSGi、字节码加解密领域大放异彩。这主要归功于Java 虚拟机的设计者们当初在设计挙加载器的时候，并没有考虑将它绑定在内部，这样做的好处就是能够更加灵活和动态地执行类加载操作。</p><h3 id="1-大厂面试题"><a href="#1-大厂面试题" class="headerlink" title="1-大厂面试题"></a>1-大厂面试题</h3><p>蚂蚁金服：</p><p>深入分析 Classloader，双亲委派机制</p><p>类加载器的双亲委派模型是什么？</p><p>一面：双亲委派机制及使用原因</p><p>百度：</p><p>都有哪些类加载器，这些类加载器都加载哪些文件？</p><p>手写一个类加载器 Demo</p><p>Class 的 forname (“java.lang. String“）和 Class 的 getClassLoader（）的 loadClass (“java.1ang. String“）有什么区别？</p><p>腾讯：</p><p>什么是双亲委派模型？</p><p>类加载器有哪些？</p><p>小米</p><p>双亲委派模型介绍一下</p><p>滴滴：</p><p>简单说说你了解的类加载器</p><p>一面：讲一下双亲委派模型，以及其优点</p><p>字节跳动</p><p>什么是类加载器，类加载器有哪些？</p><p>京东</p><p>类加载器的双亲委派模型是什么？</p><p>双亲委派机制可以打破吗？为什么</p><h3 id="2-类的加载分类"><a href="#2-类的加载分类" class="headerlink" title="2-类的加载分类"></a>2-类的加载分类</h3><p><strong>显示加载VS隐示加载</strong></p><p>Class 文件的显式加载与隐式加载的方式是指 JVM 加载 class 文件到内存的方式。</p><p><strong>显式加载</strong>指的是在代码中通过调用 ClassLoader 加载 class 对象，如直接使用 <code>Class. forName (name）</code>或 <code>this.GetClass().GetClassLoader().loadClass()</code>加载 class 对象。</p><p><strong>隐式加载</strong>则是不直接在代码中调用 Classloader 的方法加载 class 对象，而是通过虚拟机自动加载到内存中，如在加载某个类的 class 文件时，该类的 class 文件中引用了另外一个类的对象，此时额外引用的类将通过JVM 自动加载到内存中。</p><p>在日常开发以上两种方式一般会混合使用。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627194649610.png" alt="image-20210627194649610" style="zoom: 25%;"><h3 id="3-类加载器的必要性"><a href="#3-类加载器的必要性" class="headerlink" title="3-类加载器的必要性"></a>3-类加载器的必要性</h3><p>一般情況下，java 开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li>避免在开发中遇到 java.lang. ClassNotFoundException 异常或 java.lang. NoClassDeffoundError 异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解问题</li><li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li><li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li></ul><h3 id="4-命名空间"><a href="#4-命名空间" class="headerlink" title="4-命名空间"></a>4-命名空间</h3><ol><li>何为类的唯一性？</li></ol><p>对于任意一个类，都需要由加载<strong>它的类加载器和这个类本身</strong>一同确认其在Java 虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个 Class 文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等</p><ol><li>命名空间</li></ol><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li><li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><h3 id="5-类加载机制的基本特征"><a href="#5-类加载机制的基本特征" class="headerlink" title="5-类加载机制的基本特征"></a>5-类加载机制的基本特征</h3><p>通常类加载机制有三个基本特征：</p><ul><li>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK 内部的 ServiceProvider/ ServiceLoader 机制，用户可以在标准 API 框架上，提供自己的实现，JDK 也需要提供些默认的参考实现。例如，Java 中 JNDI、JDBC、文件系统、Cipher 等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li><li>可见性，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li><li>单一性，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li></ul><h3 id="6-类加载器之间的关系"><a href="#6-类加载器之间的关系" class="headerlink" title="6-类加载器之间的关系"></a>6-类加载器之间的关系</h3><p><strong>Launcher.java类：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Launcher</span> </span>&#123;</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Launcher.ExtClassLoader var1;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> InternalError( <span class="string">&quot;Could not create extension class loader&quot;</span> , var10);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span> .loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError( <span class="string">&quot;Could not create application class loader&quot;</span> , var9);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Thread.currentThread().setContextClassLoader( <span class="keyword">this</span> .loader); </span><br><span class="line"></span><br><span class="line">         …… </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>分析： </p><p><strong>1、验证扩展类加载器的父类是null</strong> </p><p>先看：</p><p> <code>var1 = Launcher.ExtClassLoader.getExtClassLoader();</code> </p><p>获取到扩展类加载器，点击该方法往里面追溯，在找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Launcher.ExtClassLoader(var0);</span><br></pre></td></tr></table></figure><p>我们在点击该方法往里面追溯，在找到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">super (getExtURLs(var1), (ClassLoader) null , Launcher.factory);</span><br></pre></td></tr></table></figure><p>然后点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="params"><span class="function">            URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>点击其中的parent就是null，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> ( checkCreateClassLoader (), parent);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>点击其中的parent就是null，我们点击this，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> . parent = parent; </span><br></pre></td></tr></table></figure><p>由于parent就是null，所以扩展类加载器的父类是null ，也就是引导类加载器，因此我们调用获取扩展类加载器父类的方法获得的结果是null</p><p> <strong>2、验证系统类加载器的父类是扩展类加载器</strong> </p><p>先看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> .loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br></pre></td></tr></table></figure><p>获取到系统类加载器，点击该方法往里面追溯，在找到：</p><p> <code>return new Launcher.AppClassLoader(var1x, var0);</code>  </p><p>其中var0就是扩展类加载器，点击AppClassLoader，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">   <span class="keyword">super</span> (var1, var2, Launcher.factory);</span><br><span class="line">   <span class="keyword">this</span> .ucp.initLookupCache( <span class="keyword">this</span> );</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>其中var2就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URLClassLoader</span><span class="params">(URL[] urls, ClassLoader parent,</span></span></span><br><span class="line"><span class="params"><span class="function">            URLStreamHandlerFactory factory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SecureClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span> (parent); </span><br></pre></td></tr></table></figure><p>里面的parent就是扩展类加载器，我们点击super，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> ( checkCreateClassLoader (), parent);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>里面的parent就是扩展类加载器，我们点击this，往里面追溯，在找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ClassLoader</span><span class="params">(Void unused, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span> . parent = parent; </span><br></pre></td></tr></table></figure><p>由于parent就是扩展类加载器，所以系统类加载器的父类是扩展类加载器 ，因此我们调用获取系统类加载器父类的方法获得的结果是扩展类加载器</p><p><strong>3、当前线程上下文的ClassLoader就是系统类加载器</strong> </p><p><code>Thread.currentThread().setContextClassLoader(this.loader)</code> 就是将系统类加载器设置为当前线程的上下文加载器，所以<code>Thread.currentThread().getContextClassLoader()</code> 获取到的就是系统类加载器</p><h2 id="02-复习"><a href="#02-复习" class="headerlink" title="02-复习"></a>02-复习</h2><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-defined Classloader)</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java 虚拟机规范却没有这么定义，而是将所有派生于抽象类 Classloader 的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627203246891.png" alt="image-20210627203246891" style="zoom:33%;"><p>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</p><p>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</p><p>下面的代码解释了包含的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">// 父类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent=parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClassLoader</span><span class="params">(ClassLoader parent)</span></span>&#123;<span class="comment">// parent=new ParentClassLoader();</span></span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p><h3 id="1-引导类加载器"><a href="#1-引导类加载器" class="headerlink" title="1-引导类加载器"></a>1-引导类加载器</h3><ul><li>这个类加载使用C/C++语言实现的,嵌套在JVM内部</li><li>它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容)。用于提供JVM 自身需要的类。</li><li>并不继承自 java.lang.Classloader，没有父加载器。</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为 java、javax、sun 头的类</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li></ul><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204027345.png" alt="image-20210627204027345" style="zoom:33%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627204324564.png" alt="image-20210627204324564" style="zoom:33%;"><p>使用-XX:+TraceClassLoading参数得到。</p><p>启动类加载器使用C++编写的？yes！</p><ul><li>C/C++指针函数&amp;函数指针、C++支持多继承、更加高效</li><li>Java：由 C++演变而来，(C++) –版，单继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;*******启动类加载器********&quot;</span>);</span><br><span class="line">    URL[] urLs = Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line">    <span class="keyword">for</span> (URL urL : urLs) &#123;</span><br><span class="line">        System.out.println(urL.toExternalForm());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*******启动类加载器********</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/resources.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/rt.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/sunrsasign.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jsse.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jce.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/charsets.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/lib/jfr.jar</span><br><span class="line">file:/Library/Java/JavaVirtualMachines/jdk1<span class="number">.8</span><span class="number">.0_251</span>.jdk/Contents/Home/jre/classes</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ClassLoader classLoader=java.security.Provider.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-扩展类加载器"><a href="#2-扩展类加载器" class="headerlink" title="2-扩展类加载器"></a>2-扩展类加载器</h3><ul><li>Java 语言编写，由sun.misc. Launcher$ExtClassLoader 实现。</li><li>继承于 Classloader 类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库,或从]DK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png" alt="image-20210627205013180" style="zoom: 50%;"><h3 id="3-系统类加载器"><a href="#3-系统类加载器" class="headerlink" title="3-系统类加载器"></a>3-系统类加载器</h3><ul><li>Java 语言编写，由 sun.misc. Launcher$AppClassLoader 实现</li><li>继承于 Classloader 类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量 classpath 或系统属性java.class.path 指定路径下的类库应用程序中的类加载器默认是系统类加载器。它是用户自定义类加载器的默认父加载器</li><li>通过 Classloader 的 getsystemClassloader（）方法可以获取到该类加载器</li></ul><h3 id="4-用户自定义类加载器"><a href="#4-用户自定义类加载器" class="headerlink" title="4-用户自定义类加载器"></a>4-用户自定义类加载器</h3><ul><li>在Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现Java 语言强大生命力和巨大魅力的关键因素之一便是，Java 开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR 包，也可以是网络上的远程资源。</li><li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的 OSGI 组件框架，再如  Eclipse 的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，自定义加载器能够实现应用隔离，例如 Tomcat, Spring 等中间件和组件框架都在内部实现了自定义的加载器,并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改 C/C++程序就能为其新功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。自定义类加载器通常需要继承于 Classloader。</li></ul><h2 id="03-测试不同的类的加载器"><a href="#03-测试不同的类的加载器" class="headerlink" title="03-测试不同的类的加载器"></a>03-测试不同的类的加载器</h2><p>每个 Class 对象都会包含一个定义它的 ClassLoader 的一个引用。</p><p>获取 ClassLoader 的途径</p><p>获得当前类的 Classloade：<code>clazz. GetClassLoader ()</code></p><p>获得当前线程上下文的 ClassLoader:<code>Thread.currenThread (). GetContextClassLoader ()</code></p><p>获得系统的 Classloader: <code>ClassLoader.GetSystemClassLoader ()</code></p><p><strong>说明：</strong></p><p>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加载器，引导类加载器是使用 C++语言编写而成的，而另外两种类加载器则是使用 Java 语言编写而成的。由于引导类加载器压根儿就不是一个 Java 类，因此在 Java 程序中只能打印出空值。</p><p>数组类的 Class 对象，不是由类加载器去创建的，而是在 Java 运行期 JVM 根据需要自动创建的。对于数组类的类加载器来说，是通过 <code>Class. GetClassLoader()</code>返回的，<strong>与数组当中元素类型的类加器</strong>是一样的：如果数<strong>组当中的元素类型是基本数据类型，数组类是没有类加载器的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取系统类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc.Launcher$ExtClassLoader@511d50c0</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line">        System.out.println(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############################</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ClassLoader classLoader = Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);<span class="comment">//null</span></span><br><span class="line">            ClassLoader currentClassLoader = Class.forName(<span class="string">&quot;com.liuermeng.jvm.chapter04.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(currentClassLoader);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">            <span class="comment">// 关于数组类型的加载:使用的类的加载器与数组元素的加载器相同</span></span><br><span class="line">            String[] arrStr=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrStr.getClass().getClassLoader());<span class="comment">//null</span></span><br><span class="line">            ClassLoaderTest1[] arrClt=<span class="keyword">new</span> ClassLoaderTest1[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrClt.getClass().getClassLoader());<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] arri=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arri.getClass().getClassLoader());<span class="comment">//null 基本数据类型，不需要类的加载器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04-ClassLoader源码解析"><a href="#04-ClassLoader源码解析" class="headerlink" title="04-ClassLoader源码解析"></a>04-ClassLoader源码解析</h2><p><strong>ClassLoader与现有类加载器的关系：</strong></p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628144346523.png" alt="image-20210628144346523" style="zoom:33%;"><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h3 id="1-ClassLoader的主要方法"><a href="#1-ClassLoader的主要方法" class="headerlink" title="1-ClassLoader的主要方法"></a>1-ClassLoader的主要方法</h3><p><strong>抽象类ClassLoader的主要方法：（内部没有抽象方法）</strong></p><p><code>public final ClassLoader getParent()</code> 返回该类加载器的超类加载器</p><p><code>public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException</code> 加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回ClassNotFoundException异常。该方法中的逻辑就是<strong>双亲委派模式</strong>的实现。</p><p><code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code> 查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM 鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被 loadClass（）方法调用。</p><ul><li>在 JDK1.2 之前，在自定义类加载时，总会去继承 ClassLoader 类并重写 loadClass 方法，从而实现自定义的类加载类。但是在 JDK1.2 之后已不再建议用户去覆盖 loadClass（）方法，而是建议把自定义的类加载逻辑写在  findClass（）方法中，从前面的分析可知findClass（）方法是在 loadClass（）方法中被调用的，当loadClass（）方法中父加载器加载失败后，则会调用自己的 findClass（）方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li><li>需要注意的是 ClassLoader 类中并没有实现 findClass（）方法的具体代码逻辑，取而代之的是抛出Classnotfoundexception 异常，同时应该知道的是 findClass 方法通常是和 defineClass 方法起使用的。一般情况下，在自定义类加载器时，会直接覆盖 Classloader 的 findClass方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defingClass（）方法生成类的Class对象。</li></ul><p><code>Protected final Class&lt;?&gt; defineClass(String name, byte[] b,int off,int len)</code> 根据给定的字节数组 b 转换为 class 的实例，off 千和 len 参数表示实际 Class 信息在 byte 数组中的位置和长度，其中 byte 数组 b 是 Classloader 从外部获取的。这是受保护的方法，只有在自定义 ClassLoader 子类中可以使用。</p><ul><li>defineClass（）方法是用来将 byte 字节流解析成 JVM 能够识别的 Class 对象（ClassLoader 中已实现该方法逻辑），通过这个方法不仅能够通过 class 文件实例化 class对象，也可以通过其他方式实例化 class 对象，如通过络收一个类的字节码，然后转换 byte 字节流创建对应的 Class 对象。</li><li>defineClass（）方法通常与 findClass（）方法一起使用，一般情況下，在自定义类加载器时，会直接覆盖Classloader 的 findClass（）方法并编写加载规则，取得要加載类的字节码后转换成流，然后调用 defineclass（）方法生成类的 Class 对象</li></ul><p><code>protected final void resolveClass(Class&lt;?&gt; c)</code> 链接指定的一个Java 类。使用该方法可以使用类的 Class 对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><p><code>protected final Class&lt;?&gt; findLoadedClass(String name)</code>  查找名称为 name 的己经被加载过的类，返回结果为 java.lang.Class 类的实例。这个方法是 final 方法，无法被修改。</p><p><code>private final ClassLoader parent</code>  它也是一个 Classloader 的实例，这个字段所表示的 Classloader 也称为这个 Classloader 的双亲。在类加载的过程中，Classloader 可能会将某些请求交予自己的双亲处理</p><p><strong>loadClass()剖析</strong></p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.liuermeng.User&quot;</span>);</span><br></pre></td></tr></table></figure><p>涉及到如下方法的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)<span class="comment">// resolve：true-加载class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123; <span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// 首先，在缓存中判断是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果未加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">// 获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// parent为null：父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; <span class="comment">// 当前类的加载器的父类加载器未加载此类</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findClass（）</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">// 是否进行解析</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SecureClassLoader与URLClassLoader"><a href="#2-SecureClassLoader与URLClassLoader" class="headerlink" title="2-SecureClassLoader与URLClassLoader"></a>2-SecureClassLoader与URLClassLoader</h3><p>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对 class 源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联。</p><p>前面说过，Classloader 是一个抽象类，很多方法是空的没有实现，比如 findClass（）、findResource（）等。而 URLClassLoader 这个实现类为这些方法提供了具体的实现。并新増了 URLClassPath 类协助取得 Class 字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findcass（）方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210627205013180.png" alt="image-20210627205013180" style="zoom:50%;"><h3 id="3-ExtClassLoader与AppClassLaoder"><a href="#3-ExtClassLoader与AppClassLaoder" class="headerlink" title="3-ExtClassLoader与AppClassLaoder"></a>3-ExtClassLoader与AppClassLaoder</h3><p>了解完 URLClassLoader 后接着看看剩余的两个类加载器，即拓展类加载器 ExtClassLoader 和系统类加载器  AppClassLoader，这两个类都继承自 URLClassLoader, 是sun.misc. Launcher 的静态内部类。 sun.misc. Launcher 主要被系统用于启动主应用程序，ExtClassLoader 和 AppClassLoader都是由 sun.misc. Launcher 创建的，其类主要类结构如下：</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150519826.png" alt="image-20210628150519826" style="zoom:50%;"><p>ExtClassLoader 并没有重写 loadClass（）方法，这足矣说明其遵循双亲委派模式，而 AppClassLoader 重载了 loadClass（）方法，但最终调用的还是父类 loadClass（）方法，因此依然遵守双亲委派模式。</p><h3 id="4-Class-forName-与ClassLoader-loadClass"><a href="#4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4-Class.forName()与ClassLoader.loadClass()"></a>4-Class.forName()与ClassLoader.loadClass()</h3><p>Class.forName ()：是一个静态方法，最常用的是 Class.forName (String className）；根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时，会执行类的初始化。如：Class.forName (“com.liuermeng.Helloworld”)</p><p>ClassLoader.loadClass ()：这是一个实例方法，需要一个 CLassLoader 对象来调用该方法。该方法将Class 文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象，所以可以根据需要指定使用哪个类加载器。如：Classloader c1=……;  c1.loadClass (“com.liuermeng.Helloworld”);</p><h2 id="05-双亲委派机制"><a href="#05-双亲委派机制" class="headerlink" title="05-双亲委派机制"></a>05-双亲委派机制</h2><h3 id="1-定义与本质"><a href="#1-定义与本质" class="headerlink" title="1-定义与本质"></a>1-定义与本质</h3><p>类加载器用来把类加载到Java 虚拟机中。从 JDK1.2 版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证 Java 平台的安全。</p><ol><li><strong>定义</strong></li></ol><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><ol start="2"><li><strong>本质</strong></li></ol><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，オ会由系统类加载器或自定义的类加载器进行加载。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150910750-4935529.png" alt="image-20210628150910750" style="zoom:33%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628150946026-4935529.png" alt="image-20210628150946026" style="zoom: 33%;"><h3 id="2-优势与劣势"><a href="#2-优势与劣势" class="headerlink" title="2-优势与劣势"></a>2-优势与劣势</h3><ol><li><strong>双亲委派机制优势</strong></li></ol><ul><li><p>避免类的重复加载，确保一个类的全局唯一性</p><p>Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子 Classloader 再加载一次。</p></li><li><p>保护程序安全，防止核心 API 被随意改</p></li></ul><ol start="2"><li><strong>代码支持</strong></li></ol><p>双亲委派机制在 java.lang.Classloader.loadClass (String, boolean）接口中体现。该接口的逻辑如下：</p><p> (1) 先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p> (2) 判断当前加载器的父加载器是否为空，如果不为空，则调用 parent.loadClass (name, false）接口进行加载。</p><p> (3) 反之，如果当前加载器的父类加载器为空，则调用 findBootStrapClassOrNul (name）接口，让引导类加载器进行加载。</p><p> (4) 如果通过以上 3 条路径都没能成功加载，则调用 findClass (name）接口进行加载。该接口最终会调用 java.lang.Classloader 接口的 defineClass 系列的 native 接口加载目标Java 类。双亲委派的模型就隐藏在这第 2 和第 3 步中。</p><ol start="3"><li><strong>举例</strong></li></ol><p>假设当前加载的是 java.lang.Object 这个类，很显然，该类属于JDK 中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载 java.lang.Object 时，JVM 默认会使用系统类加载器去加载，按照上面 4 步加载的逻辑，在第 1 步从系统类的缓存中肯定查找不到该类，于是进入第 2 步。由于系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第 1 步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第 2 步。扩展类的父加载器是 null, 因此系统调用 findclass (String），最终通过引导类加载器进行加载。</p><ol start="4"><li><strong>思考</strong></li></ol><p>如果在自定义的类加载器中重写 java.lang.Classloader.loadClass (String）或java.lang.ClassLoader.loadClass (String, boolean）方法，抹去其中的双亲委派机制，仅保留上面这 4 步中的第 1 步与第 4 步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK 还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.Classloader.defineClass (string, byte [], int, int,Protectiondomain）方法，而该方法会执行 preDefineClass（）接口，该接口中提供了对JDK 核心类库的保护。</p><ol start="5"><li><strong>双亲委托模式的弊端</strong></li></ol><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个 Classloader 的职责非常明确，但是同时会带来一个问题，即顶层的 Classloader 无法访问底层的 CLassloader 所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口该接口需要在应用类中得以实现，该接口述绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><ol start="6"><li><strong>结论</strong></li></ol><p>由于Java 虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而己。</p><p>比如在 Tomcat 中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet 规范推荐的一种做法。</p><h3 id="3-破坏双亲委派机制"><a href="#3-破坏双亲委派机制" class="headerlink" title="3-破坏双亲委派机制"></a>3-破坏双亲委派机制</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>双亲委派模型并不是一个具有强制性约的模型，而是Java 设计者推荐给开发者们的类加载器实现方式。</p><p>在Java 的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java 模块化出现为止，双亲委派模型主要出现过 3 次较大规模“被破坏”的情况。</p><h4 id="破坏双亲委派机制1"><a href="#破坏双亲委派机制1" class="headerlink" title="破坏双亲委派机制1"></a>破坏双亲委派机制1</h4><p>第一次破坏双亲委派机制：</p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一即JDK1.2 面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK1.2 之后才被引入，但是类加载器的概念和抽象类 java.lang.Classloader 则在Java 的第1个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免 loadClass（）被子类覆盖的可能性，只能在JDK1.2 之后的 java.lang.ClassLoader 中添加一个新的 protected 方法 findclass (），并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass（）中编写代码。上节我们已经分析过 loadClass（）方法，双亲委派的具体逻辑就实现在这里面，按照 loadClass（）方法的逻辑，如果父类加载失败，会自动调用自己的 findcass（）方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><h4 id="破坏双亲委派机制2"><a href="#破坏双亲委派机制2" class="headerlink" title="破坏双亲委派机制2"></a>破坏双亲委派机制2</h4><p>第二次破坏双亲委派机制：线程上下文类加载器</p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码那该怎么办呢？</p><p>这并非是不可能出现的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是Java 的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3 时加入到 rt.jar 的），肯定属于Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 Classpath 下的 JNDI 服务提供者接口（Service Provider Interface, SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？ (SPI：在Java 平台中，通常把核心类 rt.jar 中提供外部服务、可由应用层自行实现的接口称为 SPI)</p><p>为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context Classloader）</strong>。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader（）方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java 中涉及 SPI 的加载基本上都采用这种方式来完成，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。不过，当 SPI 的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在 JDK6 时，JDK 提供了 java.Util. ServiceLoader 类，以 META-INF/services 中的配置信息，辅以责任链模式，这才算是给 SPI 的加载提供了一种相对合理的解决方案。</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628160124899-4935529.png" alt="image-20210628160124899" style="zoom:33%;"><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><h4 id="破坏双亲委派机制3"><a href="#破坏双亲委派机制3" class="headerlink" title="破坏双亲委派机制3"></a>破坏双亲委派机制3</h4><p>第三次破坏双亲委派机制：</p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：<strong>代码热替换（Hot Swap）、模块热部署（Hot Deployment）</strong>等</p><p>IBM 公司主导的JSR-291（即 OSGi R4.2) 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索：</p><p>*<em>1) 将以 java. <em>开头的类，委派给父类加载器加载。</em></em></p><p><strong>2) 否则，将委派列表名单内的类，委派给父类加载器加载。</strong></p><ol start="3"><li><p>否则，将 Import 列表中的类，委派给 Export。这个类的 Bundle 的类加载器加载。</p></li><li><p>否则，查找当前 Bundle 的 Classpath，使用自己的类加载器加载。</p></li><li><p>否则，查找类是否在自己的 Fragment Bundle 中，如果在，则委派给 Fragment Bundle 的类加载器加载。</p></li><li><p>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载。</p></li><li><p>否则，类查找失败。</p></li></ol><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：</p><p>这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但<strong>这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p><p>正如：OSGi 中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为 OSGI 中对类加载器的运用是值得学习的，完全弄懂了 OSGi 的实现，就算是掌握了类加载器的精粹</p><h3 id="4-热替换的实现"><a href="#4-热替换的实现" class="headerlink" title="4-热替换的实现"></a>4-热替换的实现</h3><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了 PHP 源文件，这种改动就会立即生效，而无需重启 Web 服务器。</p><p>但对Java 来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加并重定义这个类。因此，在Java 中实现这一功能的一个可行的方法就是灵活运用 Classloader。</p><p>注意：由不同 Classloader 加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的 Classloader 加载同个类，在虚拟机内部，会认为这 2 个类是完全不同的。</p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628161157283-4935529.png" alt="image-20210628161157283" style="zoom: 25%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628162015161-4935529.png" alt="image-20210628162015161" style="zoom: 20%;"><h2 id="06-沙箱安全机制"><a href="#06-沙箱安全机制" class="headerlink" title="06-沙箱安全机制"></a>06-沙箱安全机制</h2><h3 id="1-JDK1-0时期"><a href="#1-JDK1-0时期" class="headerlink" title="1-JDK1.0时期"></a>1-JDK1.0时期</h3><p>在Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的 Java 实现中，安全依赖于沙箱（Sandbox）机制。如下图所示 JDK1.0 安全模型</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163159255-4935529.png" alt="image-20210628163159255" style="zoom: 25%;"><h3 id="2-JDK1-1时期"><a href="#2-JDK1-1时期" class="headerlink" title="2-JDK1.1时期"></a>2-JDK1.1时期</h3><p>JDK1.0 中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的 Java1.1 版本中，针对安全机制做了改进，増加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p><p>如下图所示JDK1.1 安全模型</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163255917-4935529.png" alt="image-20210628163255917" style="zoom:25%;"><h3 id="3-JDK1-2时期"><a href="#3-JDK1-2时期" class="headerlink" title="3-JDK1.2时期"></a>3-JDK1.2时期</h3><p>在Java1.2 版本中，再次改进了安全机制，増加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示 JDK1.2 安全模型</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163339056-4935529.png" alt="image-20210628163339056" style="zoom:25%;"><h3 id="4-JDK1-6时期"><a href="#4-JDK1-6时期" class="headerlink" title="4-JDK1.6时期"></a>4-JDK1.6时期</h3><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6)</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628163441756-4935529.png" alt="image-20210628163441756" style="zoom:25%;"><h2 id="07-自定义类的加载器"><a href="#07-自定义类的加载器" class="headerlink" title="07-自定义类的加载器"></a>07-自定义类的加载器</h2><ol><li><strong>为什么要自定义类加载器</strong>？</li></ol><ul><li>隔离加载类</li></ul><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的 jar 包不会影响到中间件运行时使用的 jar 包。再比如：Tomcat 这类 Web 应用服务器，内部自定义了好几种类加载器，用于隔离同一个 Web 应用服务器上的不同应用程序。</p><ul><li>修改类加载的方式</li></ul><p>类的加载模型并非强制，除 Bootstrap 外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p><ul><li>扩展加载源</li></ul><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p><ul><li>防止源码泄漏</li></ul><p>Java 代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p><ol start="2"><li><strong>常见的场景</strong></li></ol><ul><li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE 和 OSGi、JPMS 等框架。</p></li><li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码动态修改或者生成类型。</p></li></ul><ol start="3"><li><strong>注意</strong>：</li></ol><p>在一般情下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java 类型转换，则加载器反而容易产生不美好的事情。在做Java 类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><strong>实现方式</strong></li></ol><ul><li><p>Java 提供了抽象类 java.lang. Classloader，所有用户自定义的类加载器都应该继承 Classloader 类。</p></li><li><p>在自定义 Classloader 的子类时候，我们常见的会有两种做法：</p><ul><li><p>方式一：重写 loadClass（）方法</p></li><li><p>方式二：重写 findClass（）方法–&gt;推荐</p></li></ul></li></ul><ol start="2"><li><strong>对比</strong></li></ol><p>这两种方法本质上差不多，毕竟 loadClass（）也会调用 findClass (），但是从逻辑上讲我们最好不要直接修改 loadClass（）的内部逻辑。建议的做法是只在 findClass（）里重写自定义类的加载方法，根据参数指定类的名字，返回对应的 Class 对象的引用。</p><ul><li><p>loadClass（）这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。同时，也避免了自己重写loadClass（）方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p></li><li><p>当编写好自定义类加载器后，便可以在程序中调用 loadClass（）方法来实现类加载操作。</p></li></ul><ol start="3"><li><strong>说明</strong></li></ol><ul><li><p>其父类加载器是系统类加载器</p></li><li><p>JVM中的所有类加载都会使用 java.lang.ClassLoader.loadClass (String）接口（自定义类加载器并重写java.lang.ClassLoader.loadClass (String）接口的除外），连 JDK 的核心类库也不能例外。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String fileName=byteCodePath+className+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream bos= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(fileName));</span><br><span class="line">            bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>((len=bis.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                bos.write(data,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] byteCodes = bos.toByteArray();</span><br><span class="line"></span><br><span class="line">            Class&lt;?&gt; aClass = defineClass(<span class="keyword">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bos!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyClassLoader loader=<span class="keyword">new</span> MyClassLoader(<span class="string">&quot;/Users/liumeng/Desktop/&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz= loader.loadClass(<span class="string">&quot;User&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类加载器为&quot;</span>+clazz.getClassLoader().getClass().getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类加载器的父类加载器为&quot;</span>+clazz.getClassLoader().getParent().getClass().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加载此类的类加载器为com.liuermeng.jvm.classloader.MyClassLoader</span><br><span class="line">加载此类的类加载器的父类加载器为sun.misc.Launcher$AppClassLoader//我们并没有定义父类加载器，默认为系统类加载器</span><br></pre></td></tr></table></figure><h2 id="08-Java9新特性"><a href="#08-Java9新特性" class="headerlink" title="08-Java9新特性"></a>08-Java9新特性</h2><p>为了保证兼容性，JDK9 没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><ol><li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platformClassLoader）。可以通过 Classloaderl的新方法 getPlatformClassLoader（）来获取。</li></ol><p>JDK9 基于模块化进行构建 (原来的rt.jar和 tools.jar 被拆分成数十个 JMOD 文件）,其中的Java 类库就已天然地满足了可扩展的需求，那自然无须再保留<code>&lt;JAVA_HOME&gt; \liib\ext</code>目录, 此前使用这个 目录或者 java.ext.dirs 系统变量来扩展JDK 功能的机制已经没有继续存在的价值了</p><ol start="2"><li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。</li></ol><p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk. internall.loader.BuiltinClassLoader。</p> <img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628184815857-4935529.png" alt="image-20210628184815857" style="zoom:33%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185218382-4935529.png" alt="image-20210628185218382" style="zoom:33%;"><p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassloader 类的特定方法，那代码很可能会在 JDK9 及更高版本的 JDK 中崩溃。</p><ol start="3"><li><p>在Java9 中，类加载器有了名称。该名称在构造方法中指定，可以通过 getName（）方法来获取。平台类加载器的名称是 platform，应用类加载器的名称是 app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</p></li><li><p>启动类加载器现在是在 jvm 内部和 java 类库共同协作实现的类加载器（以前是c++实现），但为了与之前代码兼容在获取启动类加载器的场景中然会返回 null， 而不会得到 BootClassLoader 实例。</p></li><li><p>类加载的委派关系也发生了变动。</p></li></ol><p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><p>双亲委派模式示意图</p><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210628185505425-4935529.png" alt="image-20210628185505425" style="zoom: 25%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104356777-4935529.png" alt="image-20210629104356777" style="zoom: 50%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104427185-4935529.png" alt="image-20210629104427185" style="zoom:50%;"><img src="/2021/06/29/%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/image-20210629104449171-4935529.png" alt="image-20210629104449171" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码指令集与解析举例</title>
      <link href="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/"/>
      <url>/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当作最基本的执行模型来理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">  自动计算PC寄存器的值+1；</span><br><span class="line">  根据PC寄存器的指示位置，从字节码流中取出操作码；</span><br><span class="line">  if(字节码存在操作数)从字节码流中取出操作数；</span><br><span class="line">  执行操作码所定义的操作；</span><br><span class="line">&#125;while(字节码长度&gt;0)</span><br></pre></td></tr></table></figure><h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，<code>iload</code> 指令用于从局部变量表中加载 <code>int</code> 型的数据到操作数栈中，而 <code>fload</code> 指令加载的则是 <code>float</code> 类型的数据。</p><p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：</p><p>代表对 <code>int</code> 类型的数据操作，</p><p>l 代表 <code>1ong</code> </p><p>s 代表 <code>short</code> </p><p>b 代表 <code>byte</code> </p><p>c 代表 <code>char</code> </p><p>f 代表 <code>float</code> </p><p>d 代表 <code>double</code></p><p>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如 <code>arraylength</code> 指令，它没有代表数据类型的特殊字符，但</p><p>操作数永远只能是一个数组类型的对象。</p><p>还有另外一些指令，如无条件跳转指令 <code>goto</code> 则是与<strong>数据类型无关的</strong>。</p><p>大部分的指令都没有支持整数类型 <code>byte</code>、<code>char</code> 和 <code>short</code>，甚至没有任何指令支持 <code>boolean</code> 类型。编译器会在编译期或运行期将 <code>byte</code> 和 <code>short</code> 类型的数据带符号扩展（<code>Sign- Extend</code>）为相应的 <code>int</code> 类型数据, 将 <code>boolean</code>/和<code>char</code> 类型数据零位扩展（<code>Zero- Extend</code>）为相应的 <code>int</code> 类型数据。与之类似，在处理 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型的数组时，也会转换为使用对应的 <code>int</code> 类型的字节码指令来处理。因此，大多数对于 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型数据的操作，实际上都是使用相应的 <code>int</code> 类型作为运算类型。</p><h3 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h3><h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><p><strong>1、作用</strong></p><p>加载和存储指令用于将数据从栈桢的局部变量表和操作数之间来回传递</p><p><strong>2、常用指令</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621082659746.png" alt="image-20210621082659746"></p><p>上面所例举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>)。这些助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了    <code>iload_0、iload_1、iload_2、iload_3</code>这几个指令）。这组指令都是某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式，<strong>对于这若干组特殊指令来说，他们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p><p>除此之外，它们的语义与原生的通用指令完全一致（例如 <code>iload_0</code> 的语义与操作数为0时的 <code>iload</code> 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是 int 类型数据，<code>&lt;l&gt;</code> 代表 long 类型，<code>&lt;f&gt;</code>代表 float 类型，<code>&lt;d&gt;</code>代表 double 类型。</p><p>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</p><h3 id="复习：再谈操作数栈与局部变量表"><a href="#复习：再谈操作数栈与局部变量表" class="headerlink" title="复习：再谈操作数栈与局部变量表"></a>复习：再谈操作数栈与局部变量表</h3><p><strong>1、操作数栈</strong></p><p>我们知道，Java 字节码是Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为<strong>操作数栈，来存放计算的操作数以及返回结果</strong>。</p><p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数機中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入中。</p><p><strong>2、局部变量表（Local Variables）</strong></p><p>Java 方法桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p><p>实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p><p>和操作数栈一样，Long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621084753169.png" alt="image-20210621084753169"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085050120.png" alt="image-20210621085050120"></p><p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p><h3 id="1-局部变量压栈指令"><a href="#1-局部变量压栈指令" class="headerlink" title="1-局部变量压栈指令"></a>1-局部变量压栈指令</h3><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数。</p><p>这类指令大体可以分为：</p><p>​        &gt;<code>xload_ &lt;n&gt;</code> (x 为 i、l、f、d、a, n 为 0 到 3) </p><p>​        &gt;<code>xload</code> (x 为 i、l、f、d、a）</p><p>说明：在这里，x 的取值表示数据类型。</p><p>指令 xload_n 表示将第 n 个局部变量压入操作数，比如 iload_1、fload_0、aload_0 等指令。其中 aload_n 表示将个对象引用压栈。</p><p>指令 xload 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令 iload、fload 等</p><p><strong>￼举例分析</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085858658.png" alt="image-20210621085858658"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085922759.png" alt="image-20210621085922759"></p><h3 id="2-常量入栈指令"><a href="#2-常量入栈指令" class="headerlink" title="2-常量入栈指令"></a>2-常量入栈指令</h3><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 <code>const</code>系列、<code>push</code> 系列和 <code>ldc</code> 指令。</p><p><strong>指令 <code>const</code> 系列</strong>：用于对特定的常量入，入的常量隐含在指令本身里。指令有：<code>const_&lt;i&gt;</code> (i 从-1 到 5)、<code>lconst_&lt;l&gt;</code> (l 从 0 到 1)、<code>fconst_ &lt;f&gt;</code> (f 从 0 到 2)、<code>dconst_&lt;d&gt;</code> (d 从 0 到 1)、aconst_null。</p><p> 比如，</p><p> iconst_m1 将 -1 压入操作数栈；</p><p> iconst _x (x 为到 5) 将 x 压入栈：</p><p> lconst_0、lconst_1 分别将长整数 0 和 1 压入栈；</p><p> fconst_0、fconst_1、fconst_2 分别将浮点数0、1、2 压入栈；</p><p> dconst_0 和 dconst_1 分别将 doublet 型 0 和 1 压入栈。</p><p> aconst_null 将 null 压入操作数</p><p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整数，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p><p><strong>指令 <code>push</code> 系列</strong>：主要包括 biush 和 sipush。它们的区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数， sipus 接收 16 位整数，它们都将参数压入栈。</p><p><strong>指令 <code>ldc</code> 系列</strong>：如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。</p><p>类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。</p><p>如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。</p><p>总结如下：</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621091752821.png" alt="image-20210621091752821"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092109463.png" alt="image-20210621092109463"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092316340.png" alt="image-20210621092316340"></p><p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，本次的n代表数值或者对象，而不是局部变量表中的下标</p><h3 id="3-出栈入局部变量表指令"><a href="#3-出栈入局部变量表指令" class="headerlink" title="3-出栈入局部变量表指令"></a>3-出栈入局部变量表指令</h3><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以 store 的形式存在，比如 xstore (x 为 i、l、f、d、a）、xstore_n (x 为 i、l、f、d、a, n 为 0 至 3)。</p><p>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它值给局部变量索引 n 位置。</p><p>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</p><p><strong>说明：</strong></p><p>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有  istore_0、istore_2、istore_3, 它们分别表示从操作数顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。</p><p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然増加了指令数量，但是可以大大压缩生成的字节码的体积如果局部变量表很大，需要存储的槽位大于 3, 那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。</p><h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><p><strong>1、作用：</strong></p><p>算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p><p><strong>2、分类：</strong></p><p>大体上算数指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令。</p><p><strong>3、byte、short、char和boolean类型说明</strong></p><p>在每一大类中，都有针对Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095121174.png" alt="image-20210621095121174"></p><p><strong>4、运算时的溢出</strong></p><p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常 ArithmeticException。</p><p><strong>5、运算模式</strong></p><p>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p><p>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</p><p><strong>6、NaN值使用</strong></p><p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</p><p><strong>对于无穷大和NaN的举例</strong></p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095607569.png" alt="image-20210621095607569" style="zoom:50%;"><h3 id="1-所有算数指令"><a href="#1-所有算数指令" class="headerlink" title="1-所有算数指令"></a>1-所有算数指令</h3><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095751219.png" alt="image-20210621095751219" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095952979.png" alt="image-20210621095952979" style="zoom:50%;"><p>参数i=5，绿色表示局部变量表，蓝色表示操作数栈。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621100011574.png" alt="image-20210621100011574" style="zoom:50%;"><h3 id="2-比较指令的说明"><a href="#2-比较指令的说明" class="headerlink" title="2-比较指令的说明"></a>2-比较指令的说明</h3><p>比较指令的作用是比较顶两个元素的大小，并将比较结果入栈。</p><p>比较指令有：dampg, dcmpl、fcmpg、fcmpl、lcmp。</p><p>​        与前面讲解的指令类似，首字符 d 表示 double 类型，f表示 float,l 表示 long。</p><p>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令。以 float 为例，有 fcmp 和 fcmpl 两个指</p><p>令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。</p><p>指令 dcmpl 和 dampg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令。</p><p><strong>举例</strong></p><p>指令 fcmpg 和 fcmpl 都从中弹出两个操作数，并将它们做比较，设顶的元素为 v2, 栈顶顺位第 2 位的元素为 v1, 若</p><p>v1=v2, 则压入0；若 v1&gt; v2 则压入 1: 若 v1 &lt;v2 则压入-1。</p><p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1, 而 fcmpl 会压入-1。</p><p>数值类型的数据，才与以谈大小！ </p><p>boolean、引用数据类型不能比较大小</p><p><strong>注意</strong>：NaN(Not a Number)表示不是一个数字，比如0.0/0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，只有double和float类型中可能出现NaN的情况，而long类型不会出现NaN，所以只有lcmp。</p><h3 id="3-i-amp-i"><a href="#3-i-amp-i" class="headerlink" title="3- ++i&amp;i++"></a>3- ++i&amp;i++</h3><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101720616.png" alt="image-20210621101720616" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101758904.png" alt="image-20210621101758904" style="zoom:33%;"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101835404.png" alt="image-20210621101835404" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101855081.png" alt="image-20210621101855081" style="zoom:33%;"></p><p><strong>结论</strong>：如果只是i++和++i，字节码相同</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102017955.png" alt="image-20210621102017955" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102040391.png" alt="image-20210621102040391" style="zoom:33%;"></p><p><strong>结论</strong>：a=i++是将局部变量表中的10先加载到操作数栈，再对局部变量表中的10+1；然后再将操作数栈中的10存储到局部变量表中索引为2的空间中</p><p>b=j++是先将局部变量表中的20自加1之后再加载到操作数栈，然后在存储到局部变量表中</p><h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p><strong>1、类型转换指令说明</strong></p><p>①类型转换指令可以将两种不同的数值类型进行相互转换。</p><p>②这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><h3 id="1-宽化类型转换"><a href="#1-宽化类型转换" class="headerlink" title="1-宽化类型转换"></a>1-宽化类型转换</h3><p><strong>1.转换规则</strong></p><p>Java 虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：</p><p>​        从 int 类型到 long、float 或者 double 类型。对应的指令为：i21、i2f、i2d</p><p>​        从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</p><p>​        从 float 类型到 double 类型。对应的指令为：f2d</p><p>简化为：<code>int--&gt;long--&gt; foat--&gt; double</code></p><p><strong>2.精度损失问题</strong></p><p>2.1 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</p><p>2.2 从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数值。</p><p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java 虚拟机抛出运行时异常。</p><p><strong>3.补充说明</strong></p><p>从 byte、char 和 short类型到 int 类型的宽化类型转换实际上是不存在的。对于 byte 类型转为 int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将 byte 转为 long 时，使用的是 i2l, 可以看到在内部 byte 在这里己经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：</p><p>​        一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只意使用一个字节表示指令，因此指令总数不能超过 256个，为了节省指令资源，将 short/和 byte 当做 int 处理也在情理之中。</p><p>​        另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p><h3 id="2-窄化类型转换"><a href="#2-窄化类型转换" class="headerlink" title="2-窄化类型转换"></a>2-窄化类型转换</h3><p><strong>1.转化规则</strong></p><p>Java 虚拟机也直接支持以下窄化类型转换:</p><p>​        从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s </p><p>​        从 long 类型到 int 类型。对应的指令有：l2i</p><p>​        从行 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l</p><p>​        从 doub1e 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f</p><p><strong>2.精度损失问题</strong></p><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><p><strong>3.补充说明</strong></p><p>3.1 当将一个浮点值窄化转换为整数类型 T (T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：</p><p>​        如果浮点值是 NaN，那转换结果就是 int 或 long 类型的0。</p><p>​        如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果V在目标类型 T (int 或 long）的表示范围之内，那转换结果就是V。否则，将根据 V 的符号，转换为 T 所能表示的最大或者最小正数</p><p>3.2 当将一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</p><p>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：</p><p>​        如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</p><p>​        如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</p><p>​        对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</p><p><strong>注意</strong>：从float、double、long等类型往byte、short、char类型转换的时候，需要先把前面几种类型转换成int类型，然后在从int类型转换到后面这几种类型，所以int类型相等于一种过渡类型</p><h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><p>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><h3 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1-创建指令"></a>1-创建指令</h3><p>虽然类实例和数组都是对象，但Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p><p><strong>1. 创建类实例的指令：</strong></p><p>创建类实例的指令：new</p><p>​        它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</p><p><strong>2. 创建数组的指令：</strong></p><p>创建数组的指令：newarray、anewarray、mu tianewarray</p><p>​         newarray：创建基本类型数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anewarray：创建引用类型数</span><br><span class="line"></span><br><span class="line">multianewarray：创建多维数组</span><br></pre></td></tr></table></figure><p>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也非常高。</p><p><strong>需要注意的细节：</strong></p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105624505.png" alt="image-20210621105624505" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105652436.png" alt="image-20210621105652436" style="zoom:50%;"><p>两个创建二维数组的字节码中的差距需要注意</p><h3 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2-字段访问指令"></a>2-字段访问指令</h3><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p><p>​        <em>访问类字段（static 字段，或者称为类变量）的指令：getstatic、putstatic</em> </p><p>​        <em>访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfied、putfield</em></p><p>举例：</p><p>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的</p><p>对象或者值，并将其压入操作数栈。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113216931.png" alt="image-20210621113216931" style="zoom:50%;"><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113249177.png" alt="image-20210621113249177" style="zoom:50%;"><p>注意：<code>get***</code>是入栈，而<code>put***</code>是出栈</p><h3 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3-数组操作指令"></a>3-数组操作指令</h3><p>数组操作指令主要有：xastore 和 xaload 指令。具体为：</p><p>​        把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aalad</p><p>​        将一个操作数的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、 faster、dastore、aastore</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621114243226.png" alt="image-20210621114243226" style="zoom:50%;"><p>取数组长度的指令：arraylength</p><p>​        该指令弹出顶的数组元素，获取数组的长度，将长度压入栈</p><p><strong>说明</strong></p><p>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令xaload 在执行时，要求操作数中栈顶元素为数组素引，顶顺位第 2 个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 <code>a[i]</code>重新压入栈。</p><p> xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，restores 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</p><h3 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4-类型检查指令"></a>4-类型检查指令</h3><p>检查类实例或数组类型的指令：instanceof、checkcast。</p><p>​        指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数，否则它会抛出 ClassCastException 异常。</p><p>​        指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</p><h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1-方法调用指令"></a>1-方法调用指令</h3><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p><p>以下 <strong>5 条指令</strong>用于方法调用：</p><p>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java 语言中最常见的方法分派方式。</p><p> invokeinterface 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p><p> invokespecia 指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）、私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</p><p> invokestatic 指令用于调用命名类中的类方法（static 方法）。这是<strong>静态绑定</strong>的。</p><p> invokedynamic：调用动态绑定的方法，这个是JDK1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</p><p><strong>注意：</strong> </p><p>1、invokedynamic老师不讲，估计是很少遇到吧</p><p>2、invokeinterface是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</p><p>3、invokespecial只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了.  这几种方法都是不会被重写的</p><p>4、invokestatic是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是invokestatic，也不难理解</p><p>5、invokevirtual是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如A a = new B();a.hello()，其中B类继承A类，并且B类重写了A类中的hello()方法，这种情况下就是invokevirtual了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是invokevirtual了</p><h3 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2-方法返回指令"></a>2-方法返回指令</h3><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p><p>​        包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、 dreturn 和 areturn</p><p>​        另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621133956414.png" alt="image-20210621133956414" style="zoom:50%;"><p>举例：</p><p>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p><p>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</p><p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621135828244.png" alt="image-20210621135828244"></p><h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆那样，JVM 提供的操作数管理指令，可以用于直接操作操作数的指令。</p><p>这类指令包括如下内容：</p><p>​        将一个或两个元素从栈顶弹出，并且直接废弃：pop, pop2</p><p>​        复制顶一个或两个数值并将复制值或双份的复制值重新压入顶：dup, dup2, dup_x1,  dup2 x1, dup_x2, dup2_x2:</p><p>​        将栈最顶端的两个Slot数值位置交换：swap。Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令。</p><p>​        指令 nop，是一个非常特殊的指令，它的字节码为 x。和汇编语言中的 nop 一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p><p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p><p><strong>说明：</strong></p><p>不带_x 的指令是复制栈顶数据并压入顶。包括两个指令，dup 和 dup2。dup 的系数代表要复制的 Slot 个数。</p><p>​        dup 开头的指令用于复制 1 个 Sot 的数据。例如 1 个 int 或 1 个 reference 类型数据</p><p>​        dup2 开头的指令用于复制 2 个 S1ot 的数据。例如 1 个 1ong，或 2 个 int，或 1 个 int+1 个 float 类型数据</p><p>带_x 的指令是复制栈顶数据并插入顶以下的某个位置。共有 4 个指令，dup_x1, dup2_x1,</p><p>dup_x2, dup2_x2. 对于带_x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插</p><p>入的位置。因此</p><p>​        dup_x1 插入位置：1+1=2, 即栈顶 2 个 Slot 下面</p><p>​        dup_x2 插入位置：1+2=3, 即栈顶 3 个 Slot 下面</p><p>​        dup2_x1 插入位置：2+1=3, 即栈顶 3 个 Slot 下面</p><p>​        dup2_x2 插入位置：2+2=4, 即栈顶 4 个 Slot 下面</p><p>pop：将顶的 1 个 Slot 数值出。例如 1 个 short 类型数值</p><p>pop2: 将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值</p><h2 id="控制转义指令"><a href="#控制转义指令" class="headerlink" title="控制转义指令"></a>控制转义指令</h2><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为 1) 比较指令、2) 条件跳转指令、3) 比较条件跳转指令、4) 多条件分支跳转指令、5) 无条件跳转指令等。</p><p>比较指令见算数指令</p><h3 id="1-条件跳转指令"><a href="#1-条件跳转指令" class="headerlink" title="1-条件跳转指令"></a>1-条件跳转指令</h3><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p><p>条件跳转指令有：ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull。这些指令都接收两个字节的操作数用于计算跳转的位置（16 位符号整数作为当前位置的 offset）。</p><p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621152715017.png" alt="image-20210621152715017"></p><p>注意</p><ol><li>与前面运算规则一致：</li></ol><p>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成</p><p>对于 long、float、double：类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转</p><ol><li><p>由于各类型的比较最终都会转为 int 类型的比较操作，所以Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621153319123.png" alt="image-20210621153319123"></p><p>⚠️这里是满足条件就跳转，而源程序中是满足条件则继续执行 </p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621155510988.png" alt="image-20210621155510988"></p><p>这里需要⚠️，print函数最后输出的是boolean类型的，当前操作数栈中的1作为参数传到print方法中以后，此处的print方法是调用的返回值为boolean的重载方法，如下图</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160314388.png" alt="image-20210621160314388"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160603355.png" alt="image-20210621160603355"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162110106.png" alt="image-20210621162110106"></p></li></ol><p><strong>注意：</strong> </p><p>1、对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用<strong>比较指令和条件跳转指令</strong> 来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型</p><p>2、int类型值（包含byte、char、short）比较 和 对象类型值比较需要使用<strong>比较条件跳转指令</strong> </p><h3 id="2-比较条件跳转指令"><a href="#2-比较条件跳转指令" class="headerlink" title="2-比较条件跳转指令"></a>2-比较条件跳转指令</h3><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p><p>这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_ icmpgt、if_ icmple、if_icmpge、if_ acmpeq和 if_ acmpne。其中指令助记符加上“if_”后，以字符“i”开头的指令针对int型整数操作（也包括 short 和 byte 类型），以字符“a”开头的指令表示对象引用的比较。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162346744.png" alt="image-20210621162346744"></p><p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入。<strong>如果预设条件成立，则执行跳转，否则，继续执行下条语句。</strong></p><p><strong>举例如下</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162751624.png" alt="image-20210621162751624"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621163632471.png" alt="image-20210621163632471"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164348661.png" alt="image-20210621164348661"></p><p><strong>总结：</strong></p><p>只有int或者用int表示的类型可以直接使用<strong>比较条件跳转指令</strong>；</p><p>double，float，long则需要<strong>比较指令</strong>和<strong>条件跳转指令</strong>共同使用才能完成跳转。</p><h3 id="3-多条件分支跳转"><a href="#3-多条件分支跳转" class="headerlink" title="3-多条件分支跳转"></a>3-多条件分支跳转</h3><p>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164743732.png" alt="image-20210621164743732"></p><p>从助记符上看，两者都是 switch 语句的实现，它们的区别：</p><p>​         tableswitch 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高。</p><p>​        指令 lookupswitch 内部存放着各个离散的 case- offset 对，每次执行都要搜索全部的 case- offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此效率较低。</p><p>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203815830.png" alt="image-20210621203815830"></p><p>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 <strong>case- offset 对按照 case 值大小排</strong>序，给定 index 时，需要査查找与 index 相等的 case，获得其offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203953038.png" alt="image-20210621203953038"></p><p><strong>举例如下</strong></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171348274.png" alt="image-20210621171348274"></p><p>如果将case2中的break注释掉，</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171614629.png" alt="image-20210621171614629"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202029361.png" alt="image-20210621202029361"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202709783.png" alt="image-20210621202709783"></p><p>这里对字符串的比较，先比较哈希值，哈希值相同再比较值是否相等</p><h3 id="4-无条件跳转"><a href="#4-无条件跳转" class="headerlink" title="4-无条件跳转"></a>4-无条件跳转</h3><p>目前主要的无条件跳转指令为 goto。指令 goto 接收<strong>两个字节</strong>的操作数，共同组成一个带符号的整数，用于指定指令的偏移量指令执行的目的就是跳转到偏移量给定的位置处。</p><p>如果指令偏移量太大，超过双字节的帯符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它<strong>接收 4 个字节</strong>的操作数，可以表示更大的地址范围。</p><p>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且己经被虛拟机<em>逐渐废弃</em>，故不在这里介绍这两个指令。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204052272.png" alt="image-20210621204052272"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204647802.png" alt="image-20210621204647802"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205120603.png" alt="image-20210621205120603"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205408219.png" alt="image-20210621205408219"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205643514.png" alt="image-20210621205643514"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205815307.png" alt="image-20210621205815307"></p><h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>异常及异常的处理：</p><p>过程一：异常对象的生成过程—&gt; throw(手动/自动) —-&gt;指令：athrow </p><p>过程二：异常的处理：抓抛模型。try- catch- finaly —-&gt;使用异常表</p><h3 id="1-抛出异常指令"><a href="#1-抛出异常指令" class="headerlink" title="1-抛出异常指令"></a>1-抛出异常指令</h3><p>(1) athrow 指令</p><p>在Java 程序中显示抛出异常的操作（throw 语句）都是由 athrow 指令来实现。</p><p>除了使用 throw 语句显示抛出异常情况之外，JVM 规范还规定了许多运行时异常会在其他Java 虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出  ArithmeticException 异常。</p><p> (2) 注意</p><p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java 虚拟机会清除操作数上的所有内容，而后将异常实例压入调用者操作数栈上。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621221625270.png" alt="image-20210621221625270"></p><p>如果使用throw new 异常名称() 这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称 这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223049071.png" alt="image-20210621223049071"></p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223157782.png" alt="image-20210621223157782"></p><h3 id="2-异常处理与异常表"><a href="#2-异常处理与异常表" class="headerlink" title="2-异常处理与异常表"></a>2-异常处理与异常表</h3><p><strong>1、处理异常：</strong></p><p>在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是采用异常表来完成的。</p><p><strong>2、异常表</strong></p><p>如果一个方法定义了一个 try- catch 或者 try- finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者  finally 块的信息。异常表保存了每个异常处理信息。比如</p><p>​        起始位置</p><p>​        结束位置</p><p>​        程序计数器记录的代码处理的偏移地址</p><p>​        被捕获的异常类在常量池中的索引</p><p><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法（在调用方法帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM 自己终止，比如这个线程是个 main 线程。</p><p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finaly 块来完成目标</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622092751237.png" alt="image-20210622092751237"></p><p>栈中压入创建的异常实例信息后，会和异常表中的一场类型进行比对，因此说异常处理是通过异常表进行的</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622093823020.png" alt="image-20210622093823020"></p><p><strong>这里的异常处理，其实是重新做了一遍finally里面的事情，因为finally里面的代码时一定要执行，如果未发生异常，则上面的代码不会中断，顺利执行完finally中的代码，如果发生异常，在异常处理中也要执行finally中的代码。</strong></p><h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><p>组成</p><p>java 虚拟机支持两种同步结构：<strong>方法级的同步和方法内部一段指令序列的同</strong>步，这两种同步都是使用 monitor 来支持的</p><h3 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1-方法级的同步"></a>1-方法级的同步</h3><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONZED 访问标志得知一个方法是否声明为同步方法</p><p>当调用方法时，调用指令将会检方法的 ACC_SYNCHRONIZED 访问标志是否设置。</p><p>​        如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p><p>​        在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁</p><p>​        如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622112918956.png" alt="image-20210622112918956" style="zoom:50%;"><p>说明：</p><p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <strong>monitorenter 和 monitorexiti 进</strong>行同步区控制。这是因为，对于同步方法而言，当虚拟机通<strong>过方法的访问标示</strong>符判断是一个同步方法时<strong>，会自动在方法调用前进行加锁，当</strong>同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和  monitorexit 指令是<strong>隐式存在的</strong>，并未直接出现在字节码中。</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622113055258.png" alt="image-20210622113055258"></p><h3 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2-方法内指令指令序列的同步"></a>2-方法内指令指令序列的同步</h3><p>同步一段指令集序列：通常是由 java 中的 synchronized 语句块来表示的。jvm 的指令集有 monitorenter 和  monitorexit 两条指令来支持 synchronized 关键字的语义。</p><p>当一个线程进入同步代码块时，它使用 monitorenterl 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入;若为 1, 则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p><p>当线程退出同步块时，需要使用 monitorexit 声明退出。在Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p><p>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p><p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程 4 离开临界区后，线程 1、2、3 才有可能进入。</p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622095830957.png" alt="image-20210622095830957" style="zoom:50%;"><p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p><p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令</p><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622101528989.png" alt="image-20210622101528989"></p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的加载过程（类的生命过程）详解</title>
      <link href="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</strong></p><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，他的整个生命周期包括如下7个阶段：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622143633263-4785833.png" alt="image-20210622143633263" style="zoom:50%;"><p>其中，验证、准备、解析3个部分统称为链接（Linking）</p><p>从程序中类的使用过程看：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622143915545-4785833.png" alt="image-20210622143915545" style="zoom:50%;"><p>注意：我们所说的加载完毕包括：加载、链接、初始化三个阶段都完成之后类进入方法区中</p><h3 id="大厂面试"><a href="#大厂面试" class="headerlink" title="大厂面试"></a>大厂面试</h3><p><strong>蚂蚁金服：</strong></p><p>描述一下 JVM 加载 Class 文件的原理机制？</p><p>一面：类加载过程</p><p><strong>百度：</strong></p><p>类加载的时机 </p><p>java 类加载过程？</p><p>简述 java 类加载机制？</p><p><strong>腾讯：</strong></p><p>JVM 中类加载机制，类加载过程？</p><p><strong>滴滴：</strong></p><p>JVM 类加载机制</p><p><strong>美团：</strong></p><p>Java 类加载过程</p><p>描述一下 jvm 加载 class 文件的原理机制</p><p><strong>京东：</strong></p><p>什么是类的加载？</p><p>哪些情况会触发类的加载？</p><p>讲一下 JVM 加载一个类的过程</p><p> JVM 的类加载机制是什么？</p><h2 id="过程一：Loading（加载）阶段"><a href="#过程一：Loading（加载）阶段" class="headerlink" title="过程一：Loading（加载）阶段"></a>过程一：Loading（加载）阶段</h2><h3 id="1-加载完成的操作"><a href="#1-加载完成的操作" class="headerlink" title="1-加载完成的操作"></a>1-加载完成的操作</h3><p><strong>加载的理解</strong></p><p>所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出Java 类的原型一一类模板对象。所谓类模板对象，其实就是Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM 在运行期便能通过类模板而获取java 类中的任意信息，能够对Java 类的成员变量进行遍历，也能进行Java 方法的调用。</p><p>反射的机制即基于这一基础。如果 JVM 没有将Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p><p><strong>加载完成的操作</strong></p><p><strong>加载阶段，简言之，查找并加载类的二进制数据，生成 Class 的实例。</strong></p><p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p><ul><li><p>通过类的全名，获取类的二进制数据流</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p></li><li><p>创建 java.lang. Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><h3 id="2-二进制流的获取方式"><a href="#2-二进制流的获取方式" class="headerlink" title="2-二进制流的获取方式"></a>2-二进制流的获取方式</h3><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（<strong>只要所读取的字节码符合JVM 规范即</strong>可）</p><ul><li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）</li><li>读入 jar、zip 等归档数据包，提取类文件。</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于 HTTP 之类的协议通过网络进行加载</li><li>在运行时生成一段 C1ass 的二进制信息等</li></ul><p>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><h3 id="3-类模型与Class实例的位置"><a href="#3-类模型与Class实例的位置" class="headerlink" title="3-类模型与Class实例的位置"></a>3-类模型与Class实例的位置</h3><ol><li><strong>类模型的位置</strong></li></ol><p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDK1.8 之前：永久代：JDK1.8 及之后：元空间）。</p><ol start="2"><li><strong>Class 实例的位置</strong></li></ol><p>类将.Class 文件加载至元空间后，会在堆中创建一个Java.lang. Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p><p><strong>图示</strong></p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622145233118-4785833.png" alt="image-20210622145233118" style="zoom:50%;"><h3 id="4-数组类的加载"><a href="#4-数组类的加载" class="headerlink" title="4-数组类的加载"></a>4-数组类的加载</h3><p>创建数组类的情况稍有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p><ol><li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li></ol><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为  public。</p><h2 id="过程二：Linking（链接）阶段"><a href="#过程二：Linking（链接）阶段" class="headerlink" title="过程二：Linking（链接）阶段"></a>过程二：Linking（链接）阶段</h2><h3 id="1-环节1-链接阶段之Vertification（验证）"><a href="#1-环节1-链接阶段之Vertification（验证）" class="headerlink" title="1-环节1:链接阶段之Vertification（验证）"></a>1-环节1:链接阶段之Vertification（验证）</h3><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><strong>它的目的是保证加载的细节码是合法、合理并符合规范的。</strong></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示：</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622160921984-4785833.png" alt="image-20210622160921984" style="zoom:50%;"><p><strong>整体说明：</strong></p><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><strong>其中格式验证会和加载阶段一起执行</strong>。验证通过之后，类加载器オ会成功将类的二进制数据信息加载到方法区中。</li><li><strong>格式验证之外的验证操作将会在方法区中进行。</strong></li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><p><strong>具体说明：</strong></p><p>1.格式验证：是否以魔数 0xCAFEBABE 开头，主版本和副版本号是否在当前Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p><p>和加载阶段一起执行。</p><p>2.Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li><p>是否所有的类都有父类的存在（在Java 里，除了 Object 外，其他类都应该有父类）</p></li><li><p>是否一些被定义为 final 的方法或者类被重写或继承了</p></li><li><p>非抽象类是否实现了所有抽象方法或者接口方法</p></li><li><p>是否存在不兼容的方法（比如方法的签名除了返回值不同，其他都一样，这种方法会让虚拟机无从下手调度；abstract 情况下的方法，就不能是 fina 的了）</p></li></ul><p>3.Java 虚拟机还会进行字节码验证，字节码验证也是验证过程中最为复杂的一个过程。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p><ul><li><p>在字节码的执行过程中，是否会跳转到一条不存在的指令</p></li><li><p>函数的调用是否传递了正确类型的参数</p></li><li><p>变量的赋值是不是给了正确的数据类型等</p></li></ul><p>栈映射帧（Stackmaptable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检査出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p><strong>在前面 3 次检查中，已经排除文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</strong></p><p>4.校验器还将进行符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。</p><p><strong>此阶段在解析环节才会执行。</strong></p><h3 id="2-环节2-链接阶段之Preparation（准备）"><a href="#2-环节2-链接阶段之Preparation（准备）" class="headerlink" title="2-环节2:链接阶段之Preparation（准备）"></a>2-环节2:链接阶段之Preparation（准备）</h3><p><strong>简言之，为类的静态变量分配内存，并将其初始化为默认值。</strong></p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623111059486-4785833.png" alt="image-20210623111059486" style="zoom:50%;"><p>注意：Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是0，故对应的，boolean 的默认值就是 false。</p><p><strong>注意：</strong></p><ol><li>这里不包含基本数据类型的字段用 static final 修饰的情況，因为 final 在编译的时候就会分配了，准备阶段会显式赋值。</li><li>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java 堆中。</li><li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</li></ol><p><strong>对注意中的第1点分析：</strong> </p><p>注意：以下前3点的前提都是字段已经完成显示赋值（定义的后面已经赋了值）的前提下进行的</p><p>1、非final修饰的静态变量会在准备阶段赋初始值，然后在初始化中的<code>&lt;clinit&gt;</code>方法中显示赋值</p><p>2、静态常量（基本数据类型、String类型字面量（”XXX”这种情况））在编译阶段会初始化赋值，然后在准备阶段就会显示赋值</p><p>3、引用数据类型的静态常量，尤其是<code>new String(&quot;XXX&quot;)</code>这种形式，都是在初始化中的<code>&lt;clinit&gt;</code>中进行显示赋值的</p><p>4、如果在static静态代码块中具有显示赋值操作（定义的后面没有赋值），那肯定就是在初始化中的&lt;<code>clinit</code>&gt;方法中显示赋值</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622164156502-4785833.png" alt="image-20210622164156502" style="zoom:50%;"> <h3 id="3-环节3-链接阶段之Resolution（解析）"><a href="#3-环节3-链接阶段之Resolution（解析）" class="headerlink" title="3-环节3:链接阶段之Resolution（解析）"></a>3-环节3:链接阶段之Resolution（解析）</h3><p>在准备阶段完成后，就进入了解析阶段。</p><p><strong>解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</strong></p><p><strong>1.具体描述</strong></p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 <code>printin（）</code>方法被调用时，系统需要明确知道该方法的位置</p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210622165228307-4785833.png" alt="image-20210622165228307" style="zoom:50%;"><p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</strong></p><h2 id="过程三：Initialization（初始化）阶段"><a href="#过程三：Initialization（初始化）阶段" class="headerlink" title="过程三：Initialization（初始化）阶段"></a>过程三：Initialization（初始化）阶段</h2><h3 id="1-static与final的搭配问题"><a href="#1-static与final的搭配问题" class="headerlink" title="1-static与final的搭配问题"></a>1-static与final的搭配问题</h3><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623151818526-4785833.png" alt="image-20210623151818526" style="zoom:25%;"><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623152955662-4785833.png" alt="image-20210623152955662" style="zoom:25%;"><p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623154030811-4785833.png" alt="image-20210623154030811"></p><p>注意⚠️：结论1中的显示赋值是指直接赋值<strong>常量</strong>的形式，而非调用方法的场景</p><p><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210623153238864-4785833.png" alt="image-20210623153238864"></p><p>结论：只有String特殊</p><p><strong>最终结论：使用 static+ final 修，且显示赋值中不涉及到方法或构造器调用的基本数据类型或 string 类型的显式赋值，是在链接阶段的准备环节进行。</strong></p><h3 id="2-lt-clinit-gt-的线程安全性"><a href="#2-lt-clinit-gt-的线程安全性" class="headerlink" title="2-&lt;clinit&gt;()的线程安全性"></a>2-<code>&lt;clinit&gt;</code>()的线程安全性</h3><p>对于<code>&lt;clinit&gt;（）</code>方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的<code>&lt;clinit&gt;（）</code>方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;（）</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;（）</code>方法完毕。</p><p>正是因为函数<code>&lt;clinit&gt;（）</code>带锁线程安全的，因此，如果在一个类的<code>&lt;clinit&gt;（）</code>方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加了类，则等在队列中的线程就没有机会再执行<code>&lt;c1init&gt;（）</code>方法了。那么，当需要使用这个类时虚拟机会直接返回给它经准备好的信息。</p><h3 id="3-类的初始化情况：主动使用VS被动使用"><a href="#3-类的初始化情况：主动使用VS被动使用" class="headerlink" title="3-类的初始化情况：主动使用VS被动使用"></a>3-类的初始化情况：主动使用VS被动使用</h3><p>Java程序对类的使用有两种：<strong>主动使用</strong> 和 <strong>被动使用</strong></p><p><strong>主动使用</strong></p><ul><li>当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</li><li>当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</li><li>当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量赋值变量操作）</li><li>当使用 java.lang. Reflect 包中的方法反射类的方法时。比如：Class.forname (“com atguigu.java.Test”)</li><li>当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main（）方法的那个类），虚拟机会先初始化这个主类。</li><li>当初次调用 Methodhandle 实例时，初始化该 Methodhandle 指向的方法所在的类。（涉及解析 REF_ getstatic、REF_ putstatic、REF_ invokestatic 方法句柄对应的类）</li></ul><p>针对 5， 补充说明：</p><p>当Java 虚拟机初始化一个类时，要求它的所有父类都己经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li></ul><p>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，会导致该接口的初始化。</p><p>针对 7， 说明</p><p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用 <code>public static void main (String []）</code>方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p><p>下面是主动初始化一些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化会触发类的主动使用&lt;clnit&gt;()方法演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列化过程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">            oos.writeObject(<span class="keyword">new</span> Order());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化过程</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">            Order o = (Order) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order初始化方法执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量赋值变量操作）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveUse2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Order3.NUM1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order2</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">// 执行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num2 = <span class="number">1</span>;<span class="comment">// 不执行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num3 = <span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">// 执行初始化</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order2执行初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span>  <span class="title">Order3</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接口中不能定义静态代码块，采取的方式是声明一个能使用匿名内部类的字段</span></span><br><span class="line">    <span class="comment">// 下面这个方法会存在于&lt;clinit&gt;方法中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thread t=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Order3的初始化方法执行了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM1=<span class="number">1</span>;<span class="comment">// 不执行初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM2=<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>);<span class="comment">// 执行初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被动使用</strong></p><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<strong>被动使用不会引起类的初始化。</strong></p><p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。</strong></p><ol><li>当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。<br> 当通过子类引用父类的静态变量，不会导致子类初始化</li><li>通过数组定义类引用，不会触发此类的初始化</li><li>引用常量不会触发此类或接口的初始化。因为常量在链接阶段就己经被显式赋值了。</li><li>调用 ClassLoader 类的 loadclass（）方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过数组定义类引用，不会触发此类的初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassaveUse1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Parent[] parents=<span class="keyword">new</span> Parent[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;parent初始化了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="过程四：类Using（使用）"><a href="#过程四：类Using（使用）" class="headerlink" title="过程四：类Using（使用）"></a>过程四：类Using（使用）</h2><h2 id="过程五：类的Unloading（卸载）"><a href="#过程五：类的Unloading（卸载）" class="headerlink" title="过程五：类的Unloading（卸载）"></a>过程五：类的Unloading（卸载）</h2><h3 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h3><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</p><p> Hotspot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>该类所有的实例都己经被回收。也就是Java 堆中不存在该类及其任何派生子类的实例。</li><li>加载该类的类加载器己经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</li><li>该类对应的 java.lang. Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><h3 id="类的Unloading"><a href="#类的Unloading" class="headerlink" title="类的Unloading"></a>类的Unloading</h3><h4 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h4><p>在类加载器的内部实现中，用一个Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器调用 Class 对象的 getClassLoader（）方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass（）方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的Java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>当 Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，不可触及时，Class 对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p><p><strong>一个类何时结束生命周期，取决于代表它的 Class 对象何时结東生命周期。</strong></p><h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><img src="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/image-20210627165843275.png" alt="image-20210627165843275" style="zoom:50%;"><p>loader1 变量和 obj 变量间接应用代表 Sampe 类的 Class 对象，而 objClass 变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为 null, 此时 Sample对象结束生命周期，MyclassLoader 对象结生命周期，代表 Sample 类的 Cass 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载</p><p>当再次有需要时，会检查 Sample类的 Class 对象是否存在，<strong>如果存在会直接使用，不再重新加载</strong>；如果不存在 Sample 类会被重新加载，在Java 虚拟机的堆区会生成一个新的代表 Sampe 类的 Class 实例（可以通过哈希码查看是否是同一个实例）。</p><h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>(1) 启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p><p>(2) 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p><p>(3) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节码和源码分析Integer</title>
      <link href="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/"/>
      <url>/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/</url>
      
        <content type="html"><![CDATA[<h1 id="先从一段代码讲起"><a href="#先从一段代码讲起" class="headerlink" title="先从一段代码讲起"></a>先从一段代码讲起</h1><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1=<span class="number">59</span>;</span><br><span class="line">        <span class="keyword">int</span> i2=<span class="number">59</span>;</span><br><span class="line">        Integer i3=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">        Integer i4=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i1==i3);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">        System.out.println(i2==i4);</span><br><span class="line">        <span class="comment">//System.out.println(i1==i4);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><p>引起我的好奇的不是单一个的结果，而是这几个结果的组合，我感觉违背了数学定律，<code>i1==i2,i2==i4,i1==i3</code>,是不是可以推导出<code>i3==i4</code>?有了这个问题，我就开始了对每一个==的研究。</p><h2 id="字节码分析"><a href="#字节码分析" class="headerlink" title="字节码分析"></a>字节码分析</h2><p>打开字节码</p><h3 id="创建属性的字节码"><a href="#创建属性的字节码" class="headerlink" title="创建属性的字节码"></a>创建属性的字节码</h3><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624163619597.png" alt="image-20210624163619597" style="zoom:50%;"><p>可以看到<code>i1</code>虽然是直接赋值，仍然调用了<code>valueOf()</code>方法；<code>i2</code>是基本数据类型<code>int</code>，所以直接赋值；<code>i3</code>不用讲；<code>i4</code>是<code>new</code>的，所以调用了构造方法 。</p><h3 id="比较过程的字节码"><a href="#比较过程的字节码" class="headerlink" title="比较过程的字节码"></a>比较过程的字节码</h3><p><strong><code>i1==i2</code></strong></p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624164510827.png" alt="image-20210624164510827" style="zoom:50%;"><p>我首先看到的是<code>if_icmpne</code>指令，这是一个<code>int</code>类型的比较指令，到这里其实就能懂了，<code>Integer</code>成为了<code>int</code>，那肯定是自动拆箱了，那前面的<code>intValue</code>方法肯定就是拆箱的方法了，具体的执行过程的源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as an</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int类型的比较，数值相同肯定相同了。</p><p><strong><code>i1==i3</code></strong></p><p>前面分析创建过程的时候我们知道了<code>i1</code>和<code>i3</code>都调用了同一个函数valueOf，那么他俩相等时不适合这个函数有关呢？我们先看一下字节码</p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624165301236.png" alt="image-20210624165301236" style="zoom:50%;"><p>就是普通的引用类型比较过程，那问题一定出在了<code>valueOf</code>函数，我们打开源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要的是这一段，我们看到了条件判断，其中出现了一个<code>IntegerCache</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这是一个静态内部类，<code>low=-128,high=127</code>，内部类中有个数组<code>cache</code>放着-128～127，也就是说如果<code>Integer</code>的值在-128～127之间的话直接返回数组索引地址，因此<code>i1==i3</code>！！！</p><p><strong><code>i3==i4</code></strong></p><p>通过前面的分析，我们能想到这个是<code>false</code>的原因了，一个是数组某一索引的地址，一个是存放在堆内的引用类型地址，不是同一个地址。</p><p><strong><code>i2==i4</code></strong></p><img src="/2021/06/24/%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90Integer/image-20210624171530684.png" alt="image-20210624171530684" style="zoom:50%;"><p>拆箱了，因此相等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个是<code>Integer</code>和<code>int</code>进行比较时，引用数据类型要进行拆箱，再比较。</p><p>第二是<code>Integer.valueOf()</code>方法的作用。</p>]]></content>
      
      
      <categories>
          
          <category> JVM学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
