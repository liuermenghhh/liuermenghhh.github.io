<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/game32*32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/game16*16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liuermenghhh.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JVM中篇，字节码指令集与解析举例">
<meta property="og:type" content="article">
<meta property="og:title" content="字节码指令集与解析举例">
<meta property="og:url" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/index.html">
<meta property="og:site_name" content="刘二萌的博客">
<meta property="og:description" content="JVM中篇，字节码指令集与解析举例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621082659746.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621084753169.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085050120.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085858658.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085922759.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621091752821.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092109463.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092316340.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095121174.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095607569.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095751219.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095952979.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621100011574.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101720616.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101758904.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101835404.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101855081.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102017955.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102040391.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105624505.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105652436.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113216931.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113249177.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621114243226.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621133956414.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621135828244.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621152715017.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621153319123.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621155510988.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160314388.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160603355.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162110106.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162346744.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162751624.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621163632471.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164348661.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164743732.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203815830.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203953038.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171348274.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171614629.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202029361.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202709783.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204052272.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204647802.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205120603.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205408219.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205643514.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205815307.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621221625270.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223049071.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223157782.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622092751237.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622093823020.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622112918956.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622113055258.png">
<meta property="og:image" content="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622095830957.png">
<meta property="og:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622101528989.png">
<meta property="article:published_time" content="2021-06-27T01:49:39.000Z">
<meta property="article:modified_time" content="2021-06-27T02:01:03.543Z">
<meta property="article:author" content="superBaby">
<meta property="article:tag" content="-JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liuermenghhh.github.io/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621082659746.png">

<link rel="canonical" href="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>字节码指令集与解析举例 | 刘二萌的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">刘二萌的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">日常学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/iu.GIF">
      <meta itemprop="name" content="superBaby">
      <meta itemprop="description" content="记录学习">
    </span>
    
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="刘二萌的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          字节码指令集与解析举例
        </h1>
    
        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              
    
              <time title="创建时间：2021-06-27 09:49:39 / 修改时间：10:01:03" itemprop="dateCreated datePublished" datetime="2021-06-27T09:49:39+08:00">2021-06-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">JVM学习</span></a>
                </span>
            </span>
    
          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">JVM中篇，字节码指令集与解析举例</div>
    
        </div>
      </header>
    
    
    
    
    <div class="post-body" itemprop="articleBody">
    
      
        <h1 id="字节码指令集与解析举例"><a href="#字节码指令集与解析举例" class="headerlink" title="字节码指令集与解析举例"></a>字节码指令集与解析举例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="执行模型"><a href="#执行模型" class="headerlink" title="执行模型"></a>执行模型</h3><p>如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当作最基本的执行模型来理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">  自动计算PC寄存器的值+1；</span><br><span class="line">  根据PC寄存器的指示位置，从字节码流中取出操作码；</span><br><span class="line">  if(字节码存在操作数)从字节码流中取出操作数；</span><br><span class="line">  执行操作码所定义的操作；</span><br><span class="line">&#125;while(字节码长度&gt;0)</span><br></pre></td></tr></table></figure>



<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>在Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，<code>iload</code> 指令用于从局部变量表中加载 <code>int</code> 型的数据到操作数栈中，而 <code>fload</code> 指令加载的则是 <code>float</code> 类型的数据。</p>
<p>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务</strong>：</p>
<p>代表对 <code>int</code> 类型的数据操作，</p>
<p>l 代表 <code>1ong</code> </p>
<p>s 代表 <code>short</code> </p>
<p>b 代表 <code>byte</code> </p>
<p>c 代表 <code>char</code> </p>
<p>f 代表 <code>float</code> </p>
<p>d 代表 <code>double</code></p>
<p>也有一些指令的助记符中<strong>没有明确地指明操作类型的字母</strong>，如 <code>arraylength</code> 指令，它没有代表数据类型的特殊字符，但</p>
<p>操作数永远只能是一个数组类型的对象。</p>
<p>还有另外一些指令，如无条件跳转指令 <code>goto</code> 则是与<strong>数据类型无关的</strong>。</p>
<p>大部分的指令都没有支持整数类型 <code>byte</code>、<code>char</code> 和 <code>short</code>，甚至没有任何指令支持 <code>boolean</code> 类型。编译器会在编译期或运行期将 <code>byte</code> 和 <code>short</code> 类型的数据带符号扩展（<code>Sign- Extend</code>）为相应的 <code>int</code> 类型数据, 将 <code>boolean</code>/和<code>char</code> 类型数据零位扩展（<code>Zero- Extend</code>）为相应的 <code>int</code> 类型数据。与之类似，在处理 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型的数组时，也会转换为使用对应的 <code>int</code> 类型的字节码指令来处理。因此，大多数对于 <code>boolean</code>、<code>byte</code>、<code>short</code> 和 <code>char</code> 类型数据的操作，实际上都是使用相应的 <code>int</code> 类型作为运算类型。</p>
<h3 id="指令分析"><a href="#指令分析" class="headerlink" title="指令分析"></a>指令分析</h3><h2 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h2><p><strong>1、作用</strong></p>
<p>加载和存储指令用于将数据从栈桢的局部变量表和操作数之间来回传递</p>
<p><strong>2、常用指令</strong></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621082659746.png" alt="image-20210621082659746"></p>
<p>上面所例举的指令助记符中，有一部分是以尖括号结尾的（例如<code>iload_&lt;n&gt;</code>)。这些助记符实际上代表了一组指令（例如<code>iload_&lt;n&gt;</code>代表了    <code>iload_0、iload_1、iload_2、iload_3</code>这几个指令）。这组指令都是某个带有一个操作数的通用指令（例如<code>iload</code>）的特殊形式，<strong>对于这若干组特殊指令来说，他们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中。</strong></p>
<p>除此之外，它们的语义与原生的通用指令完全一致（例如 <code>iload_0</code> 的语义与操作数为0时的 <code>iload</code> 指令语义完全一致）。在尖括号之间的字母指定了指令隐含操作数的数据类型，<code>&lt;n&gt;</code>代表非负的整数，<code>&lt;i&gt;</code>代表是 int 类型数据，<code>&lt;l&gt;</code> 代表 long 类型，<code>&lt;f&gt;</code>代表 float 类型，<code>&lt;d&gt;</code>代表 double 类型。</p>
<p>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</p>
<h3 id="复习：再谈操作数栈与局部变量表"><a href="#复习：再谈操作数栈与局部变量表" class="headerlink" title="复习：再谈操作数栈与局部变量表"></a>复习：再谈操作数栈与局部变量表</h3><p><strong>1、操作数栈</strong></p>
<p>我们知道，Java 字节码是Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。在解释执行过程中，每当为Java 方法分配栈桢时，Java 虚拟机往往需要开辟一块额外的空间作为<strong>操作数栈，来存放计算的操作数以及返回结果</strong>。</p>
<p>具体来说便是：执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数機中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入中。</p>
<p><strong>2、局部变量表（Local Variables）</strong></p>
<p>Java 方法桢的另外一个重要组成部分则是局部变量区，字节码程序可以将计算的结果缓存在局部变量区之中。</p>
<p>实际上，Java 虚拟机将局部变量区当成一个数组，依次存放 this 指针（仅非静态方法），所传入的参数，以及字节码中的局部变量。</p>
<p>和操作数栈一样，Long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621084753169.png" alt="image-20210621084753169"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085050120.png" alt="image-20210621085050120"></p>
<p>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p>
<h3 id="1-局部变量压栈指令"><a href="#1-局部变量压栈指令" class="headerlink" title="1-局部变量压栈指令"></a>1-局部变量压栈指令</h3><p>局部变量压栈指令将给定的局部变量表中的数据压入操作数。</p>
<p>这类指令大体可以分为：</p>
<p>​        &gt;<code>xload_ &lt;n&gt;</code> (x 为 i、l、f、d、a, n 为 0 到 3) </p>
<p>​        &gt;<code>xload</code> (x 为 i、l、f、d、a）</p>
<p>说明：在这里，x 的取值表示数据类型。</p>
<p>指令 xload_n 表示将第 n 个局部变量压入操作数，比如 iload_1、fload_0、aload_0 等指令。其中 aload_n 表示将个对象引用压栈。</p>
<p>指令 xload 通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了 4 个，比如指令 iload、fload 等</p>
<p><strong>￼举例分析</strong></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085858658.png" alt="image-20210621085858658"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621085922759.png" alt="image-20210621085922759"></p>
<h3 id="2-常量入栈指令"><a href="#2-常量入栈指令" class="headerlink" title="2-常量入栈指令"></a>2-常量入栈指令</h3><p>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 <code>const</code>系列、<code>push</code> 系列和 <code>ldc</code> 指令。</p>
<p><strong>指令 <code>const</code> 系列</strong>：用于对特定的常量入，入的常量隐含在指令本身里。指令有：<code>const_&lt;i&gt;</code> (i 从-1 到 5)、<code>lconst_&lt;l&gt;</code> (l 从 0 到 1)、<code>fconst_ &lt;f&gt;</code> (f 从 0 到 2)、<code>dconst_&lt;d&gt;</code> (d 从 0 到 1)、aconst_null。</p>
<p> 比如，</p>
<p> iconst_m1 将 -1 压入操作数栈；</p>
<p> iconst _x (x 为到 5) 将 x 压入栈：</p>
<p> lconst_0、lconst_1 分别将长整数 0 和 1 压入栈；</p>
<p> fconst_0、fconst_1、fconst_2 分别将浮点数0、1、2 压入栈；</p>
<p> dconst_0 和 dconst_1 分别将 doublet 型 0 和 1 压入栈。</p>
<p> aconst_null 将 null 压入操作数</p>
<p>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整数，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</p>
<p><strong>指令 <code>push</code> 系列</strong>：主要包括 biush 和 sipush。它们的区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数， sipus 接收 16 位整数，它们都将参数压入栈。</p>
<p><strong>指令 <code>ldc</code> 系列</strong>：如果以上指令都不能满足需求，那么可以使用万能的 ldc 指令，它可以接收一个 8 位的参数，该参数指向常量池中的 int、float 或者 String 的索引，将指定的内容压入堆栈。</p>
<p>类似的还有 ldc_w，它接收两个 8 位参数，能支持的索引范围大于 ldc。</p>
<p>如果要压入的元素是 long 或者 double 类型的，则使用 ldc2_w 指令，使用方式都是类似的。</p>
<p>总结如下：</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621091752821.png" alt="image-20210621091752821"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092109463.png" alt="image-20210621092109463"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621092316340.png" alt="image-20210621092316340"></p>
<p>注意：常量入栈指令中的n和局部变量压栈指令中的n不一样，本次的n代表数值或者对象，而不是局部变量表中的下标</p>
<h3 id="3-出栈入局部变量表指令"><a href="#3-出栈入局部变量表指令" class="headerlink" title="3-出栈入局部变量表指令"></a>3-出栈入局部变量表指令</h3><p>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。这类指令主要以 store 的形式存在，比如 xstore (x 为 i、l、f、d、a）、xstore_n (x 为 i、l、f、d、a, n 为 0 至 3)。</p>
<p>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它值给局部变量索引 n 位置。</p>
<p>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</p>
<p><strong>说明：</strong></p>
<p>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第 1 个位置。类似的还有  istore_0、istore_2、istore_3, 它们分别表示从操作数顶弹出一个元素，存放在局部变量表第 0、2、3 个位置。</p>
<p>由于局部变量表前几个位置总是非常常用，因此这种做法虽然増加了指令数量，但是可以大大压缩生成的字节码的体积如果局部变量表很大，需要存储的槽位大于 3, 那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置。</p>
<h2 id="算数指令"><a href="#算数指令" class="headerlink" title="算数指令"></a>算数指令</h2><p><strong>1、作用：</strong></p>
<p>算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</p>
<p><strong>2、分类：</strong></p>
<p>大体上算数指令可以分为两种：对整型数据进行运算的指令与对浮点类型数据进行运算的指令。</p>
<p><strong>3、byte、short、char和boolean类型说明</strong></p>
<p>在每一大类中，都有针对Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095121174.png" alt="image-20210621095121174"></p>
<p><strong>4、运算时的溢出</strong></p>
<p>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常 ArithmeticException。</p>
<p><strong>5、运算模式</strong></p>
<p>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；</p>
<p>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</p>
<p><strong>6、NaN值使用</strong></p>
<p>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</p>
<p><strong>对于无穷大和NaN的举例</strong></p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095607569.png" alt="image-20210621095607569" style="zoom:50%;">

<h3 id="1-所有算数指令"><a href="#1-所有算数指令" class="headerlink" title="1-所有算数指令"></a>1-所有算数指令</h3><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095751219.png" alt="image-20210621095751219" style="zoom:50%;">

<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621095952979.png" alt="image-20210621095952979" style="zoom:50%;">

<p>参数i=5，绿色表示局部变量表，蓝色表示操作数栈。</p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621100011574.png" alt="image-20210621100011574" style="zoom:50%;">



<h3 id="2-比较指令的说明"><a href="#2-比较指令的说明" class="headerlink" title="2-比较指令的说明"></a>2-比较指令的说明</h3><p>比较指令的作用是比较顶两个元素的大小，并将比较结果入栈。</p>
<p>比较指令有：dampg, dcmpl、fcmpg、fcmpl、lcmp。</p>
<p>​        与前面讲解的指令类似，首字符 d 表示 double 类型，f表示 float,l 表示 long。</p>
<p>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令。以 float 为例，有 fcmp 和 fcmpl 两个指</p>
<p>令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。</p>
<p>指令 dcmpl 和 dampg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
<p>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令。</p>
<p><strong>举例</strong></p>
<p>指令 fcmpg 和 fcmpl 都从中弹出两个操作数，并将它们做比较，设顶的元素为 v2, 栈顶顺位第 2 位的元素为 v1, 若</p>
<p>v1=v2, 则压入0；若 v1&gt; v2 则压入 1: 若 v1 &lt;v2 则压入-1。</p>
<p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1, 而 fcmpl 会压入-1。</p>
<p>数值类型的数据，才与以谈大小！ </p>
<p>boolean、引用数据类型不能比较大小</p>
<p><strong>注意</strong>：NaN(Not a Number)表示不是一个数字，比如0.0/0.0得到的可能是1.0（两个数相等），也可能是0.0（0.0是分子），也可能是无穷大（0.0是分母），所以老师给出的解释是NaN代表无法确定是什么数字，只有double和float类型中可能出现NaN的情况，而long类型不会出现NaN，所以只有lcmp。</p>
<h3 id="3-i-amp-i"><a href="#3-i-amp-i" class="headerlink" title="3- ++i&amp;i++"></a>3- ++i&amp;i++</h3><p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101720616.png" alt="image-20210621101720616" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101758904.png" alt="image-20210621101758904" style="zoom:33%;"></p>
<p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101835404.png" alt="image-20210621101835404" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621101855081.png" alt="image-20210621101855081" style="zoom:33%;"></p>
<p><strong>结论</strong>：如果只是i++和++i，字节码相同</p>
<p><img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102017955.png" alt="image-20210621102017955" style="zoom:33%;">的字节码为<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621102040391.png" alt="image-20210621102040391" style="zoom:33%;"></p>
<p><strong>结论</strong>：a=i++是将局部变量表中的10先加载到操作数栈，再对局部变量表中的10+1；然后再将操作数栈中的10存储到局部变量表中索引为2的空间中</p>
<p>b=j++是先将局部变量表中的20自加1之后再加载到操作数栈，然后在存储到局部变量表中</p>
<h2 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h2><p><strong>1、类型转换指令说明</strong></p>
<p>①类型转换指令可以将两种不同的数值类型进行相互转换。</p>
<p>②这些转换操作一般用于实现用户代码中的<strong>显式类型转换操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<h3 id="1-宽化类型转换"><a href="#1-宽化类型转换" class="headerlink" title="1-宽化类型转换"></a>1-宽化类型转换</h3><p><strong>1.转换规则</strong></p>
<p>Java 虚拟机直接支持以下数值的宽化类型转换（widening numeric conversion，小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括：</p>
<p>​        从 int 类型到 long、float 或者 double 类型。对应的指令为：i21、i2f、i2d</p>
<p>​        从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</p>
<p>​        从 float 类型到 double 类型。对应的指令为：f2d</p>
<p>简化为：<code>int--&gt;long--&gt; foat--&gt; double</code></p>
<p><strong>2.精度损失问题</strong></p>
<p>2.1 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</p>
<p>2.2 从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数值。</p>
<p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java 虚拟机抛出运行时异常。</p>
<p><strong>3.补充说明</strong></p>
<p>从 byte、char 和 short类型到 int 类型的宽化类型转换实际上是不存在的。对于 byte 类型转为 int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将 byte 转为 long 时，使用的是 i2l, 可以看到在内部 byte 在这里己经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：</p>
<p>​        一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只意使用一个字节表示指令，因此指令总数不能超过 256个，为了节省指令资源，将 short/和 byte 当做 int 处理也在情理之中。</p>
<p>​        另一方面，由于局部变量表中的槽位固定为 32 位，无论是 byte 或者 short 存入局部变量表，都会占用 32 位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p>
<h3 id="2-窄化类型转换"><a href="#2-窄化类型转换" class="headerlink" title="2-窄化类型转换"></a>2-窄化类型转换</h3><p><strong>1.转化规则</strong></p>
<p>Java 虚拟机也直接支持以下窄化类型转换:</p>
<p>​        从 int 类型至 byte、short 或者 char 类型。对应的指令有：i2b、i2c、i2s </p>
<p>​        从 long 类型到 int 类型。对应的指令有：l2i</p>
<p>​        从行 float 类型到 int 或者 long 类型。对应的指令有：f2i、f2l</p>
<p>​        从 doub1e 类型到 int、long 或者 float 类型。对应的指令有：d2i、d2l、d2f</p>
<p><strong>2.精度损失问题</strong></p>
<p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<p><strong>3.补充说明</strong></p>
<p>3.1 当将一个浮点值窄化转换为整数类型 T (T 限于 int 或 long 类型之一）的时候，将遵循以下转换规则：</p>
<p>​        如果浮点值是 NaN，那转换结果就是 int 或 long 类型的0。</p>
<p>​        如果浮点值不是无穷大的话，浮点值使用 IEEE754 的向零舍入模式取整，获得整数值 v，如果V在目标类型 T (int 或 long）的表示范围之内，那转换结果就是V。否则，将根据 V 的符号，转换为 T 所能表示的最大或者最小正数</p>
<p>3.2 当将一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</p>
<p>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这 3 条规则判断：</p>
<p>​        如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</p>
<p>​        如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</p>
<p>​        对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</p>
<p><strong>注意</strong>：从float、double、long等类型往byte、short、char类型转换的时候，需要先把前面几种类型转换成int类型，然后在从int类型转换到后面这几种类型，所以int类型相等于一种过渡类型</p>
<h2 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h2><p>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p>
<h3 id="1-创建指令"><a href="#1-创建指令" class="headerlink" title="1-创建指令"></a>1-创建指令</h3><p>虽然类实例和数组都是对象，但Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</p>
<p><strong>1. 创建类实例的指令：</strong></p>
<p>创建类实例的指令：new</p>
<p>​        它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈。</p>
<p><strong>2. 创建数组的指令：</strong></p>
<p>创建数组的指令：newarray、anewarray、mu tianewarray</p>
<p>​         newarray：创建基本类型数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anewarray：创建引用类型数</span><br><span class="line"></span><br><span class="line">multianewarray：创建多维数组</span><br></pre></td></tr></table></figure>

<p>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也非常高。</p>
<p><strong>需要注意的细节：</strong></p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105624505.png" alt="image-20210621105624505" style="zoom:50%;">

<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621105652436.png" alt="image-20210621105652436" style="zoom:50%;">

<p>两个创建二维数组的字节码中的差距需要注意</p>
<h3 id="2-字段访问指令"><a href="#2-字段访问指令" class="headerlink" title="2-字段访问指令"></a>2-字段访问指令</h3><p>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p>
<p>​        <em>访问类字段（static 字段，或者称为类变量）的指令：getstatic、putstatic</em> </p>
<p>​        <em>访问类实例字段（非 static 字段，或者称为实例变量）的指令：getfied、putfield</em></p>
<p>举例：</p>
<p>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的</p>
<p>对象或者值，并将其压入操作数栈。</p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113216931.png" alt="image-20210621113216931" style="zoom:50%;">

<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621113249177.png" alt="image-20210621113249177" style="zoom:50%;">

<p>注意：<code>get***</code>是入栈，而<code>put***</code>是出栈</p>
<h3 id="3-数组操作指令"><a href="#3-数组操作指令" class="headerlink" title="3-数组操作指令"></a>3-数组操作指令</h3><p>数组操作指令主要有：xastore 和 xaload 指令。具体为：</p>
<p>​        把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、 daload、aalad</p>
<p>​        将一个操作数的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、 faster、dastore、aastore</p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621114243226.png" alt="image-20210621114243226" style="zoom:50%;">

<p>取数组长度的指令：arraylength</p>
<p>​        该指令弹出顶的数组元素，获取数组的长度，将长度压入栈</p>
<p><strong>说明</strong></p>
<p>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令xaload 在执行时，要求操作数中栈顶元素为数组素引，顶顺位第 2 个元素为数组引用 a，该指令会弹出栈顶这两个元素，并将 <code>a[i]</code>重新压入栈。</p>
<p> xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定引赋值。在 iastore 执行前，操作数栈顶需要以此准备 3 个元素：值、索引、数组引用，restores 会弹出这 3 个值，并将值赋给数组中指定索引的位置。</p>
<h3 id="4-类型检查指令"><a href="#4-类型检查指令" class="headerlink" title="4-类型检查指令"></a>4-类型检查指令</h3><p>检查类实例或数组类型的指令：instanceof、checkcast。</p>
<p>​        指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数，否则它会抛出 ClassCastException 异常。</p>
<p>​        指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。</p>
<h2 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h2><h3 id="1-方法调用指令"><a href="#1-方法调用指令" class="headerlink" title="1-方法调用指令"></a>1-方法调用指令</h3><p>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</p>
<p>以下 <strong>5 条指令</strong>用于方法调用：</p>
<p>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java 语言中最常见的方法分派方式。</p>
<p> invokeinterface 指令用于调用接口方法，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。</p>
<p> invokespecia 指令用于调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）、私有方法和父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态派发。</p>
<p> invokestatic 指令用于调用命名类中的类方法（static 方法）。这是<strong>静态绑定</strong>的。</p>
<p> invokedynamic：调用动态绑定的方法，这个是JDK1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。</p>
<p><strong>注意：</strong> </p>
<p>1、invokedynamic老师不讲，估计是很少遇到吧</p>
<p>2、invokeinterface是对接口而言的，用属于接口类型的对象调用方法的时候就是这个</p>
<p>3、invokespecial只有构造器、私有方法、super.方法名()调用父类方法这几种情况，其中调用父类方法这种情况可能出现其直接父类没有该方法，那就可以调用其父类继承的父类中的该方法，最终找到一个方法调用就是了.  这几种方法都是不会被重写的</p>
<p>4、invokestatic是调用static静态方法，无论是使用对象.静态方法名()还是类名.静态方法名()都是invokestatic，也不难理解</p>
<p>5、invokevirtual是调用类中的非静态普通方法，而这种实例方法可能调用的是子类重写的非静态普通方法，比如A a = new B();a.hello()，其中B类继承A类，并且B类重写了A类中的hello()方法，这种情况下就是invokevirtual了，但是有可能该类没有子类，调用的就是本类中的非静态普通方法，这种情况也是invokevirtual了</p>
<h3 id="2-方法返回指令"><a href="#2-方法返回指令" class="headerlink" title="2-方法返回指令"></a>2-方法返回指令</h3><p>方法调用结束前，需要进行返回。方法返回指令是根据返回值的类型区分的。</p>
<p>​        包括 ireturn（当返回值是 boolean、byte、char、short 和 int 类型时使用）、lreturn、freturn、 dreturn 和 areturn</p>
<p>​        另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用。</p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621133956414.png" alt="image-20210621133956414" style="zoom:50%;">

<p>举例：</p>
<p>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃。</p>
<p>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</p>
<p>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621135828244.png" alt="image-20210621135828244"></p>
<h2 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h2><p>如同操作一个普通数据结构中的堆那样，JVM 提供的操作数管理指令，可以用于直接操作操作数的指令。</p>
<p>这类指令包括如下内容：</p>
<p>​        将一个或两个元素从栈顶弹出，并且直接废弃：pop, pop2</p>
<p>​        复制顶一个或两个数值并将复制值或双份的复制值重新压入顶：dup, dup2, dup_x1,  dup2 x1, dup_x2, dup2_x2:</p>
<p>​        将栈最顶端的两个Slot数值位置交换：swap。Java 虚拟机没有提供交换两个 64 位数据类型（long、double）数值的指令。</p>
<p>​        指令 nop，是一个非常特殊的指令，它的字节码为 x。和汇编语言中的 nop 一样，它表示什么都不做。这条指令一般可用于调试、占位等。</p>
<p>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。</p>
<p><strong>说明：</strong></p>
<p>不带_x 的指令是复制栈顶数据并压入顶。包括两个指令，dup 和 dup2。dup 的系数代表要复制的 Slot 个数。</p>
<p>​        dup 开头的指令用于复制 1 个 Sot 的数据。例如 1 个 int 或 1 个 reference 类型数据</p>
<p>​        dup2 开头的指令用于复制 2 个 S1ot 的数据。例如 1 个 1ong，或 2 个 int，或 1 个 int+1 个 float 类型数据</p>
<p>带_x 的指令是复制栈顶数据并插入顶以下的某个位置。共有 4 个指令，dup_x1, dup2_x1,</p>
<p>dup_x2, dup2_x2. 对于带_x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插</p>
<p>入的位置。因此</p>
<p>​        dup_x1 插入位置：1+1=2, 即栈顶 2 个 Slot 下面</p>
<p>​        dup_x2 插入位置：1+2=3, 即栈顶 3 个 Slot 下面</p>
<p>​        dup2_x1 插入位置：2+1=3, 即栈顶 3 个 Slot 下面</p>
<p>​        dup2_x2 插入位置：2+2=4, 即栈顶 4 个 Slot 下面</p>
<p>pop：将顶的 1 个 Slot 数值出。例如 1 个 short 类型数值</p>
<p>pop2: 将栈顶的 2 个 Slot 数值出栈。例如 1 个 double 类型数值，或者 2 个 int 类型数值</p>
<h2 id="控制转义指令"><a href="#控制转义指令" class="headerlink" title="控制转义指令"></a>控制转义指令</h2><p>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为 1) 比较指令、2) 条件跳转指令、3) 比较条件跳转指令、4) 多条件分支跳转指令、5) 无条件跳转指令等。</p>
<p>比较指令见算数指令</p>
<h3 id="1-条件跳转指令"><a href="#1-条件跳转指令" class="headerlink" title="1-条件跳转指令"></a>1-条件跳转指令</h3><p>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</p>
<p>条件跳转指令有：ifeq, iflt, ifle, ifne, ifgt, ifge, ifnull, ifnonnull。这些指令都接收两个字节的操作数用于计算跳转的位置（16 位符号整数作为当前位置的 offset）。</p>
<p>它们的统一含义为：弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621152715017.png" alt="image-20210621152715017"></p>
<p>注意</p>
<ol>
<li>与前面运算规则一致：</li>
</ol>
<p>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成</p>
<p>对于 long、float、double：类型的条件分支比较操作，则会先执行相应类型的比较运算指令，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转</p>
<ol>
<li><p>由于各类型的比较最终都会转为 int 类型的比较操作，所以Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621153319123.png" alt="image-20210621153319123"></p>
<p>⚠️这里是满足条件就跳转，而源程序中是满足条件则继续执行 </p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621155510988.png" alt="image-20210621155510988"></p>
<p>这里需要⚠️，print函数最后输出的是boolean类型的，当前操作数栈中的1作为参数传到print方法中以后，此处的print方法是调用的返回值为boolean的重载方法，如下图</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160314388.png" alt="image-20210621160314388"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621160603355.png" alt="image-20210621160603355"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162110106.png" alt="image-20210621162110106"></p>
</li>
</ol>
<p><strong>注意：</strong> </p>
<p>1、对于float、double、long类型的比较，它们比较之后生成的是int类型的0、1、-1，这个过程可以使用<strong>比较指令和条件跳转指令</strong> 来完成，虽然得到的是int类型的值，但是System.out.println(XXX)中的值是布尔类型，你可以在jclasslib中的常量池信息中看到写的是Z，代表布尔值类型</p>
<p>2、int类型值（包含byte、char、short）比较 和 对象类型值比较需要使用<strong>比较条件跳转指令</strong> </p>
<h3 id="2-比较条件跳转指令"><a href="#2-比较条件跳转指令" class="headerlink" title="2-比较条件跳转指令"></a>2-比较条件跳转指令</h3><p>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</p>
<p>这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_ icmpgt、if_ icmple、if_icmpge、if_ acmpeq和 if_ acmpne。其中指令助记符加上“if_”后，以字符“i”开头的指令针对int型整数操作（也包括 short 和 byte 类型），以字符“a”开头的指令表示对象引用的比较。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162346744.png" alt="image-20210621162346744"></p>
<p>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且没有任何数据入。<strong>如果预设条件成立，则执行跳转，否则，继续执行下条语句。</strong></p>
<p><strong>举例如下</strong></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621162751624.png" alt="image-20210621162751624"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621163632471.png" alt="image-20210621163632471"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164348661.png" alt="image-20210621164348661"></p>
<p><strong>总结：</strong></p>
<p>只有int或者用int表示的类型可以直接使用<strong>比较条件跳转指令</strong>；</p>
<p>double，float，long则需要<strong>比较指令</strong>和<strong>条件跳转指令</strong>共同使用才能完成跳转。</p>
<h3 id="3-多条件分支跳转"><a href="#3-多条件分支跳转" class="headerlink" title="3-多条件分支跳转"></a>3-多条件分支跳转</h3><p>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621164743732.png" alt="image-20210621164743732"></p>
<p>从助记符上看，两者都是 switch 语句的实现，它们的区别：</p>
<p>​         tableswitch 要求多个条件分支值是连续的，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此效率比较高。</p>
<p>​        指令 lookupswitch 内部存放着各个离散的 case- offset 对，每次执行都要搜索全部的 case- offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此效率较低。</p>
<p>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203815830.png" alt="image-20210621203815830"></p>
<p>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑，将 <strong>case- offset 对按照 case 值大小排</strong>序，给定 index 时，需要査查找与 index 相等的 case，获得其offset，如果找不到则跳转到 default。指令 lookupswitch 如下图所示。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621203953038.png" alt="image-20210621203953038"></p>
<p><strong>举例如下</strong></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171348274.png" alt="image-20210621171348274"></p>
<p>如果将case2中的break注释掉，</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621171614629.png" alt="image-20210621171614629"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202029361.png" alt="image-20210621202029361"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621202709783.png" alt="image-20210621202709783"></p>
<p>这里对字符串的比较，先比较哈希值，哈希值相同再比较值是否相等</p>
<h3 id="4-无条件跳转"><a href="#4-无条件跳转" class="headerlink" title="4-无条件跳转"></a>4-无条件跳转</h3><p>目前主要的无条件跳转指令为 goto。指令 goto 接收<strong>两个字节</strong>的操作数，共同组成一个带符号的整数，用于指定指令的偏移量指令执行的目的就是跳转到偏移量给定的位置处。</p>
<p>如果指令偏移量太大，超过双字节的帯符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它<strong>接收 4 个字节</strong>的操作数，可以表示更大的地址范围。</p>
<p>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且己经被虛拟机<em>逐渐废弃</em>，故不在这里介绍这两个指令。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204052272.png" alt="image-20210621204052272"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621204647802.png" alt="image-20210621204647802"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205120603.png" alt="image-20210621205120603"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205408219.png" alt="image-20210621205408219"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205643514.png" alt="image-20210621205643514"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621205815307.png" alt="image-20210621205815307"></p>
<h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>异常及异常的处理：</p>
<p>过程一：异常对象的生成过程—&gt; throw(手动/自动) —-&gt;指令：athrow </p>
<p>过程二：异常的处理：抓抛模型。try- catch- finaly —-&gt;使用异常表</p>
<h3 id="1-抛出异常指令"><a href="#1-抛出异常指令" class="headerlink" title="1-抛出异常指令"></a>1-抛出异常指令</h3><p>(1) athrow 指令</p>
<p>在Java 程序中显示抛出异常的操作（throw 语句）都是由 athrow 指令来实现。</p>
<p>除了使用 throw 语句显示抛出异常情况之外，JVM 规范还规定了许多运行时异常会在其他Java 虚拟机指令检测到异常状况时自动抛出。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出  ArithmeticException 异常。</p>
<p> (2) 注意</p>
<p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是在抛异常时，Java 虚拟机会清除操作数上的所有内容，而后将异常实例压入调用者操作数栈上。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621221625270.png" alt="image-20210621221625270"></p>
<p>如果使用throw new 异常名称() 这种形式来抛出异常，那就会在代码中出现athrow指令，而在方法上面添加throw 异常名称 这种形式来抛出异常，然后使用jclasslib的时候就会出现在方法下面多出现一个属性Exceptions，如下图所示：</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223049071.png" alt="image-20210621223049071"></p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210621223157782.png" alt="image-20210621223157782"></p>
<h3 id="2-异常处理与异常表"><a href="#2-异常处理与异常表" class="headerlink" title="2-异常处理与异常表"></a>2-异常处理与异常表</h3><p><strong>1、处理异常：</strong></p>
<p>在 Java 虚拟机中，处理异常（catch 语句）不是由字节码指令来实现的（早期使用 jsr、ret 指令），而是采用异常表来完成的。</p>
<p><strong>2、异常表</strong></p>
<p>如果一个方法定义了一个 try- catch 或者 try- finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者  finally 块的信息。异常表保存了每个异常处理信息。比如</p>
<p>​        起始位置</p>
<p>​        结束位置</p>
<p>​        程序计数器记录的代码处理的偏移地址</p>
<p>​        被捕获的异常类在常量池中的索引</p>
<p><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结并弹出当前栈帧</strong>，并且异常会重新抛给上层调用的方法（在调用方法帧）。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致JVM 自己终止，比如这个线程是个 main 线程。</p>
<p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行</strong>。在这种情况下，如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finaly 块来完成目标</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622092751237.png" alt="image-20210622092751237"></p>
<p>栈中压入创建的异常实例信息后，会和异常表中的一场类型进行比对，因此说异常处理是通过异常表进行的</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622093823020.png" alt="image-20210622093823020"></p>
<p><strong>这里的异常处理，其实是重新做了一遍finally里面的事情，因为finally里面的代码时一定要执行，如果未发生异常，则上面的代码不会中断，顺利执行完finally中的代码，如果发生异常，在异常处理中也要执行finally中的代码。</strong></p>
<h2 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h2><p>组成</p>
<p>java 虚拟机支持两种同步结构：<strong>方法级的同步和方法内部一段指令序列的同</strong>步，这两种同步都是使用 monitor 来支持的</p>
<h3 id="1-方法级的同步"><a href="#1-方法级的同步" class="headerlink" title="1-方法级的同步"></a>1-方法级的同步</h3><p>方法级的同步：<strong>是隐式的</strong>，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONZED 访问标志得知一个方法是否声明为同步方法</p>
<p>当调用方法时，调用指令将会检方法的 ACC_SYNCHRONIZED 访问标志是否设置。</p>
<p>​        如果设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁。</p>
<p>​        在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁</p>
<p>​        如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622112918956.png" alt="image-20210622112918956" style="zoom:50%;">

<p>说明：</p>
<p>这段代码和普通的无同步操作的代码没有什么不同，没有使用 <strong>monitorenter 和 monitorexiti 进</strong>行同步区控制。这是因为，对于同步方法而言，当虚拟机通<strong>过方法的访问标示</strong>符判断是一个同步方法时<strong>，会自动在方法调用前进行加锁，当</strong>同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和  monitorexit 指令是<strong>隐式存在的</strong>，并未直接出现在字节码中。</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622113055258.png" alt="image-20210622113055258"></p>
<h3 id="2-方法内指令指令序列的同步"><a href="#2-方法内指令指令序列的同步" class="headerlink" title="2-方法内指令指令序列的同步"></a>2-方法内指令指令序列的同步</h3><p>同步一段指令集序列：通常是由 java 中的 synchronized 语句块来表示的。jvm 的指令集有 monitorenter 和  monitorexit 两条指令来支持 synchronized 关键字的语义。</p>
<p>当一个线程进入同步代码块时，它使用 monitorenterl 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入;若为 1, 则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为0，才会被允许进入同步块。</p>
<p>当线程退出同步块时，需要使用 monitorexit 声明退出。在Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</p>
<p>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</p>
<p>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程 4 离开临界区后，线程 1、2、3 才有可能进入。</p>
<img src="/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622095830957.png" alt="image-20210622095830957" style="zoom:50%;">

<p>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</p>
<p>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令</p>
<p><img src="/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/image-20210622101528989.png" alt="image-20210622101528989"></p>

    </div>
    
    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    <i class="fa fa-qrcode fa-2x" style="line-height:35px;"></i>
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="superBaby 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="superBaby 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>superBaby
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liuermenghhh.github.io/2021/06/27/%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/" title="字节码指令集与解析举例">https://liuermenghhh.github.io/2021/06/27/字节码指令集与解析举例/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

    
      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"># -JVM</i></a>
          </div>
    
        

    
        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/06/25/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E8%BF%87%E7%A8%8B%EF%BC%89%E8%AF%A6%E8%A7%A3/" rel="prev" title="类的加载过程（类的生命过程）详解">
      <i class="fa fa-chevron-left"></i> 类的加载过程（类的生命过程）详解
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B"><span class="nav-number">1.</span> <span class="nav-text">字节码指令集与解析举例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">执行模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">字节码与数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E5%88%86%E6%9E%90"><span class="nav-number">1.1.3.</span> <span class="nav-text">指令分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.</span> <span class="nav-text">加载与存储指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0%EF%BC%9A%E5%86%8D%E8%B0%88%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">复习：再谈操作数栈与局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8E%8B%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.2.</span> <span class="nav-text">1-局部变量压栈指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B8%B8%E9%87%8F%E5%85%A5%E6%A0%88%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.3.</span> <span class="nav-text">2-常量入栈指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%87%BA%E6%A0%88%E5%85%A5%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.2.4.</span> <span class="nav-text">3-出栈入局部变量表指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.</span> <span class="nav-text">算数指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%89%80%E6%9C%89%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="nav-number">1.3.1.</span> <span class="nav-text">1-所有算数指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.3.2.</span> <span class="nav-text">2-比较指令的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-i-amp-i"><span class="nav-number">1.3.3.</span> <span class="nav-text">3- ++i&amp;i++</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%8C%87%E4%BB%A4"><span class="nav-number">1.4.</span> <span class="nav-text">类型转换指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%BD%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.1.</span> <span class="nav-text">1-宽化类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%AA%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">2-窄化类型转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">对象的创建与访问指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.1.</span> <span class="nav-text">1-创建指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E6%AE%B5%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.2.</span> <span class="nav-text">2-字段访问指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.3.</span> <span class="nav-text">3-数组操作指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%8C%87%E4%BB%A4"><span class="nav-number">1.5.4.</span> <span class="nav-text">4-类型检查指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">1.6.</span> <span class="nav-text">方法调用与返回指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.6.1.</span> <span class="nav-text">1-方法调用指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4"><span class="nav-number">1.6.2.</span> <span class="nav-text">2-方法返回指令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%E7%AE%A1%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">1.7.</span> <span class="nav-text">操作数栈管理指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">1.8.</span> <span class="nav-text">控制转义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.8.1.</span> <span class="nav-text">1-条件跳转指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AF%94%E8%BE%83%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4"><span class="nav-number">1.8.2.</span> <span class="nav-text">2-比较条件跳转指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.8.3.</span> <span class="nav-text">3-多条件分支跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.8.4.</span> <span class="nav-text">4-无条件跳转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.</span> <span class="nav-text">异常处理指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.1.</span> <span class="nav-text">1-抛出异常指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E5%B8%B8%E8%A1%A8"><span class="nav-number">1.9.2.</span> <span class="nav-text">2-异常处理与异常表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4"><span class="nav-number">1.10.</span> <span class="nav-text">同步控制指令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E7%BA%A7%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">1.10.1.</span> <span class="nav-text">1-方法级的同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95%E5%86%85%E6%8C%87%E4%BB%A4%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-number">1.10.2.</span> <span class="nav-text">2-方法内指令指令序列的同步</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="superBaby"
      src="/images/iu.GIF">
  <p class="site-author-name" itemprop="name">superBaby</p>
  <div class="site-description" itemprop="description">记录学习</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liuermenghhh/liuermenghhh.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liuermenghhh&#x2F;liuermenghhh.github.io" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1259492465@qq.com" title="E-Mail → mailto:1259492465@qq.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/5323074186/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;5323074186&#x2F;profile?rightmod&#x3D;1&amp;wvr&#x3D;6&amp;mod&#x3D;personinfo&amp;is_all&#x3D;1" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘二哈</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xPozfJb4WQSAlH28uAjlNdoR-gzGzoHsz',
      appKey     : 'HyKcWABd0XnOctis8UvdK2OM',
      placeholder: ":-)来啊，快活啊",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-CN' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>


  <script async src="/js/fireworks.js"></script>




  <script src="/js/activate-power-mode.min.js"></script>
  <script>
    POWERMODE.colorful = true;
    POWERMODE.shake = false;
    document.body.addEventListener('input', POWERMODE);
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
